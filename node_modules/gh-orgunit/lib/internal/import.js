/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var util = require('util');

var AppsConstants = require('gh-apps/lib/constants');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-orgunit');
var Validator = require('gh-core/lib/validator').Validator;

var OrgUnitAPI = require('gh-orgunit');
var OrgUnitAuthz = require('gh-orgunit/lib/authz');
var OrgUnitDAO = require('gh-orgunit/lib/internal/dao');

/**
 * Import a set of organisational units, event series and events into an organisational unit
 *
 * @param  {Context}        ctx                     Standard context containing the current user and the current app
 * @param  {Number}         id                      The id of the organisational unit into which to import the data
 * @param  {Object}         data                    The organisational units, event series and events to import
 * @param  {Boolean}        deleteMissing           Whether to delete items from the database that aren't in the import data
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 */
var importOrgUnit = module.exports.importOrgUnit = function(ctx, id, data, deleteMissing, callback) {
    // Ensure that the organisational unit is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    // Ensure that the deleteMissing flag is a boolean
    deleteMissing = GrasshopperUtil.getBooleanParam(deleteMissing, false);

    // Ensure that the data structure is an object
    try {
        data = JSON.parse(data);
    } catch (err) {
        log().warn({'id': id, 'err': err}, 'Invalid JSON import data submitted');
        return callback(400, {'code': 400, 'msg': util.format('A valid data object must be provided: %s', err.message)});
    }

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can import an organisational unit'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid organisational unit id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'A valid data object must be provided'}).isObject(data);
    validator.check(null, {'code': 400, 'msg': 'A valid deleteMissing flag must be provided'}).isBoolean(deleteMissing);
    if (validator.hasErrors()) {
        return callback(validator.getErrors());
    }

    // Ensure the organisational unit exists
    OrgUnitAPI.getOrgUnit(ctx, id, false, function(err, orgUnit) {
        if (err) {
            return callback(err);
        }

        // We only support importing data on `timetable` applications
        if (orgUnit.App.type !== AppsConstants.types.TIMETABLE) {
            return callback({'code': 400, 'msg': 'This type of application does not allow you to import data'});
        }

        // We only support imports on `course`, `subject` or `part` nodes
        if (orgUnit.type !== 'course' && orgUnit.type !== 'subject' && orgUnit.type !== 'part') {
            return callback({'code': 400, 'msg': 'We only support importing data on courses, subjects or parts'});
        }

        // Ensure the current user can import data into the organisational unit
        OrgUnitAuthz.canUpdateOrgUnit(ctx, orgUnit, function(err, canImport) {
            if (err) {
                return callback(err);
            } else if (!canImport) {
                log().warn({'id': orgUnit.id}, 'Unauthorized attempt at importing an organisational unit');
                return callback({'code': 401, 'msg': 'You are not allowed to import the organisational unit'});
            }

            _getParentIfNecessary(orgUnit, function(err, parent) {
                if (err) {
                    return callback(err);
                }

                // Prior to merging, verify the external ids are unique WITHIN the import tree. If this
                // weren't the case, this would get lost in the merge process which would be really painful
                // to debug. We need to have validated that `data` is an object first though
                _validateImportDataExternalId(validator, data);
                if (validator.hasErrors()) {
                    return callback(validator.getErrors());
                }

                OrgUnitDAO.exportOrgUnit(orgUnit, 'json', function(err, exportedOrgUnit) {
                    if (err) {
                        return callback(err);
                    }

                    // Overlay the import tree over the data that's already present in the database
                    var mergedData = mergeTrees(exportedOrgUnit, data, deleteMissing);

                    // Ensure the imported data doesn't create validation errors
                    _validateImport(validator, mergedData.tree, parent);
                    if (validator.hasErrors()) {
                        return callback(validator.getErrors());
                    }

                    // Import the merged data and remove the data that needs to be removed (if any)
                    return OrgUnitDAO.importTree(orgUnit.AppId, mergedData, callback);
                });
            });
        });
    });
};

/**
 * Get the parent of an organisational unit if it has one
 *
 * @param  {OrgUnit}    orgUnit             The organisational unit for which to get the parent
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {OrgUnit}    callback.parent     The organisational unit's parent
 * @api private
 */
var _getParentIfNecessary = function(orgUnit, callback) {
    if (!orgUnit.ParentId) {
        return callback();
    }

    // Get the entire parent tree of the given organisational unit. Since we only allow to import
    // on courses, subjects or parts, we should only have to fetch at most 2 organisational units
    var options = {
        'where': {
            'ParentId': orgUnit.ParentId
        },
        'include': [
            {'model': DB.OrgUnit, 'include': []}
        ]
    };
    DB.OrgUnit.findOne(options).complete(function(err, parent) {
        if (err) {
            return callback(err);
        }

        return callback(null, parent);
    });
};

/**
 * Recursively iterate through a tree and validate that an external id has been provided for each
 * node. This function will also validate that the structure has a maximum depth of 15 nodes.
 *
 * @param  {Validator}      validator        The validator to validate each node with
 * @param  {Object}         node             An organisational unit, series or event node to validate
 * @api private
 */
var _validateImportDataExternalId = function(validator, node, _seenExternalIds, _level) {
    _seenExternalIds = _seenExternalIds || {};
    _level = _level || 1;

    // We don't validate the root node as it's not strictly necessary so it's one less thing the
    // importer has to think of
    if (_level > 1 || node.externalId) {
        validator.check(node.externalId, {'code': 400, 'msg': util.format('A valid externalId must be provided for %s', node.displayName)}).notEmpty();
        validator.check(_seenExternalIds[node.externalId], {'code': 400, 'msg': util.format('Duplicate externalId found: %s', node.externalId)}).isNull();
        _seenExternalIds[node.externalId] = true;
    }

    // Iterate through all the child nodes (this includes series and events)
    var childNodes = _.union(node.children, node.series, node.events);
    _.each(childNodes, function(child) {
        _validateImportDataExternalId(validator, child, _seenExternalIds, _level + 1);
    });
};

/**
 * Validate an import tree
 *
 * @param  {Validator}      validator       The validator to validate each node with
 * @param  {Object}         tree            The tree to validate
 * @api private
 */
var _validateImport = function(validator, tree, parent) {
    var seenExternalIds = {};
    var seenTypes = {};

    // Add the types of the parents
    if (parent) {
        seenTypes[parent.type] = 0;
        if (parent.parent) {
            seenTypes[parent.parent.type] = -1;
        }
    }

    // The root node of the tree is the organisational unit into which the tree will be
    // imported. Validating that node will recursively iterate through the entire tree
    _validateImportOrgUnit(validator, tree, parent, 1, seenExternalIds, seenTypes);
};

/**
 * Validate an organisational unit. This will recursively validate any child organisational units,
 * series and events
 *
 * @param  {Validator}      validator       The validator to validate each node with
 * @param  {Object}         orgUnit         The organisational unit to validate
 * @param  {Object}         [parent]        The parent of the given `orgUnit`
 * @api private
 */
var _validateImportOrgUnit = function(validator, orgUnit, parent, _currentLevel, _seenExternalIds, _seenTypes) {
    // Perform basic input validation
    _validateOrgUnitMetadata(validator, orgUnit, parent, _currentLevel, _seenTypes);

    // Ensure the external id for this organisational unit is unique within the tree
    if (parent || orgUnit.externalId) {
        validator.check(_seenExternalIds[orgUnit.externalId], {'code': 400, 'msg': util.format('Duplicate externalId found: %s', orgUnit.externalId)}).isNull();
        _seenExternalIds[orgUnit.externalId] = orgUnit.displayName;
    }

    // Validate each child organisational unit
    _.each(orgUnit.children, function(childOrgUnit) {
        _validateImportOrgUnit(validator, childOrgUnit, orgUnit, _currentLevel + 1, _seenExternalIds, _seenTypes);
    });

    // Validate each series within this organisational unit
    _.each(orgUnit.series, function(series) {
        _validateImportSeries(validator, series, _seenExternalIds);
    });

    // TODO: Allow to import events directly associated to an organisational unit
};

/**
 * Validate the metadata for an organisational unit
 *
 * @param  {Validator}      validator           The validator to validate each node with
 * @param  {Object}         orgUnit             The organisational unit to validate
 * @param  {Object}         [parent]        The parent of the given `orgUnit`
 * @param  {Number}         currentLevel        The level on which the organisational unit appears in the entire tree
 * @param  {Object}         seenTypes           A hash that maps previously seen organisational types to the level they were seen on
 * @api private
 */
var _validateOrgUnitMetadata = function(validator, orgUnit, parent, currentLevel, seenTypes) {
    validator.check(orgUnit.displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).notEmpty();
    validator.check(orgUnit.displayName, {'code': 400, 'msg': 'A displayName can be at most 255 characters long'}).isShortString();

    var validTypes = ['course', 'subject', 'part', 'module'];
    validator.check(orgUnit.type, {'code': 400, 'msg': 'A valid type must be provided'}).notEmpty();
    validator.check(orgUnit.type, {'code': 400, 'msg': 'A valid type must be one of: ' + validTypes.join(', ')}).isIn(validTypes);
    // Ensure the type for this organisational unit is not on a different level
    var typeLevel = seenTypes[orgUnit.type] || currentLevel;
    validator.check(currentLevel, {'code': 400, 'msg': util.format('The type for %s was used on a different level', orgUnit.externalId)}).is(typeLevel);
    seenTypes[orgUnit.type] = currentLevel;

    if (orgUnit.description) {
        validator.check(orgUnit.description, {'code': 400, 'msg': 'A description can be at most 1000 characters long'}).isMediumString();
    }
    if (orgUnit.metadata) {
        if (_.isString(orgUnit.metadata)) {
            try {
                orgUnit.metadata = JSON.parse(orgUnit.metadata);
            } catch (e) {
            }
        }
        validator.check(null, {'code': 400, 'msg': 'A metadata object must be provided in JSON'}).isObject(orgUnit.metadata);
    }
    if (orgUnit.published) {
        orgUnit.published = GrasshopperUtil.getBooleanParam(orgUnit.published);
        validator.check(null, {'code': 400, 'msg': 'A valid published flag must be provided'}).isBoolean(orgUnit.published);
    }

    // Validate this type does not break TimeTable specific structure. Organisational units should
    // form a tree structure of:
    // ```
    // course
    //   [ subject ]
    //      part
    //        module
    // ```
    // Keep in mind that the `subject` type is optional
    if (parent) {
        if (!((parent.type === 'course' && orgUnit.type === 'subject') ||
              (parent.type === 'course' && orgUnit.type === 'part') ||
              (parent.type === 'subject' && orgUnit.type === 'part') ||
              (parent.type === 'part' && orgUnit.type === 'module')
        )) {
            validator.error({'code': 400, 'msg': util.format('Nesting a %s under a %s is invalid', orgUnit.type, parent.type)});
        }
    }
};

/**
 * Validate an event series
 *
 * @param  {Validator}  validator           The validator to validate each node with
 * @param  {Object}     series              The series to validate
 * @param  {Object}     seenExternalIds     A hash whose keys are external ids that are associated with other nodes in the tree
 * @api private
 */
var _validateImportSeries = function(validator, series, seenExternalIds) {
    // Perform basic input validation
    validator.check(series.externalId, {'code': 400, 'msg': util.format('A valid externalId must be provided for %s', series.displayName)}).notEmpty();
    validator.check(series.displayName, {'code': 400, 'msg': util.format('A valid displayName must be provided for %s', series.externalId)}).isShortString();
    if (series.description) {
        validator.check(series.description, {'code': 400, 'msg': 'A description can be at most 1000 characters long'}).isMediumString();
    }

    // Ensure the external id for this series is unique within the tree
    validator.check(seenExternalIds[series.externalId], {'code': 400, 'msg': util.format('Duplicate externalId found: %s', series.externalId)}).isNull();
    seenExternalIds[series.externalId] = series.displayName;

    _.each(series.events, function(event) {
        _validateImportEvent(validator, event, seenExternalIds);
    });
};

/**
 * Validate an event
 *
 * @param  {Validator}  validator           The validator to validate each node with
 * @param  {Object}     event               The event to validate
 * @param  {Object}     seenExternalIds     A hash whose keys are external ids that are associated with other nodes in the tree
 * @api private
 */
var _validateImportEvent = function(validator, event, seenExternalIds) {
    // Perform basic input validation
    validator.check(event.displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).notEmpty();
    validator.check(event.displayName, {'code': 400, 'msg': 'A displayName can be at most 255 characters long'}).isShortString();
    validator.check(event.externalId, {'code': 400, 'msg': util.format('A valid externalId must be provided for %s', event.displayName)}).notEmpty();
    validator.check(event.start, {'code': 400, 'msg': util.format('A valid start time must be provided for %s', event.externalId)}).notEmpty();
    validator.check(event.start, {'code': 400, 'msg': util.format('A valid start time must be provided for %s', event.externalId)}).isDate();
    validator.check(event.end, {'code': 400, 'msg': util.format('A valid end time must be provided for %s', event.externalId)}).notEmpty();
    validator.check(event.end, {'code': 400, 'msg': util.format('A valid end time must be provided for %s', event.externalId)}).isDate();
    validator.check(event.start, {'code': 400, 'msg': util.format('The start time must be before the end time for %s', event.externalId)}).isBefore(event.end);
    if (event.description) {
        validator.check(event.description, {'code': 400, 'msg': util.format('A description can be at most 1000 characters long for %s', event.externalId)}).isMediumString();
    }
    if (event.location) {
        validator.check(event.location, {'code': 400, 'msg': util.format('A location can be at most 255 characters long for %s', event.externalId)}).isShortString();
    }
    if (event.type) {
        validator.check(event.type, {'code': 400, 'msg': 'A type can be at most 255 characters long'}).isShortString();
    }
    if (event.notes) {
        validator.check(event.notes, {'code': 400, 'msg': util.format('The notes can be at most 10000 characters long for %s', event.externalId)}).isLongString();
    }

    // Ensure the external id for this event is unique within the tree
    validator.check(seenExternalIds[event.externalId], {'code': 400, 'msg': util.format('Duplicate externalId found: %s', event.externalId)}).isNull();
    seenExternalIds[event.externalId] = event.displayName;
};

/**
 * @typedef MergedTreeData
 * @type {Object}
 * @property {Object}       tree                The result of merging the trees
 * @property {Object[]}     deletedOrgUnits     The organisational units that have been removed from the base tree
 * @property {Object[]}     deletedSeries       The series that have been removed from the base tree
 * @property {Object[]}     deletedEvents       The events that have been removed from the base tree
*/

/**
 * Merge the `importTree` into the `baseTree`. The merge process will try to retain as much
 * properties from the `baseTree` nodes as it can, **even if `deleteMissing` is set to `true`**.
 *
 * @param  {Object}             baseTree            The base tree as generated by `OrgUnitDAO.exportOrgUnit`
 * @param  {Object}             importTree          The tree to import and overlay on top of the `baseTree`
 * @param  {Boolean}            deleteMissing       Whether nodes that aren't specified in the `importTree` should be dropped
 * @return {MergedTreeData}                         The merged tree data
 */
var mergeTrees = module.exports.mergeTrees = function(baseTree, importTree, deleteMissing) {
    var deletedOrgUnits = [];
    var deletedSeries = [];
    var deletedEvents = [];
    var tree = _mergeOrgUnits(baseTree, importTree, deleteMissing, deletedOrgUnits, deletedSeries, deletedEvents);

    return {
        'tree': tree,
        'deletedOrgUnits': deletedOrgUnits,
        'deletedSeries': deletedSeries,
        'deletedEvents': deletedEvents
    };
};

/**
 * Merge two organisational units
 *
 * @param  {Object}         baseOrgUnit         The base organisational unit
 * @param  {Object}         importOrgUnit       The organisational unit to import
 * @param  {Boolean}        deleteMissing       Whether base child organisational units that are not specified as children of `importOrgUnit` should be removed
 * @param  {Object[]}       deletedOrgUnits     The organisational units that have been removed from the base tree
 * @param  {Object[]}       deletedSeries       The series that have been removed from the base tree
 * @param  {Object[]}       deletedEvents       The events that have been removed from the base tree
 * @return {Object}                             The merged organisational unit
 * @api private
 */
var _mergeOrgUnits = function(baseOrgUnit, importOrgUnit, deleteMissing, deletedOrgUnits, deletedSeries, deletedEvents) {
    var mergedOrgUnit = {
        'id': baseOrgUnit.id,
        'externalId': baseOrgUnit.externalId,
        '_type': 'orgUnit',

        'displayName': importOrgUnit.displayName || baseOrgUnit.displayName,
        'type': importOrgUnit.type || baseOrgUnit.type,
        'description': importOrgUnit.description || baseOrgUnit.description,
        'metadata': importOrgUnit.metadata || baseOrgUnit.metadata,
        'published': importOrgUnit.published || baseOrgUnit.published,

        'children': [],
        'series': []
    };

    // Merge the children of the two organisational units. If we're not deleting missing data, we
    // copy all the child organisational units from the base organisational unit.
    if (!deleteMissing) {
        mergedOrgUnit.children = baseOrgUnit.children;
    }
    // Add or merge in imported child organisational units
    _.each(importOrgUnit.children, function(childOrgUnit) {
        var childToAdd = childOrgUnit;

        // If the child organisational unit already exists, we need to merge it with the import
        // organisational unit
        var baseChild = _.find(baseOrgUnit.children, {'externalId': childOrgUnit.externalId});
        if (baseChild) {
            childToAdd = _mergeOrgUnits(baseChild, childOrgUnit, deleteMissing, deletedOrgUnits, deletedSeries, deletedEvents);
        }

        // Add or update the child organisatioanl unit
        _upsert(mergedOrgUnit.children, childToAdd);
    });

    // Keep track of which child organisational units were deleted
    _.each(baseOrgUnit.children, function(child) {
        if (!_.find(mergedOrgUnit.children, {'id': child.id})) {
            deletedOrgUnits.push(child);

            // Delete all the series associated to the child organisational unit
            _.each(deletedOrgUnits.series, function(series) {
                deletedSeries.push(series);

                // Delete all the events in the series
                _.each(series.events, function(event) {
                    deletedEvents.push(event);
                });
            });

            // TODO: Events directly associated to the organisational unit
        }
    });

    // Merge the series of the two organisational units. If we're not deleting missing data, we
    // copy all the series from the base organisational unit
    if (!deleteMissing) {
        mergedOrgUnit.series = baseOrgUnit.series;
    }
    // Add or merge in imported series
    _.each(importOrgUnit.series, function(importSeries) {
        var seriesToAdd = importSeries;

        // If the series already exists, we need to merge it with the import series
        var baseSeries = _.find(baseOrgUnit.series, {'externalId': importSeries.externalId});
        if (baseSeries) {
            seriesToAdd = _mergeSeries(baseSeries, importSeries, deleteMissing, deletedEvents);
        }

        // Add or update the series
        _upsert(mergedOrgUnit.series, seriesToAdd);
    });
    _.each(baseOrgUnit.series, function(series) {
        if (!_.find(mergedOrgUnit.series, {'id': series.id})) {
            // Delete the series
            deletedSeries.push(series);

            // Delete the events in the series
            _.each(series.events, function(event) {
                deletedEvents.push(event);
            });
        }
    });

    // TODO: Events directly associated to an organisational unit

    return mergedOrgUnit;
};

/**
 * Merge two series
 *
 * @param  {Object}     baseSeries          The base series
 * @param  {Object}     importSeries        The series to import
 * @param  {Boolean}    deleteMissing       Whether base events that are not specified as events of `importSeries` should be removed
 * @param  {Object[]}   deletedEvents       The events that have been removed from the base tree
 * @return {Object}                         The merged series
 * @api private
 */
var _mergeSeries = function(baseSeries, importSeries, deleteMissing, deletedEvents) {
    var mergedSeries = {
        'id': baseSeries.id,
        'externalId': baseSeries.externalId,
        '_type': 'series',

        'displayName': importSeries.displayName || baseSeries.displayName,
        'description': importSeries.description || baseSeries.description,

        'events': []
    };

    // Merge the events of the two series. If we're not deleting missing data, we copy all the
    // events from the base series
    if (!deleteMissing) {
        mergedSeries.events = baseSeries.events;
    }
    // Add or merge in imported events
    _.each(importSeries.events, function(importEvent) {
        var eventToAdd = importEvent;

        // If the event already exists, we need to merge it with the import event
        var baseEvent = _.find(baseSeries.events, {'externalId': importEvent.externalId});
        if (baseEvent) {
            eventToAdd = _mergeEvents(baseEvent, importEvent, deleteMissing);
        }

        // Add or update the event
        _upsert(mergedSeries.events, eventToAdd);
    });
    // Keep track of which events were deleted
    _.each(baseSeries.events, function(event) {
        if (!_.find(mergedSeries.events, {'id': event.id})) {
            deletedEvents.push(event);
        }
    });

    return mergedSeries;
};

/**
 * Merge two events
 *
 * @param  {Object}     baseEvent           The base series
 * @param  {Object}     importEvent         The series to import
 * @param  {Boolean}    deleteMissing       Whether organisers are not specified as organisers of `importEvent` should be removed
 * @return {Object}                         The merged series
 * @api private
 */
var _mergeEvents = module.exports._mergeEvents = function(baseEvent, importEvent, deleteMissing) {
    var mergedEvent = {
        'id': baseEvent.id,
        'externalId': baseEvent.externalId,
        '_type': 'event',

        'displayName': importEvent.displayName || baseEvent.displayName,
        'description': importEvent.description || baseEvent.description,
        'type': importEvent.type || baseEvent.type,
        'notes': importEvent.notes || baseEvent.notes,
        'location': importEvent.location || baseEvent.location,
        'start': importEvent.start || baseEvent.start,
        'end': importEvent.end || baseEvent.end,
        'organisers': []
    };

    var allOrganisers = _.union(baseEvent.organisers, importEvent.organisers);
    var organiserOther = _.chain(allOrganisers)
        .filter(function(organiser) {
            return (!organiser.shibbolethId);
        })
        .uniq()
        .value();
    var organiserUsers = _.chain(allOrganisers)
        .filter(function(organiser) {
            return (organiser.shibbolethId);
        })
        .uniq('shibbolethId')
        .value();

    mergedEvent.organisers = _.union(organiserOther, organiserUsers);

    return mergedEvent;
};

/**
 * Find an item in a set by its externalId and replace it. If an item could not be found, it will
 * be pushed into the set
 *
 * @param  {Object[]}   set         The set of items to upsert the item into
 * @param  {Object}     item        The item to upsert
 * @api private
 */
var _upsert = function(set, item) {
    var index = _.findIndex(set, {'externalId': item.externalId});
    if (index === -1) {
        set.push(item);
    } else {
        set[index] = item;
    }
};
