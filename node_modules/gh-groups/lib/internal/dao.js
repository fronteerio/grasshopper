/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-groups');

/**
 * Create a group
 *
 * @param  {Number}         appId               The id of the application on which to create the group
 * @param  {Number[]}       [members]           An optional set of users that should be added to the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group}          callback.group      The created group
 */
var createGroup = module.exports.createGroup = function(appId, members, callback) {
    // TODO: Transaction
    var group = {
        'AppId': appId
    };
    DB.Group.create(group).complete(function(err, group) {
        if (err) {
            log().error({'err': err}, 'Failed to create a new group');
            return callback({'code': 500, 'msg': err.message});
        }

        _addGroupMembers(group, members, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, group);
        });
    });
};

/**
 * Get the members of a group
 *
 * @param  {Group}          group               The group whose members to get
 * @param  {Number}         limit               The amount of users that should be returned
 * @param  {Number}         offset              The paging number of the results to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {User[]}         callback.users      The users that are members of the group
 */
var getGroupMembers = module.exports.getGroupMembers = function(group, limit, offset, callback) {
    var options = {
        'limit': limit,
        'offset': offset,
        'order': [['displayName', 'ASC']]
    };
    group.getMembers(options).complete(function(err, members) {
        if (err) {
            log().error({'err': err, 'id': group.id}, 'Unable to retrieve a group\'s members');
            return callback({'code': 500, 'msg': 'Unable to retrieve a group\'s members'});
        }

        return callback(null, members);
    });
};

/**
 * Get the memberships of a user
 *
 * @param  {User}           user                The user whose memberships to get
 * @param  {Number}         limit               The amount of groups that should be returned
 * @param  {Number}         offset              The paging number of the results to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group[]}        callback.groups     The groups that the user is a member of
 */
var getUserMemberships = module.exports.getUserMemberships = function(user, limit, offset, callback) {
    var options = {
        'limit': limit,
        'offset': offset
    };
    user.getMemberships(options).complete(function(err, groups) {
        if (err) {
            log().error({'err': err, 'id': group.id}, 'Unable to retrieve a user\'s memberships');
            return callback({'code': 500, 'msg': 'Unable to retrieve a user\'s memberships'});
        }

        return callback(null, groups);
    });
};

/**
 * Update the members of a group
 *
 * @param  {Group}          group               The group whose members to update
 * @param  {Object}         memberUpdates       The members to add to or remove from the group. The keys should hold the user ids and the value should be a boolean indicating whether the user should be added(true) or removed(false)
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var updateGroupMembers = module.exports.updateGroupMembers = function(group, memberUpdates, callback) {
    // Due to a bug in Sequelize (https://github.com/sequelize/sequelize/issues/3592) we have to fetch
    // the existing members of the group here before adding and/or removing users
    group.getMembers().complete(function(err, members) {
        if (err) {
            return callback(err);
        }

        // Get the ids of the members (keep in mind that Sequelize objects don't support _.pluck)
        var memberUserIds = _.map(members, function(member) {
            return member.id;
        });

        // Add a set of users
        var newMembers = _.chain(memberUpdates)
            .keys()
            // Get the new members
            .filter(function(userId) {
                return memberUpdates[userId];
            })
            .map(function(userId) {
                return parseInt(userId, 10);
            })
            // Filter out users who are already a member
            .filter(function(userId) {
                return (!_.contains(memberUserIds, userId));
            })
            .value();

        // TODO: Transaction
        _addGroupMembers(group, newMembers, function(err) {
            if (err) {
                return callback(err);
            }

            // Remove a set of members
            var membersToRemove = _.chain(memberUpdates)
                .keys()
                .filter(function(userId) {
                    return !memberUpdates[userId];
                })
                .map(function(userId) {
                    return parseInt(userId, 10);
                })

                // Only retain those user ids that are also members
                .intersection(memberUserIds)
                .value();
            _removeGroupMembers(group, membersToRemove, callback);
        });
    });
};

/**
 * Add a set of users to a group
 *
 * @param  {Group}          group               The group to add the users to
 * @param  {Number[]}       newMembers          The ids of the users to add to the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _addGroupMembers = function(group, newMembers, callback) {
    if (_.isEmpty(newMembers)) {
        return callback();
    }

    group.addMembers(newMembers).complete(function(err) {
        if (err) {
            log().error({'err': err, 'id': group.id, 'memberIds': newMembers}, 'Failed to add members to a group');
            return callback({'code': 500, 'msg': 'Failed to add members to a group'});
        }

        return callback();
    });
};

/**
 * Remove a set of users from a group
 *
 * @param  {Group}          group               The group to add the users to
 * @param  {Number[]}       membersToRemove     The ids of the users to remove from the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _removeGroupMembers = function(group, membersToRemove, callback) {
    if (_.isEmpty(membersToRemove)) {
        return callback();
    }

    group.removeMembers(membersToRemove).complete(function(err) {
        if (err) {
            log().error({'err': err, 'id': group.id, 'memberIds': membersToRemove}, 'Failed to remove members from a group');
            return callback({'code': 500, 'msg': 'Failed to remove members from a group'});
        }

        return callback();
    });
};

/**
 * Get the groups a user is a member of
 *
 * @param  {Number}         userId              The id of the user for whom to retrieve the group memberships
 * @param  {Number}         limit               The amount of groups that should be returned
 * @param  {Number}         offset              The paging number of the results to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group[]}        callback.groups     The groups that the user is a member of
 */
var getUserGroups = module.exports.getUserGroups = function(userId, limit, offset, callback) {
    var options = {
        'limit': limit,
        'offset': offset,
        'where': {'id': userId},
        'include': [
            {'model': DB.Group, 'as': 'Memberships', 'include': [
                {'model': DB.User, 'as': 'LockedBy'}
            ]}
        ]
    };
    DB.User.findOne(options).complete(function(err, user) {
        if (err) {
            log().error({'id': userId}, 'Could not get groups for a user');
            return callback({'code': 500, 'msg': 'Failed to add members to a group'});
        }

        return callback(null, user.Memberships);
    });
};

/**
 * Get a group by its id. The members and user who locked
 * the group will be included.
 *
 * @param  {Number}     id                      The id of the group to retrieve
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Group}      callback.group          The retrieved group
 */
var getGroup = module.exports.getGroup = function(id, callback) {
    var options = {
        'where': {'id': id},
        'include': [
            {'model': DB.User, 'as': 'Members'},
            {'model': DB.User, 'as': 'LockedBy'}
        ]
    };
    DB.Group.findOne(options).complete(function(err, group) {
        if (err) {
            log().error({'err': err, 'id': id}, 'Failed to get a group');
            return callback({'code': 500, 'msg': 'Failed to get a group'});
        } else if (!group) {
            log().error({'err': err, 'id': id}, 'Could not find a group');
            return callback({'code': 404, 'msg': 'Could not find a group'});
        }

        return callback(null, group);
    });
};

/**
 * Determine whether a user is a member of a group. If the group's members
 * are already pre-loaded, no query will take place.
 *
 * @param  {Group}      group                   The group whose members to check
 * @param  {User}       user                    The user to check
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Boolean}    callback.isMember       `true` if the user is a member of the group, `false` otherwise
 */
var isMember = module.exports.isMember = function(group, user, callback) {
    // If we've eager loaded the group members, we can do a synchronous check
    if (group.Members) {
        var member = _.find(group.Members, function(member) {
            return (member.id === user.id);
        });
        var isMember = _.isObject(member);
        return callback(null, isMember);
    }

    // Otherwise, we need to hit the database
    group.hasMember(user).complete(callback);
};

/**
 * Lock a group
 *
 * @param  {Group}          group               The group to lock
 * @param  {User}           user                The user who is locking the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var lock = module.exports.lock = function(group, user, callback) {
    // TODO: Transaction
    group.setLockedBy(user).complete(function(err) {
        if (err) {
            log().error({'err': err, 'user': user.id, 'group': group.id}, 'Failed to lock a group (user)');
            return callback({'code': 500, 'msg': 'Failed to lock a group'});
        }

        group.updateAttributes({'lockedOn': Date.now()}).complete(function(err) {
            if (err) {
                log().error({'err': err, 'user': user.id, 'group': group.id}, 'Failed to lock a group (timestamp)');
                return callback({'code': 500, 'msg': 'Failed to lock a group'});
            }

            return callback();
        });
    });
};

/**
 * Release the lock on a group
 *
 * @param  {Group}          group               The group to release the lock from
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var releaseLock = module.exports.releaseLock = function(group, callback) {
    // TODO: Transaction
    group.setLockedBy(null).complete(function(err) {
        if (err) {
            log().error({'err': err, 'user': user.id, 'group': group.id}, 'Failed to release a lock on a group (user)');
            return callback({'code': 500, 'msg': 'Failed to release a lock on a group'});
        }

        group.updateAttributes({'lockedOn': null}).complete(function(err) {
            if (err) {
                log().error({'err': err, 'user': user.id, 'group': group.id}, 'Failed to release a lock on a group (timestamp)');
                return callback({'code': 500, 'msg': 'Failed to release a lock on a group'});
            }

            return callback();
        });
    });
};
