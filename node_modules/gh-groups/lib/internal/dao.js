/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-groups');

/**
 * Create a group
 *
 * @param  {Number}         appId               The id of the application on which to create the group
 * @param  {Number[]}       [members]           An optional set of users that should be added to the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group}          callback.group      The created group
 */
var createGroup = module.exports.createGroup = function(appId, members, callback) {
    // TODO: Transaction
    var group = {
        'AppId': appId
    };
    DB.Group.create(group).complete(function(err, group) {
        if (err) {
            log().error({'err': err}, 'Failed to create a new group');
            return callback({'code': 500, 'msg': err.message});
        }

        _addGroupMembers(group, members, function(err) {
            if (err) {
                return callback(err);
            }

            return callback(null, group);
        });
    });
};

/**
 * Get the users that are members of a group
 *
 * @param  {Group}          group               The group whose members to get
 * @param  {Number}         limit               The amount of groups that should be returned
 * @param  {Number}         offset              The paging number of the results to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {USer[]}         callback.users      The users that are members of the group
 */
var getGroupMembers = module.exports.getGroupMembers = function(group, limit, offset, callback) {
    var options = {
        'limit': limit,
        'offset': offset,
        'order': [['displayName', 'ASC']]
    };
    group.getMembers(options).complete(function(err, members) {
        if (err) {
            log().error({'err': err, 'id': group.id}, 'Unable to retrieve a group\'s members');
            return callback({'code': 500, 'msg': 'Unable to retrieve a group\'s members'});
        }

        return callback(null, members);
    });
};

/**
 * Update a group's members
 *
 * @param  {Group}          group               The group whose members to update
 * @param  {Object}         memberUpdates       The members to add to or remove from the group. The keys should hold the user ids and the value should be a boolean indicating whether the user should be added(true) or removed(false)
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var updateGroupMembers = module.exports.updateGroupMembers = function(group, memberUpdates, callback) {
    var newMembers = _.chain(memberUpdates)
        .keys()
        .filter(function(userId) {
            return memberUpdates[userId];
        })
        .map(function(userId) {
            return parseInt(userId, 10);
        })
        .value();
    var membersToRemove = _.chain(memberUpdates)
        .keys()
        .filter(function(userId) {
            return !memberUpdates[userId];
        })
        .map(function(userId) {
            return parseInt(userId, 10);
        })
        .value();

    // TODO: Transaction
    _addGroupMembers(group, newMembers, function(err) {
        if (err) {
            return callback(err);
        }

        _removeGroupMembers(group, membersToRemove, callback);
    });
};

/**
 * Add a set of users to a group
 *
 * @param  {Group}          group               The group to add the users to
 * @param  {Number[]}       newMembers          The ids of the users to add to the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _addGroupMembers = function(group, newMembers, callback) {
    if (_.isEmpty(newMembers)) {
        return callback();
    }

    group.addMembers(newMembers).complete(function(err) {
        if (err) {
            log().error({'err': err, 'id': group.id, 'memberIds': newMembers}, 'Failed to add members to a group');
            return callback({'code': 500, 'msg': 'Failed to add members to a group'});
        }

        return callback();
    });
};

/**
 * Remove a set of users from a group
 *
 * @param  {Group}          group               The group to add the users to
 * @param  {Number[]}       membersToRemove     The ids of the users to remove from the group
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @api private
 */
var _removeGroupMembers = function(group, membersToRemove, callback) {
    if (_.isEmpty(membersToRemove)) {
        return callback();
    }

    group.removeMembers(membersToRemove).complete(function(err) {
        if (err) {
            log().error({'err': err, 'id': group.id, 'memberIds': membersToRemove}, 'Failed to remove members from a group');
            return callback({'code': 500, 'msg': 'Failed to remove members from a group'});
        }

        return callback();
    });
};

/**
 * Get the groups a user is a member of
 *
 * @param  {Number}         userId              The id of the user for whom to retrieve the group memberships
 * @param  {Number}         limit               The amount of groups that should be returned
 * @param  {Number}         offset              The paging number of the results to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group[]}        callback.groups     The groups that the user is a member of
 */
var getUserGroups = module.exports.getUserGroups = function(userId, limit, offset, callback) {
    var options = {
        'limit': limit,
        'offset': offset,
        'where': {'id': userId},
        'include': [
            {'model': DB.Group, 'as': 'Memberships', 'include': [
                {'model': DB.User, 'as': 'LockedBy'}
            ]}
        ]
    };
    DB.User.find(options).complete(function(err, user) {
        if (err) {
            log().error({'id': userId}, 'Could not get groups for a user');
            return callback({'code': 500, 'msg': 'Failed to add members to a group'});
        }

        return callback(null, user.Memberships);
    });
};

/**
 * Get a group by its id. The Members and user who locked
 * the group will be included.
 *
 * @param  {Number}     id                      The id of the group to retrieve
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Group}      callback.group          The retrieved group
 */
var getGroup = module.exports.getGroup = function(id, callback) {
    var options = {
        'where': {'id': id},
        'include': [
            {'model': DB.User, 'as': 'Members'},
            {'model': DB.User, 'as': 'LockedBy'}
        ]
    };
    DB.Group.find(options).complete(function(err, group) {
        if (err) {
            log().error({'err': err, 'id': id}, 'Failed to get a group');
            return callback({'code': 500, 'msg': 'Failed to get a group'});
        } else if (!group) {
            log().error({'err': err, 'id': id}, 'Could not find a group');
            return callback({'code': 404, 'msg': 'Could not find a group'});
        }

        return callback(null, group);
    });
};

/**
 * Determine whether a user is a member of a group. If the group's members
 * are already pre-loaded, no query will take place.
 *
 * @param  {Group}      group                   The group whose members to check
 * @param  {User}       user                    The user to check
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Boolean}    callback.isMember       `true` if the user is a member of the group, `false` otherwise
 */
var isMember = module.exports.isMember = function(group, user, callback) {
    // If we've eager loaded the group members, we can do a synchronous check
    if (group.Members) {
        var member = _.find(group.Members, {'id': user.id});
        var isMember = _.isObject(member);
        return callback(null, isMember);
    }

    // Otherwise, we need to hit the database
    group.hasMember(user).complete(callback);
};
