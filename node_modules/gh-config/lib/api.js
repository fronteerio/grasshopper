/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var events = require('events');

var AppsDAO = require('gh-apps/lib/internal/dao');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-config');
var Pubsub = require('gh-core/lib/pubsub');
var Validator = require('gh-core/lib/validator').Validator;

var ConfigDAO = require('./internal/dao');

// Holds the full config objects
var cachedConfigs = {};

// Holds the config objects that can be returned to anonymous and regular users. Config values
// such as the Shibboleth mappings and identity provider's entity ID will be scrubbed
var cachedSuppressedConfigs = {};

/**
 * The Configuration API.
 *
 * ## Events
 *
 * * `cached(appId)`: The configuration for an application has been re-cached. If no `appId` has been specified, all the applications their configuration objects have been recached
 */
var ConfigAPI = module.exports = new events.EventEmitter();

/* Pubsub notifications */

Pubsub.on('config', function(appId) {
    // Ensure that the app id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    ConfigDAO.getApplicationConfig(appId, function(err, config) {
        if (err) {
            log().error({'app': appId}, 'Failed to re-cache the application config for an application');
            return;
        }

        cachedConfigs[appId] = config.toJSON();
        cachedSuppressedConfigs[appId] = _getSuppressedConfig(cachedConfigs[appId]);

        // Indicate that the config values have been re-cached
        ConfigAPI.emit('cached', appId);
    });
});

/* Initialisation */

/**
 * Initialise and cache the configuration objects
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var init = module.exports.init = function(callback) {
    // Set up the config database stuff
    ConfigDAO.init(function(err) {
        if (err) {
            return callback(err);
        }

        // Cache all the application configs
        return _cacheAllApplicationConfigs(callback);
    });
};

/**
 * Cache the config values for all of the available applications
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @api private
 */
var _cacheAllApplicationConfigs = function(callback) {
    // Get all the configs
    ConfigDAO.getAllApplicationConfigs(function(err, configs) {
        if (err) {
            return callback(err);
        }

        // As we are going to hold on to these instances, we get rid of all the unnecessary
        // data (or connections/transactions) that is associated to the config instances
        configs = _.map(configs, function(config) {
            return config.toJSON();
        });

        // The full cached config objects are indexed by their application ids
        cachedConfigs = _.indexBy(configs, 'AppId');

        // The suppressed configs hides some elements and are indexed by their application ids
        cachedSuppressedConfigs = _.chain(configs)
            .map(_getSuppressedConfig)
            .indexBy('AppId')
            .value();

        // Indicate that the config values have been re-cached
        ConfigAPI.emit('cached');

        return callback();
    });
};

/**
 * Given a full config object, get the suppressed config object
 *
 * @param  {Object}     fullConfig      The full config object
 * @return {Object}                     The suppressed config object
 * @api private
 */
var _getSuppressedConfig = function(fullConfig) {
    // Make sure we don't change the full config object
    var suppressedConfig = _.clone(fullConfig);

    // Delete the config fields that should be suppressed
    delete suppressedConfig.shibIdpEntityId;
    delete suppressedConfig.shibExternalIdAttributes;
    delete suppressedConfig.shibMapDisplayname;
    delete suppressedConfig.shibMapEmail;
    delete suppressedConfig.statsd;
    delete suppressedConfig.termsAndConditionsText;

    // Return the suppressed config object
    return suppressedConfig;
};

/* Get an app config */

/**
 * Get the full cached config object for an application. This function
 * does not perform any authorization checks, this should only be used
 * by internal logic
 *
 * @param  {Number}     appId   The id of the application for which to get the full config object
 * @return {Object}             The cached full config object
 */
module.exports.config = function(appId) {
    // Parameter validation
    if (!appId) {
        throw new Error('An app id must be provided');
    }

    return cachedConfigs[appId];
};

/**
 * Get the cached config objects for all the applications. This function does not perform any
 * authorization checks and should only be used by internal logic
 *
 * @return {Object[]}           The cached configuration objects
 */
var getAllCachedConfigs = module.exports.getAllCachedConfigs = function() {
    return cachedConfigs;
};

/**
 * Get the config feed for an application from the cache, containing all the config values
 * for that application. Admin users will receive all config values, including those for
 * suppressed fields. Non-admin users will receive all of the non-suppressed config values
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current application
 * @param  {Number}     appId               The id of the application for which to get the configuration
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Object}     callback.config     The cached application config
 */
var getApplicationConfig = module.exports.getApplicationConfig = function(ctx, appId, callback) {
    // Ensure that the app id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    // Parameter validation
    var validator = new Validator();
    validator.check(appId, {'code': 400, 'msg': 'A valid application id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the current user is allowed to retrieve the configuration
    if (ctx.app.id !== appId && (!ctx.user || !ctx.user.canAdmin(appId))) {
        return callback({'code': 401, 'msg': 'You cannot retrieve the config from another application'});

    // Ensure the application exists
    } else if (!cachedConfigs[appId]) {
        return callback({'code': 404, 'msg': 'Unknown application'});
    }

    // If the user can administer the application, we return the full configuration object
    if (ctx.user && ctx.user.canAdmin(appId)) {
        return callback(null, cachedConfigs[appId]);

    // Otherwise we return the suppressed configuration
    } else {
        return callback(null, cachedSuppressedConfigs[appId]);
    }
};

/**
 * Update an application config
 *
 * @param  {Context}    ctx                 Standard context object containing the current user and the current application
 * @param  {Number}     appId               The id of the application whose configuration object to update
 * @param  {Object}     update              The object that holds the updated values. See `ConfigDAO.EDITABLE_FIELDS`
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var updateConfig = module.exports.updateConfig = function(ctx, appId, update, callback) {
    update = update || {};

    // Ensure that the app id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    // Parameter validation
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can update an application config'}).isLoggedInUser(ctx);
    validator.check(appId, {'code': 400, 'msg': 'A valid application id must be provided'}).isInt();
    validator.check(_.keys(update).length, {'code': 400, 'msg': 'At least one config field needs to be specified'}).min(1);
    _.each(update, function(val, key) {
        validator.check(key, {'code': 400, 'msg': 'Unknown config field'}).isIn(ConfigDAO.EDITABLE_FIELDS);

        // Config fields that start with `allow` or `enable` should be boolean values
        if (key.indexOf('allow') === 0 || key.indexOf('enable') === 0) {
            val = GrasshopperUtil.getBooleanParam(val);
            validator.check(null, {'code': 400, 'msg': 'Boolean value expected for ' + key}).isBoolean(val);
            update[key] = val;
        }

        // A valid integer must be provided for the `academic year` config field
        if (key === 'academicYear') {
            val = GrasshopperUtil.getNumberParam(val);
            validator.check(val, {'code': 400, 'msg': 'Integer value expected for ' + key}).isInt();
            update[key] = val;
        }
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Keep track of when a Terms and Conditions value gets changed
    if (_.has(update, 'termsAndConditionsEnabled') || _.has(update, 'termsAndConditionsText')) {
        update.termsAndConditionsLastUpdate = new Date();
    }

    // Ensure the app exists
    AppsDAO.getApp(appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        // Ensure the user can update the config
        if (!ctx.user.canAdmin(appId)) {
            return callback({'code': 401, 'msg': 'Only administrators can update an application config'});
        }

        ConfigDAO.updateConfig(appId, update, callback);
    });
};
