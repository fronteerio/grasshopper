/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-config');

// The editable fields
var fields = ['allowLocalAccountCreation', 'enableLocalAuth', 'enableShibbolethAuth', 'shibIdpEntityId',
              'shibExternalIdAttributes', 'shibMapDisplayname', 'shibMapEmail', 'allowUserEventCreation',
              'allowUserSerieCreation', 'enableAnalytics', 'analyticsTrackingId', 'academicYear',
              'statsd', 'termsAndConditionsEnabled', 'termsAndConditionsText'];
module.exports.EDITABLE_FIELDS = fields;

/**
 * Initialise the configuration-related database logic. New triggers will be added that ensure
 * that new applications get a configuration row and updates to configuration rows are published
 * over the pub/sub mechanism.
 *
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var init = module.exports.init = function(callback) {
    _setUpAppsTrigger(function(err) {
        if (err) {
            return callback(err);
        }

        _setUpConfigPubSubTrigger(callback);
    });
};

/**
 * Set up a trigger that creates a config row when a new application is created
 *
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _setUpAppsTrigger = function(callback) {
    // Define a trigger that will insert a new config row when an app is created
    var functionQuery = [
        'CREATE OR REPLACE FUNCTION app_config_trigger() RETURNS trigger AS $$',
        'DECLARE',
        'BEGIN',
        '  INSERT INTO "Configs" ("AppId", "createdAt", "updatedAt") VALUES (NEW."id", NOW(), NOW());',
        '  RETURN new;',
        'END;',
        '$$ LANGUAGE plpgsql;'
    ].join('\n');

    // Add the trigger for new applications
    var triggerQuery = [
        'DO $$',
        'BEGIN',
        '    IF NOT EXISTS(SELECT * FROM information_schema.triggers',
        '       WHERE event_object_table = \'Apps\' AND trigger_name = \'app_config_trigger\') THEN',
        '           CREATE TRIGGER app_config_trigger AFTER INSERT ON "Apps"',
        '           FOR EACH ROW EXECUTE PROCEDURE app_config_trigger();',
        '    END IF;',
        'END;',
        '$$'
    ].join('\n');

    var sequelize = DB.getSequelize();

    sequelize.query(functionQuery).complete(function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to create app_config trigger function');
            return callback({'code': 500, 'msg': 'Unable to create config app_config trigger function'});
        }

        sequelize.query(triggerQuery).complete(function(err) {
            if (err) {
                log().error({'err': err}, 'Unable to create app_config trigger');
                return callback({'code': 500, 'msg': 'Unable to create app_config trigger'});
            }

            log().debug('Created app_config trigger and function');
            return callback();
        });
    });
};

/**
 * Set up a trigger that publishes new or updated config rows over pub/sub
 *
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _setUpConfigPubSubTrigger = function(callback) {
    // Define a trigger that will notify the watchers that there
    // is a new or updated configuration row
    var functionQuery = [
        'CREATE OR REPLACE FUNCTION config_trigger() RETURNS trigger AS $$',
        'DECLARE',
        'BEGIN',
        '  PERFORM pg_notify(\'watchers\', \'config \' || NEW."AppId");',
        '  RETURN new;',
        'END;',
        '$$ LANGUAGE plpgsql;'
    ].join('\n');

    // Add the trigger for new or updated config rows
    var triggerQuery = [
        'DO $$',
        'BEGIN',
        '    IF NOT EXISTS(SELECT * FROM information_schema.triggers',
        '       WHERE event_object_table = \'Configs\' AND trigger_name = \'config_trigger\') THEN',
        '           CREATE TRIGGER config_trigger AFTER INSERT OR UPDATE ON "Configs"',
        '           FOR EACH ROW EXECUTE PROCEDURE config_trigger();',
        '    END IF;',
        'END;',
        '$$'
    ].join('\n');

    var sequelize = DB.getSequelize();

    sequelize.query(functionQuery).complete(function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to create pubsub_config trigger function');
            return callback({'code': 500, 'msg': 'Unable to create pubsub_config trigger function'});
        }

        sequelize.query(triggerQuery).complete(function(err) {
            if (err) {
                log().error({'err': err}, 'Unable to create pubsub_config trigger');
                return callback({'code': 500, 'msg': 'Unable to create pubsub_config trigger'});
            }

            log().debug('Created pubsub_config trigger and function');
            return callback();
        });
    });
};

/**
 * Get the configuration objects for all the applications
 *
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Config[]}   callback.configs    All the configuration objects
 */
var getAllApplicationConfigs = module.exports.getAllApplicationConfigs = function(callback) {
    DB.Config.findAll().complete(function(err, configs) {
        if (err) {
            log().error({'err': err}, 'Unable to get all the application configs');
            return callback({'code': 500, 'msg': 'Unable to get all the application configs'});
        }

        return callback(null, configs);
    });
};

/**
 * Get the configuration object for a given application
 *
 * @param  {Number}     appId               The id of the application for which to retrieve the configuration object
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @param  {Config}     callback.config     The configuration object for the given application
 */
var getApplicationConfig = module.exports.getApplicationConfig = function(appId, callback) {
    DB.Config.findOne({'where': {'AppId': appId}}).complete(function(err, config) {
        if (err) {
            log().error({'err': err, 'app': appId}, 'Unable to get an application config');
            return callback({'code': 500, 'msg': 'Unable to get the application config'});
        } else if (!config) {
            log().debug({'app': appId}, 'A config for the specified application could not be found');
            return callback({'code': 404, 'msg': 'Could not find a config for that application'});
        }

        return callback(null, config);
    });
};

/**
 * Update the configuration object for a given application
 *
 * @param  {Number}     appId               The id of the application whose configuration object to update
 * @param  {Object}     update              The updates to persist
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 */
var updateConfig = module.exports.updateConfig = function(appId, update, callback) {
    getApplicationConfig(appId, function(err, config) {
        if (err) {
            return callback(err);
        }

        config.updateAttributes(update).complete(function(err) {
            if (err) {
                log().error({'err': err, 'app': appId}, 'Unable to update an application config');
                return callback({'code': 500, 'msg': 'Unable to update the application config'});
            }

            return callback();
        });
    });
};
