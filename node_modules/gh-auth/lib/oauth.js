/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var moment = require('moment');
var url = require('url');
var util = require('util');

var AppsAPI = require('gh-apps');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-auth-oauth');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var AuthOauthDAO = require('./oauth/dao');
var AuthOauthUtil = require('./oauth/util');

/**
 * Create an oauth client
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Number}         appId               The id of the target app server
 * @param  {String}         displayName         The display name of the client
 * @param  {String}         redirectUri         The redirect uri of the client
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {OauthClient}    callback.client     The created oauth client
 */
var createClient = module.exports.createClient = function(ctx, appId, displayName, redirectUri, callback) {
    appId = GrasshopperUtil.getNumberParam(appId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can create a client'}).isAdmin(ctx, appId);
    validator.check(appId, {'code': 400, 'msg': 'An integer app id must be specified'}).isInt();
    validator.check(displayName, {'code': 400, 'msg': 'A display name must be specified'}).notEmpty();
    validator.check(displayName, {'code': 400, 'msg': 'A display name can be at most 255 characters long'}).isShortString();
    validator.check(redirectUri, {'code': 400, 'msg': 'A valid redirect URI must be specified'}).isUrl();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        return AuthOauthDAO.createClient(app, displayName, AuthOauthUtil.generateClientSecret(), redirectUri, callback);
    });
};

/**
 * Update an oauth client
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {Number}         clientId                The id of the client to update
 * @param  {Object}         fields                  The fields to update
 * @param  {String}         [fields.displayName]    The display name to update
 * @param  {String}         [fields.redirectUri]    The redirect uri to udpate
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {OauthClient}    callback.client         The updated oauth client
 */
var updateClient = module.exports.updateClient = function(ctx, clientId, fields, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);
    fields = fields || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can update a client'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    validator.check(_.keys(fields).length, {'code': 400, 'msg': 'At least one field to update must be specified'}).min(1);

    if (fields.displayName) {
        validator.check(fields.displayName, {'code': 400, 'msg': 'A display name can be at most 255 characters long'}).isShortString();
    }

    if (fields.redirectUri) {
        validator.check(fields.redirectUri, {'code': 400, 'msg': 'A valid redirect URI must be specified'}).isUrl();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can update a client'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        return AuthOauthDAO.updateClient(client, _.ghCompact(fields), callback);
    });
};

/**
 * Disable an oauth client
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Number}         clientId            The id of the client
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {OauthClient}    callback.client     The disabled oauth client
 */
var disableClient = module.exports.disableClient = function(ctx, clientId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can disable a client'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can disable a client'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        } else if (client.disabled) {
            return callback(null, client);
        }

        return AuthOauthDAO.disableClient(client, callback);
    });
};

/**
 * Enable an oauth client
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Number}         clientId            The id of the client
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {OauthClient}    callback.client     The enabled oauth client
 */
var enableClient = module.exports.enableClient = function(ctx, clientId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can enable a client'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can enable a client'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        } else if (!client.disabled) {
            return callback(null, client);
        }

        return AuthOauthDAO.enableClient(client, callback);
    });
};

/**
 * Regenerate the secret of an oauth client
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Number}         clientId            The id of the client
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {OauthClient}    callback.client     The oauth client with the regenerated secret
 */
var regenerateClientSecret = module.exports.regenerateClientSecret = function(ctx, clientId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only administrators can regenerate a client secret'}).isAdmin(ctx, ctx.app.id);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        }

        validator.check(null, {'code': 401, 'msg': 'Only administrators can regenerate a client secret'}).isAdmin(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        return AuthOauthDAO.setClientSecret(client, AuthOauthUtil.generateClientSecret(), callback);
    });
};

/**
 * List oauth clients for a given app
 *
 * @param  {Context}            ctx                 The context of the current request
 * @param  {Number}             appId               The id of the target app server
 * @param  {Object}             [opts]              Optional parameters
 * @param  {Number}             [opts.limit]        The maximum number of oauth clients to list
 * @param  {Number}             [opts.offset]       The beginning offset index from which to start listing clients
 * @param  {Function}           callback            Standard callback function
 * @param  {Object}             callback.err        An error that occurred, if any
 * @param  {OauthClientList}    callback.response   The oauth client list response
 */
var getClients = module.exports.getClients = function(ctx, appId, opts, callback) {
    appId = GrasshopperUtil.getNumberParam(appId);
    opts = opts || {};
    opts.limit = GrasshopperUtil.getNumberParam(opts.limit, 25);
    opts.offset = GrasshopperUtil.getNumberParam(opts.offset, 0);

    var validator = new Validator();
    validator.check(appId, {'code': 400, 'msg': 'An integer app id must be provided'}).isInt();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can list clients'}).isLoggedInUser(ctx, appId);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        AuthOauthDAO.getClients(app, opts, function(err, response) {
            if (err) {
                return callback(err);
            }

            // Transform each client according to the current context
            response.rows = _.map(response.rows, _.curry(AuthOauthUtil.transformClient)(ctx));

            return callback(null, response);
        });
    });
};

/**
 * Get an oauth client
 *
 * @param  {Context}        ctx                 The context of the current request
 * @param  {Number}         id                  The id of the client
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {OauthClient}    callback.client     The oauth client
 */
var getClient = module.exports.getClient = function(ctx, id, callback) {
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'An integer client id must be provided'}).isInt();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can get a client'}).isLoggedInUser(ctx);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the requested client
    AuthOauthDAO.getClient(id, function(err, client) {
        if (err) {
            return callback(err);
        }

        // Ensure the user is authenticated to the client's app
        validator.check(null, {'code': 401, 'msg': 'Only authenticated users can get a client'}).isLoggedInUser(ctx, client.AppId);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        return callback(null, AuthOauthUtil.transformClient(ctx, client));
    });
};

/**
 * Grant an authorization code to a client for either the current user, or on behalf of the
 * specified user
 *
 * @param  {Context}        ctx                     The context of the current request
 * @param  {Number}         clientId                The id of the client
 * @param  {Number}         [forUserId]             The user for which to grant the authorization code, if applicable
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error that occurred, if any
 * @param  {OauthClient}    callback.redirectUri    The uri to which to redirect the user, which contains the generated authorization code
 */
var grantAuthCode = module.exports.grantAuthCode = function(ctx, clientId, forUserId, callback) {
    clientId = GrasshopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can grant an auth code'}).isLoggedInUser(ctx);
    validator.check(clientId, {'code': 400, 'msg': 'An integer client id must be specified'}).isInt();
    if (forUserId) {
        validator.check(forUserId, {'code': 400, 'msg': 'If a user id is specified, it must be an integer'}).isInt();
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Determine if the client exists and if the current user can grant an auth code for it
    AuthOauthDAO.getClient(clientId, function(err, client) {
        if (err) {
            return callback(err);
        } else if (ctx.user.AppId !== client.AppId && !ctx.user.canAdmin(client.AppId)) {
            return callback({'code': 401, 'msg': 'You do not have access to grant an authorization code for the given client'});
        } else if (client.disabled) {
            return callback({'code': 401, 'msg': 'The specified client is disabled'});
        }

        // Determine which user the auth code should be granted for
        var userId = GrasshopperUtil.getNumberParam(forUserId) || ctx.user.id;
        UsersDAO.getUser(userId, function(err, user) {
            if (err) {
                return callback(err);
            } else if (ctx.user.id !== user.id && !ctx.user.canAdmin(user.AppId)) {
                return callback({'code': 401, 'msg': 'Only administrators can grant auth codes for other users'});
            } else if (user.AppId !== client.AppId) {
                return callback({'code': 400, 'msg': 'The id of the given client is not enabled for your app'});
            }

            // Generate a code that lasts for 10 minutes
            var code = AuthOauthUtil.generateAuthCode();
            var expires = moment().add(10, 'minutes');
            AuthOauthDAO.createAuthCode(client, user, code, expires, function(err, authCode) {
                if (err) {
                    return callback(err);
                }

                // Use the client's configured redirect URI. This isn't entirely correct as we could
                // have received a redirect URI from the request. But currently we don't support
                // multiple registered redirect URIs so this is not necessary
                var parsedRedirectUri = url.parse(client.redirectUri, true);

                // Set `code` parameter to the redirect URI. We clear the `search` parameter because
                // we will format the URI afterward
                parsedRedirectUri.query = _.chain(parsedRedirectUri.query)
                    .ghOptional()
                    .extend({'code': code})
                    .value();
                parsedRedirectUri.search = null;

                log().info({
                    'actorId': ctx.user.id,
                    'clientId': clientId,
                    'forUserId': userId,
                    'expires': expires
                }, 'OAuth Authorization Code has been granted for a user');

                return callback(null, url.format(parsedRedirectUri));
            });
        });
    });
};

/**
 * Exchange an authorization code for an access token. In the client access token exchange, a client
 * secret is provided. Since the client id and secret are the "authentication" mechanisms (i.e.,
 * username and password), the check that applies to the secret should have already been done before
 * this function gets invoked
 *
 * @param  {OauthClient}    client          The *authenticated* oauth client that is performing the request
 * @param  {String}         code            The code to exchange for an access token
 * @param  {String}         redirectUri     The redirect uri of the client
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error that occurred, if any
 * @param  {String}         callback.token  The access token that can be used to perform "bearer" authenticated requests
 */
var exchangeAuthCode = module.exports.exchangeAuthCode = function(client, code, redirectUri, callback) {
    var validator = new Validator();
    validator.check(code, {'code': 400, 'msg': 'An authorization code must be specified'}).notEmpty();
    validator.check(client, {'code': 400, 'msg': 'A valid client must be specified'}).notEmpty();
    validator.check(redirectUri, {'code': 400, 'msg': 'A valid redirect URI must be specified'}).isUrl();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    } else if (client.disabled) {
        return callback({'code': 401, 'msg': 'The specified client has been disabled'});
    } else if (client.redirectUri !== redirectUri) {
        return callback({'code': 401, 'msg': util.format('The specified redirect uri "%s" does not match the redirect uri configured for the client')});
    }

    AuthOauthDAO.getAuthCodeByCode(code, function(err, authCode) {
        if (err) {
            return callback(err);
        } else if (authCode.OauthClientId !== client.id) {
            return callback({'code': 401, 'msg': 'The provided authorization code does not map to the specified client'});
        } else if (authCode.expires.getTime() <= Date.now()) {
            return callback({'code': 401, 'msg': 'The provided authorization code has expired'});
        }

        UsersDAO.getUser(authCode.UserId, function(err, user) {
            if (err) {
                return callback(err);
            }

            AuthOauthDAO.getAccessTokenByUserAndClient(user, client, function(err, accessToken) {
                if (err && err.code !== 404) {
                    return callback(err);
                } else if (accessToken) {
                    log().info({
                        'clientId': client.id,
                        'redirectUri': redirectUri,
                        'userId': user.id
                    }, 'A client exchanged an authorization code for an access token');
                    return callback(null, accessToken.token);
                }

                var token = AuthOauthUtil.generateAccessToken();
                AuthOauthDAO.createAccessToken(client, user, token, function(err, accessToken) {
                    if (err) {
                        return callback(err);
                    }

                    log().info({
                        'clientId': client.id,
                        'redirectUri': redirectUri,
                        'userId': user.id
                    }, 'A client exchanged an authorization code for an access token');

                    return callback(null, token);
                });
            });
        });
    });
};

/**
 * Get access tokens for the specified user
 *
 * @param  {Context}                ctx                 The context of the current request
 * @param  {Number}                 userId              The id of the user for which to get access tokens
 * @param  {Number}                 [opts]              The user for which to grant the authorization code, if applicable
 * @param  {Number}                 [opts.limit]        The maximum number of oauth access tokens to list
 * @param  {Number}                 [opts.offset]       The beginning offset index from which to start listing access tokens
 * @param  {Function}               callback            Standard callback function
 * @param  {Object}                 callback.err        An error that occurred, if any
 * @param  {OauthAccessTokenList}   callback.response   The uri to which to redirect the user, which contains the generated authorization code
 */
var getAccessTokensByUser = module.exports.getAccessTokensByUser = function(ctx, userId, opts, callback) {
    userId = GrasshopperUtil.getNumberParam(userId);
    opts = opts || {};
    opts.limit = GrasshopperUtil.getNumberParam(opts.limit, 25);
    opts.offset = GrasshopperUtil.getNumberParam(opts.offset, 0);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can list access tokens for a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'An integer user id must be specified'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    UsersDAO.getUser(userId, function(err, user) {
        if (err) {
            return callback(err);
        } else if (ctx.user.id !== user.id && !ctx.user.canAdmin(user.AppId)) {
            return callback({'code': 401, 'msg': 'Only administrators or the user themself can list access tokens for a user'});
        }

        AuthOauthDAO.getAccessTokensByUser(user, _.pick(opts, 'limit', 'offset'), function(err, response) {
            if (err) {
                return callback(err);
            }

            // Transform the access token results according to the context
            response.rows = _.map(response.rows, _.curry(AuthOauthUtil.transformAccessToken)(ctx));

            return callback(null, response);
        });
    });
};

/**
 * Delete an access token by its token
 *
 * @param  {Context}    ctx             The context of the current request
 * @param  {String}     token           The token of the access token
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 */
var deleteAccessTokenByToken = module.exports.deleteAccessTokenByToken = function(ctx, token, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can delete an access token'}).isLoggedInUser(ctx);
    validator.check(token, {'code': 400, 'msg': 'An access token must be specified'}).notEmpty();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    AuthOauthDAO.getAccessTokenByToken(token, function(err, accessToken) {
        if (err) {
            return callback(err);
        } else if (!ctx.user.canAdmin(accessToken.OauthClient.AppId) && ctx.user.id !== accessToken.UserId) {
            return callback({'code': 401, 'msg': 'Only administrators or token owners can delete an access token'});
        }

        return AuthOauthDAO.deleteAccessToken(accessToken, callback);
    });
};
