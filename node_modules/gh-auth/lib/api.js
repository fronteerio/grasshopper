/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var crypto = require('crypto');
var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;

var AdminsDAO = require('gh-admins/lib/internal/dao');
var ConfigAPI = require('gh-config');
var Context = require('gh-context').Context;
var GrassHopper = require('gh-core');
var log = require('gh-core/lib/logger').logger('gh-apps');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var AuthUtil = require('./util');
var ShibbolethAPI = require('./api.shibboleth');
var ShibbolethStrategy = require('./shibboleth/strategy');

/**
 * Initialise the authentication module
 *
 * @param  {Object}         config              The application configuration
 */
var initialise = module.exports.initialise = function(config) {
    // Register the Passport authentication strategies
    registerLocalAuthentication();
    registerShibbolethAuthentication();

    // Register the Passport serializers
    registerSerializeUser(config.cookie.secret);
    registerDeserializeUser(config.cookie.secret);

    // Add the context middleware to the global admin and app Express servers
    // This needs to happen *AFTER* all authentication strategies have been initialized
    GrassHopper.appServer.use(contextMiddleware);
    GrassHopper.globalAdminServer.use(contextMiddleware);

    // Initialise the Shibboleth API
    ShibbolethAPI.refreshConfiguration(config);
};

/**
 * Register the Passport local authentication strategy
 *
 * @api private
 */
var registerLocalAuthentication = function() {
    passport.use(new LocalStrategy({'passReqToCallback': true}, function(req, username, password, done) {
        // The user is logging in as a global administrator
        if (req.ghApp.isGlobalAdmin) {
            _validateGlobalAdminCredentials(req.ghApp, username, password, done);

        // The user is logging in on a regular app
        } else {
            // On a regular application, users log in with their email address. There's no
            // need to check whether `username` and `password` are defined as Passport.js has
            // already done those checks
            var validator = new Validator();
            validator.check(username, 'A valid username must be provided').isEmail();
            if (validator.hasErrors()) {
                return done(null, null, validator.getFirstError());
            }

            _validateLocalUserCredentials(req.ghApp, username, password, done);
        }
    }));
};

/**
 * Validate the login credentials for a global administrator
 *
 * @param  {App}                    app                             The global admin application
 * @param  {String}                 username                        The username of the global administrator to attempt login validation for
 * @param  {String}                 password                        The password to attempt login validation with
 * @param  {Function}               done                            PassportJS callback function
 * @param  {Object}                 done.err                        An error object, if any
 * @param  {Boolean|Object}         done.authInfo                   The global administrator and global admin app for the provided username and password. If the provided password was incorrect, this will be `false`
 * @param  {GlobalAdmin}            done.authInfo.globalAdmin       The global administrator object
 * @param  {App}                    done.authInfo.app               The global admin application
 */
var _validateGlobalAdminCredentials = function(app, username, password, done) {
    // Ensure that a global administrator with the provided username exist
    AdminsDAO.getGlobalAdminByUsername(username, function(err, globalAdmin) {
        // No global administrator could be found for the provided username
        if (err && err.code === 404) {
            log().info({'err': err, 'username': username}, 'The provided global administrator username is incorrect');
            return done(null, false);
        // A different error occured
        } else if (err) {
            log().error({'err': err, 'username': username}, 'Failed to validate the login credentials for a global administrator');
            return done(err);
        }

        var match = AuthUtil.comparePassword(password, globalAdmin.password);
        if (!match) {
            log().info({'err': err, 'username': username}, 'The provided global administrator password is incorrect');
            return done(null, false);
        }

        log().info({'globalAdmin': globalAdmin}, 'Logged in as a global administrator');
        var authInfo = {'user': globalAdmin, 'app': app};
        return done(null, authInfo);
    });
};

/**
 * Validate the login credentials for a local user
 *
 * @param  {App}                    app                     The application to which the user belongs
 * @param  {String}                 email                   The email of the user to attempt login validation for. The email acts as the username
 * @param  {String}                 password                The password to attempt login validation with
 * @param  {Function}               done                    PassportJS callback function
 * @param  {Object}                 done.err                An error object, if any
 * @param  {Boolean|Object}         done.authInfo           The user and app objects for the provided username and password. If the provided password was incorrect, this will be `false`
 * @param  {GlobalAdmin}            done.authInfo.user      The user object
 * @param  {App}                    done.authInfo.app       The application to which the user belongs
 */
var _validateLocalUserCredentials = function(app, email, password, done) {
    // Ensure that a user with the provided credentials exist
    UsersDAO.getUserByCredentials(app.id, 'local', email, function(err, user) {
        // No user could be found for the provided credentials
        if (err && err.code === 404) {
            log().warn({'err': err, 'email': email}, 'The provided user email is incorrect');
            return done(null, false);
        // A different error occured
        } else if (err) {
            log().error({'err': err, 'email': email}, 'Failed to validate the login credentials for a user');
            return done(err);
        }

        var match = AuthUtil.comparePassword(password, user.password);
        if (!match) {
            log().warn({'err': err, 'email': email}, 'The provided user password is incorrect');
            return done(null, false);
        }

        log().debug({'user': user}, 'Logged in as a user with a local authentication strategy');
        var authInfo = {'user': user, 'app': app};
        return done(null, authInfo);
    });
};

/**
 * Register the Passport Shibboleth authentication strategy
 *
 * @api private
 */
var registerShibbolethAuthentication = function() {
    passport.use(new ShibbolethStrategy(function(req, app, headers, callback) {

        log().debug({
            'app': app.id,
            'headers': headers
        }, 'Received Shibboleth authentication callback');

        var config = ConfigAPI.config(app.id);
        var shibExternalIdAttributes = config.shibExternalIdAttributes;
        var shibMapDisplayname = config.shibMapDisplayname;
        var shibMapEmail = config.shibMapEmail;

        // The external ID is configurable in the admin UI as a priority list (similar to
        // how `mod_shib` works). We try to find an attribute in the released set that matches
        // any of the configurable attributes. Rather than relying on `mod_shib`'s `remote_user`
        // attribute, we rely on the configured list as it allows administrators to specify
        // attributes on a per-tenant basis. We use `remote_user` as the fall back value
        var externalId = _getBestAttributeValue(shibExternalIdAttributes, headers, headers['remote_user']);
        if (!externalId) {
            log().error({'headers': headers, 'app': app.id}, 'No suitable attribute was found for the `externalId` attribute');
            return callback({'code': 500, 'msg': 'No suitable attribute was found for the `externalId` attribute'});
        }

        // There are a lot of SAML attributes that may indicate a user's display name. The administrator
        // should provide a suitable priority list to construct the displayName. If no suitable value was
        // returned from the mapping, we fall back to the `remote_user` attribute, as this is always provided
        var displayName = _getBestAttributeValue(shibMapDisplayname, headers, headers['remote_user']);

        // Set the optional profile parameters
        var opts = {};

        // Get an email address from the provided headers. We fall back to `eppn` which may not always
        // contain a valid email address. We only set the `email` value if a valid email has been provided
        var email = _getBestAttributeValue(shibMapEmail, headers, headers['eppn']);
        if (email) {
            var validator = new Validator();
            validator.check(email, {'code': 400, 'msg': 'Invalid email'}).isEmail();
            if (!validator.hasErrors()) {
                opts['email'] = email;
            } else {
                log().warn({'email': email, 'externalId': externalId, 'app': app.id}, 'A user signed in via Shib with an invalid email address');
            }
        }

        // Check if the user already exists
        UsersDAO.getUserByCredentials(app.id, 'shibboleth', externalId, function(err, user) {
            if (err && err.code !== 404) {
                return callback(err);
            } else if (user) {
                log().debug({'user': user.id, 'externalId': externalId}, 'User logged in via Shibboleth');
                return callback(null, user);
            }

            // The user was not found, create a record
            log().debug({
                'externalId': externalId,
                'displayName': displayName,
                'email': email
            }, 'New user logged in via shibboleth, creating new account');
            var userProfile = {
                'displayName': displayName,
                'email': email,
                'emailPreference': 'immediate',
                'isAdmin': false
            };
            var credentials = {
                'strategy': 'shibboleth',
                'shibbolethId': externalId
            };
            return UsersDAO.createUser(app.id, userProfile, credentials, callback);
        });
    }));
};

/**
 * Get the value from the attribute that best matches a configured priority list
 *
 * @param  {String}     priorityList        A prioritised space seperated list
 * @param  {Object}     headers             The headers that were passed along by mod_shib
 * @param  {String}     [defaultValue]      A default value that can be fallen back to
 * @return {String}                         The value of the attribute that best matched the configured priority list
 * @api private
 */
var _getBestAttributeValue = function(priorityList, headers, defaultValue) {
    priorityList = _.chain(priorityList.split(' '))
        .compact()
        .uniq()
        .value();

    var attribute = _.find(priorityList, function(attribute) {
        return (headers[attribute] && headers[attribute] !== defaultValue);
    });

    var value = headers[attribute] || defaultValue;
    return value;
};

/**
 * Express middleware that will add the Grasshopper `Context` to each request at `req.ctx`.
 * This context object will contain the current app, the currently authenticated user and
 * the user impostering the authenticated user
 *
 * @param  {Request}    req     The Express.js request
 * @param  {Response}   res     The express.js response
 * @param  {Function}   next    Standard callback function
 * @api private
 */
var contextMiddleware = function(req, res, next) {
    var user = null;
    if (req.authInfo && req.authInfo.user) {
        user = req.authInfo.user;
    }

    // TODO: Add imposter
    req.ctx = new Context(req.ghApp, user);
    return next();
};

/**
 * Register the Passport serialize user function. This determines
 * what is stored in the session cookie
 *
 * @param  {String}         cookieSecret        The cookie secret to encrypt the session cookie with
 * @api private
 */
var registerSerializeUser = function(cookieSecret) {
    passport.serializeUser(function(authInfo, callback) {
        // Serialize the user id and whether the user is logged in
        // on the global admin server to the session cookie
        var sessionCookie = {
            'userId': authInfo.user.id,
            'isGlobalAdmin': authInfo.app.isGlobalAdmin
        };

        var encryptedCookie = _encryptCookieData(JSON.stringify(sessionCookie), cookieSecret);
        return callback(null, encryptedCookie);
    });
};

/**
 * Register the Passport deserialize user function. This retrieves
 * the currently logged in user based on the session cookie data.
 *
 * @param  {String}         cookieSecret        The cookie secret used to encrypt the session cookie
 * @api private
 */
var registerDeserializeUser = function(cookieSecret) {
    passport.deserializeUser(function(encryptedCookie, callback) {
        var sessionData = _decryptCookieData(encryptedCookie, cookieSecret);

        try {
            // Parse the cookie data
            sessionData = JSON.parse(sessionData);
        } catch (err) {
            // If parsing failed, the user cookie has malformed session data or has been tampered with.
            // Continue with an empty session
            log().error({'err': err, 'sessionData': sessionData}, 'Failed to deserialize the user cookie');
            sessionData = {};
        }

        // If there is no user in the session, fall back to an anonymous session
        if (!sessionData.userId) {
            return callback(null, false);
        }

        // The user is logged in as a global administrator
        if (sessionData.isGlobalAdmin) {
            AdminsDAO.getGlobalAdmin(sessionData.userId, function(err, globalAdmin) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the global administrator from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': globalAdmin, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });

        // The user is logged in on a regular app
        } else {
            UsersDAO.getUser(sessionData.userId, function(err, user) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the logged in user from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': user, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });
        }
    });
};

/**
 * Encrypt cookie data to send to the client
 *
 * @param  {String}     cookieData      The cookie data to encrypt
 * @param  {String}     cookieSecret    The secret to encrypt the cookie data with
 * @return {String}                     The encrypted cookie data
 * @api private
 */
var _encryptCookieData = function(cookieData, cookieSecret) {
    var cipher = crypto.createCipher('aes-256-cbc', cookieSecret);
    return cipher.update(cookieData, 'utf8', 'base64') + cipher.final('base64');
};

/**
 * Decrypt cookie data provided by the client
 *
 * @param  {String}     encryptedData   The encrypted cookie data to decrypt
 * @param  {String}     cookieSecret    The secret to decrypt the data with
 * @return {String}                     The decrypted cookie data
 * @api private
 */
var _decryptCookieData = function(encryptedData, cookieSecret) {
    var decipher = crypto.createDecipher('aes-256-cbc', cookieSecret);
    return decipher.update(encryptedData, 'base64', 'utf8') + decipher.final('utf8');
};
