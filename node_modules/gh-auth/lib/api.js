/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var crypto = require('crypto');
var passport = require('passport');

var AdminsDAO = require('gh-admins/lib/internal/dao');
var AuthConstants = require('gh-auth/lib/constants');
var ConfigAPI = require('gh-config');
var Context = require('gh-context').Context;
var GrassHopper = require('gh-core');
var GrassHopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-apps');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var AuthUtil = require('./util');
var OauthDAO = require('./oauth/dao');
var ShibbolethAPI = require('./api.shibboleth');

// Authentication Strategy prototypes
var BasicStrategy = require('passport-http').BasicStrategy;
var BearerStrategy = require('passport-http-bearer').Strategy;
var ClientPasswordStrategy = require('passport-oauth2-client-password').Strategy;
var LocalStrategy = require('passport-local').Strategy;
var ShibbolethStrategy = require('./shibboleth/strategy');

/**
 * Initialise the authentication module
 *
 * @param  {Object}     config          The application configuration
 */
var init = module.exports.init = function(config) {
    // Apply bearer token authentication
    GrassHopper.appServer.use(function(req, res, next) {
        if (!_hasAccessToken(req)) {
            return next();
        }

        passport.authenticate('bearer', {'session': false})(req, res, function() {
            if (_.has(req, 'ghAuthInfo.user')) {
                // Authentication was successful, we can safely disable CSRF for this request as we know
                // it came from a valid external site
                req._checkCSRF = false;
            }

            return next();
        });
    });

    // Register the Passport authentication strategies
    _registerLocalAuthentication();
    _registerShibbolethAuthentication();
    _registerBearerAuthentication();
    _registerBasicClientPasswordAuthentication();
    _registerClientPasswordAuthentication();

    // Register the Passport serializers
    _registerSerializeUser(config.cookie.secret);
    _registerDeserializeUser(config.cookie.secret);

    // Add the context middleware to the global admin and app Express servers
    // This needs to happen *AFTER* all authentication strategies have been initialized
    GrassHopper.appServer.use(_contextMiddleware);
    GrassHopper.globalAdminServer.use(_contextMiddleware);

    // Initialise the Shibboleth API
    ShibbolethAPI.refreshConfiguration(config);
};

/**
 * Register the Passport local authentication strategy
 *
 * @api private
 */
var _registerLocalAuthentication = function() {
    passport.use(new LocalStrategy({'passReqToCallback': true}, function(req, username, password, done) {
        // The user is logging in as a global administrator
        if (req.ghApp.isGlobalAdmin) {
            _validateGlobalAdminCredentials(req.ghApp, username, password, done);

        // The user is logging in on a regular app
        } else {
            // On a regular application, users log in with their email address. There's no
            // need to check whether `username` and `password` are defined as Passport.js has
            // already done those checks
            var validator = new Validator();
            validator.check(username, 'A valid username must be provided').isEmail();
            if (validator.hasErrors()) {
                return done(null, null, validator.getFirstError());
            }

            _validateLocalUserCredentials(req.ghApp, username, password, done);
        }
    }));
};

/**
 * Validate the login credentials for a global administrator
 *
 * @param  {App}                    app                             The global admin application
 * @param  {String}                 username                        The username of the global administrator to attempt login validation for
 * @param  {String}                 password                        The password to attempt login validation with
 * @param  {Function}               done                            PassportJS callback function
 * @param  {Object}                 done.err                        An error object, if any
 * @param  {Boolean|Object}         done.ghAuthInfo                 The global administrator and global admin app for the provided username and password. If the provided password was incorrect, this will be `false`
 * @param  {GlobalAdmin}            done.ghAuthInfo.globalAdmin     The global administrator object
 * @param  {App}                    done.ghAuthInfo.app             The global admin application
 */
var _validateGlobalAdminCredentials = function(app, username, password, done) {
    // Ensure that a global administrator with the provided username exist
    AdminsDAO.getGlobalAdminByUsername(username, function(err, globalAdmin) {
        // No global administrator could be found for the provided username
        if (err && err.code === 404) {
            log().info({'err': err, 'username': username}, 'The provided global administrator username is incorrect');
            return done(null, false);
        // A different error occured
        } else if (err) {
            log().error({'err': err, 'username': username}, 'Failed to validate the login credentials for a global administrator');
            return done(err);
        }

        var match = AuthUtil.comparePassword(password, globalAdmin.password);
        if (!match) {
            log().info({'err': err, 'username': username}, 'The provided global administrator password is incorrect');
            return done(null, false);
        }

        log().info({'globalAdmin': globalAdmin}, 'Logged in as a global administrator');
        var ghAuthInfo = {'user': globalAdmin, 'app': app};
        return done(null, ghAuthInfo);
    });
};

/**
 * Validate the login credentials for a local user
 *
 * @param  {App}                    app                     The application to which the user belongs
 * @param  {String}                 email                   The email of the user to attempt login validation for. The email acts as the username
 * @param  {String}                 password                The password to attempt login validation with
 * @param  {Function}               done                    PassportJS callback function
 * @param  {Object}                 done.err                An error object, if any
 * @param  {Boolean|Object}         done.ghAuthInfo         The user and app objects for the provided username and password. If the provided password was incorrect, this will be `false`
 * @param  {GlobalAdmin}            done.ghAuthInfo.user    The user object
 * @param  {App}                    done.ghAuthInfo.app     The application to which the user belongs
 */
var _validateLocalUserCredentials = function(app, email, password, done) {
    // Ensure that a user with the provided credentials exist
    UsersDAO.getUserByCredentials(app.id, AuthConstants.strategies.LOCAL, email, function(err, user) {
        // No user could be found for the provided credentials
        if (err && err.code === 404) {
            log().warn({'err': err, 'email': email}, 'The provided user email is incorrect');
            return done(null, false);
        // A different error occured
        } else if (err) {
            log().error({'err': err, 'email': email}, 'Failed to validate the login credentials for a user');
            return done(err);
        }

        var match = AuthUtil.comparePassword(password, user.password);
        if (!match) {
            log().warn({'err': err, 'email': email}, 'The provided user password is incorrect');
            return done(null, false);
        }

        log().debug({'user': user}, 'Logged in as a user with a local authentication strategy');
        var ghAuthInfo = {'user': user, 'app': app};
        return done(null, ghAuthInfo);
    });
};

/**
 * Register the OAuth 2.0 Bearer authentication strategy
 *
 * @api private
 */
var _registerBearerAuthentication = function() {
    passport.use(new BearerStrategy({'passReqToCallback': true}, function(req, token, done) {
        var validator = new Validator();
        validator.check(token, {'code': 400, 'msg': 'A valid token must be specified'}).notEmpty();
        if (validator.hasErrors()) {
            return done(validator.getFirstError());
        }

        OauthDAO.getAccessTokenByToken(token, function(err, accessToken) {
            if (err) {
                return done(err);
            } else if (req.ghApp.id !== accessToken.User.AppId) {
                return done({'code': 401, 'msg': 'The provided token is not available on this app'});
            } else if (accessToken.OauthClient.disabled) {
                return done({'code': 401, 'msg': 'The client associated to this token has been disabled'});
            }

            log().debug({'user': accessToken.User}, 'Logged in as a user with a bearer authentication strategy');
            var ghAuthInfo = {'user': accessToken.User, 'app': req.ghApp};
            return done(null, ghAuthInfo);
        });
    }));
};

/**
 * Register the OAuth 2.0 Client Password authentication strategy. This strategy is geared
 * specifically so that OAuth Clients can authenticate requests to perform requests on behalf of
 * *themselves* but not any request in particular.
 *
 * As of now, the only request that they can do is exchange for an OAuth access token with an
 * authorization code that has been authorized to it by a user. Theoretically, one could allow a
 * client to update some metadata about itself, for example.
 *
 * @api private
 */
var _registerBasicClientPasswordAuthentication = function() {
    passport.use(new BasicStrategy({'passReqToCallback': true}, _handleOauthClientAuthentication));
};

/**
 * This is a permutation of `_registerBasicClientPasswordAuthentication` that allows a client to
 * provide its credentials in the request body instead of basic authentication.
 *
 * For clients performing POST requests, this form of authentication is acceptable since there is
 * CSRF protection in place to ensure that the request wasn't forged. However, for GET requests, the
 * request should use `_BasicClientPasswordAuthentication` so that credentials are transmitted in
 * HTTP headers rather than the query string. This is a security measure as query strings should be
 * safe to log in an access log, and client secrets are not safe for this.
 *
 * @api private
 */
var _registerClientPasswordAuthentication = function() {
    passport.use(new ClientPasswordStrategy({'passReqToCallback': true}, _handleOauthClientAuthentication));
};

/**
 * Convenience function for handling oauth client authentication, in which the client provides its
 * id as the username and its secret as a password.
 *
 * @param  {Request}            req                 The request that initiated the authentication
 * @param  {Number}             clientId            The id of the client trying to authenticate
 * @param  {String}             clientSecret        The provided secret with which to authenticate
 * @param  {Function}           done                Passport authentication `done` callback
 * @param  {Object}             done.err            An error that occurred, if any
 * @param  {Object|Boolean}     done.ghAuthInfo     If an object, should be the auth info object to apply to the request. Otherwise, should be `false` to indicate a failed authentcation
 * @oaram  {Object}             done.errInfo        Additional error information, used by passport to assemble its errors
 * @api private
 */
var _handleOauthClientAuthentication = function(req, clientId, clientSecret, done) {
    clientId = GrassHopperUtil.getNumberParam(clientId);

    var validator = new Validator();
    validator.check(clientId, {'code': 400, 'msg': 'A valid client id must be specified'}).isInt();
    validator.check(clientSecret, {'code': 400, 'msg': 'A valid client secret must be specified'}).notEmpty();
    if (validator.hasErrors()) {
        return done(null, false, {'message': validator.getFirstError().msg});
    }

    OauthDAO.getClient(clientId, function(err, client) {
        if (err && err.code === 500) {
            // This is a systemic error, not an authentication failure
            return done(err);
        } else if (err) {
            // For other kinds of errors (e.g., 404), we treat it as an authentication failure
            return done(null, false, {'message': err.msg});
        } else if (client.secret !== clientSecret) {
            return done(null, false, {'message': 'Client secret mismatch'});
        } else if (req.ghApp.id !== client.AppId) {
            return done(null, false, {'message': 'The provided client is not available on this app'});
        } else if (client.disabled) {
            return done(null, false, {'message': 'This client has been disabled'});
        }

        log().debug({'clientId': client.id}, 'Authenticated a request with client credentials');

        // Do not grant a regular session, but indicate that there was a successful oauth client
        // authentication
        var ghAuthInfo = {'oauthClient': client, 'app': req.ghApp};
        return done(null, ghAuthInfo);
    });
};

/**
 * Register the Passport Shibboleth authentication strategy
 *
 * @api private
 */
var _registerShibbolethAuthentication = function() {
    passport.use(new ShibbolethStrategy(function(req, app, headers, callback) {

        log().debug({
            'app': app.id,
            'headers': headers
        }, 'Received Shibboleth authentication callback');

        var config = ConfigAPI.config(app.id);
        var shibExternalIdAttributes = config.shibExternalIdAttributes;
        var shibMapDisplayname = config.shibMapDisplayname;
        var shibMapEmail = config.shibMapEmail;

        // The external ID is configurable in the admin UI as a priority list (similar to
        // how `mod_shib` works). We try to find an attribute in the released set that matches
        // any of the configurable attributes. Rather than relying on `mod_shib`'s `remote_user`
        // attribute, we rely on the configured list as it allows administrators to specify
        // attributes on a per-tenant basis. We use `remote_user` as the fall back value
        var externalId = _getBestAttributeValue(shibExternalIdAttributes, headers, headers['remote_user']);
        if (!externalId) {
            log().error({'headers': headers, 'app': app.id}, 'No suitable attribute was found for the `externalId` attribute');
            return callback({'code': 500, 'msg': 'No suitable attribute was found for the `externalId` attribute'});
        }

        // There are a lot of SAML attributes that may indicate a user's display name. The administrator
        // should provide a suitable priority list to construct the displayName. If no suitable value was
        // returned from the mapping, we fall back to the `remote_user` attribute, as this is always provided
        var displayName = _getBestAttributeValue(shibMapDisplayname, headers, headers['remote_user']);

        // Set the optional profile parameters
        var opts = {};

        // Get an email address from the provided headers. We fall back to `eppn` which may not always
        // contain a valid email address. We only set the `email` value if a valid email has been provided
        var email = _getBestAttributeValue(shibMapEmail, headers, headers['eppn']);
        if (email) {
            var validator = new Validator();
            validator.check(email, {'code': 400, 'msg': 'Invalid email'}).isEmail();
            if (!validator.hasErrors()) {
                opts['email'] = email;
            } else {
                log().warn({'email': email, 'externalId': externalId, 'app': app.id}, 'A user signed in via Shib with an invalid email address');
            }
        }

        // Check if the user already exists
        UsersDAO.getUserByCredentials(app.id, AuthConstants.strategies.SHIBBOLETH, externalId, function(err, user) {
            if (err && err.code !== 404) {
                return callback(err);
            } else if (user) {
                log().debug({'user': user.id, 'externalId': externalId}, 'User logged in via Shibboleth');
                return callback(null, user);
            }

            // The user was not found, create a record
            log().debug({
                'externalId': externalId,
                'displayName': displayName,
                'email': email
            }, 'New user logged in via shibboleth, creating new account');
            var userProfile = {
                'displayName': displayName,
                'email': email,
                'emailPreference': 'immediate',
                'isAdmin': false
            };
            var credentials = {
                'strategy': AuthConstants.strategies.SHIBBOLETH,
                'shibbolethId': externalId
            };
            return UsersDAO.createUser(app.id, userProfile, credentials, callback);
        });
    }));
};

/**
 * Get the value from the attribute that best matches a configured priority list
 *
 * @param  {String}     priorityList        A prioritised space seperated list
 * @param  {Object}     headers             The headers that were passed along by mod_shib
 * @param  {String}     [defaultValue]      A default value that can be fallen back to
 * @return {String}                         The value of the attribute that best matched the configured priority list
 * @api private
 */
var _getBestAttributeValue = function(priorityList, headers, defaultValue) {
    priorityList = _.chain(priorityList.split(' '))
        .compact()
        .uniq()
        .value();

    var attribute = _.find(priorityList, function(attribute) {
        return (headers[attribute] && headers[attribute] !== defaultValue);
    });

    var value = headers[attribute] || defaultValue;
    return value;
};

/**
 * Express middleware that will add the Grasshopper `Context` to each request at `req.ctx`.
 * This context object will contain the current app, the currently authenticated user and
 * the user impostering the authenticated user
 *
 * @param  {Request}    req     The Express.js request
 * @param  {Response}   res     The express.js response
 * @param  {Function}   next    Standard callback function
 * @api private
 */
var _contextMiddleware = function(req, res, next) {
    var user = null;
    if (req.ghAuthInfo && req.ghAuthInfo.user) {
        user = req.ghAuthInfo.user;
    }

    // TODO: Add imposter
    req.ctx = new Context(req.ghApp, user);
    return next();
};

/**
 * Register the Passport serialize user function. This determines
 * what is stored in the session cookie
 *
 * @param  {String}         cookieSecret        The cookie secret to encrypt the session cookie with
 * @api private
 */
var _registerSerializeUser = function(cookieSecret) {
    passport.serializeUser(function(ghAuthInfo, callback) {
        // Serialize the user id and whether the user is logged in
        // on the global admin server to the session cookie
        var sessionCookie = {
            'userId': ghAuthInfo.user.id,
            'isGlobalAdmin': ghAuthInfo.app.isGlobalAdmin
        };

        var encryptedCookie = _encryptCookieData(JSON.stringify(sessionCookie), cookieSecret);
        return callback(null, encryptedCookie);
    });
};

/**
 * Register the Passport deserialize user function. This retrieves
 * the currently logged in user based on the session cookie data.
 *
 * @param  {String}         cookieSecret        The cookie secret used to encrypt the session cookie
 * @api private
 */
var _registerDeserializeUser = function(cookieSecret) {
    passport.deserializeUser(function(encryptedCookie, callback) {
        var sessionData = _decryptCookieData(encryptedCookie, cookieSecret);

        try {
            // Parse the cookie data
            sessionData = JSON.parse(sessionData);
        } catch (err) {
            // If parsing failed, the user cookie has malformed session data or has been tampered with.
            // Continue with an empty session
            log().error({'err': err, 'sessionData': sessionData}, 'Failed to deserialize the user cookie');
            sessionData = {};
        }

        // If there is no user in the session, fall back to an anonymous session
        if (!sessionData.userId) {
            return callback(null, false);
        }

        // The user is logged in as a global administrator
        if (sessionData.isGlobalAdmin) {
            AdminsDAO.getGlobalAdmin(sessionData.userId, function(err, globalAdmin) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the global administrator from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': globalAdmin, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });

        // The user is logged in on a regular app
        } else {
            UsersDAO.getUser(sessionData.userId, function(err, user) {
                if (err) {
                    log().error({'err': err, 'sessionData': sessionData}, 'Failed to retrieve the logged in user from the session cookie');
                    return callback(err);
                }

                return callback(null, {'user': user, 'isGlobalAdmin': sessionData.isGlobalAdmin});
            });
        }
    });
};

/**
 * Encrypt cookie data to send to the client
 *
 * @param  {String}     cookieData      The cookie data to encrypt
 * @param  {String}     cookieSecret    The secret to encrypt the cookie data with
 * @return {String}                     The encrypted cookie data
 * @api private
 */
var _encryptCookieData = function(cookieData, cookieSecret) {
    var cipher = crypto.createCipher('aes-256-cbc', cookieSecret);
    return cipher.update(cookieData, 'utf8', 'base64') + cipher.final('base64');
};

/**
 * Decrypt cookie data provided by the client
 *
 * @param  {String}     encryptedData   The encrypted cookie data to decrypt
 * @param  {String}     cookieSecret    The secret to decrypt the data with
 * @return {String}                     The decrypted cookie data
 * @api private
 */
var _decryptCookieData = function(encryptedData, cookieSecret) {
    var decipher = crypto.createDecipher('aes-256-cbc', cookieSecret);
    return decipher.update(encryptedData, 'base64', 'utf8') + decipher.final('utf8');
};

/**
 * Find an OAuth access token in the HTTP request
 *
 * @param  {Request}    req     The HTTP request in which to look for the OAuth access token
 * @return {Boolean}            Whether or not the request contains an OAuth access token
 * @api private
 */
var _hasAccessToken = function(req) {
    return ((req.body && req.body.access_token) ||
        (req.headers && req.headers.authorization && req.headers.authorization.indexOf('Bearer ') === 0)
    );
};
