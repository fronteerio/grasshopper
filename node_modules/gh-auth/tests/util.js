/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var assert = require('assert');
var moment = require('moment');
var querystring = require('querystring');
var url = require('url');
var util = require('util');

var AppsTestsUtil = require('gh-apps/tests/util');
var TestsUtil = require('gh-tests/lib/util');
var UsersTestsUtil = require('gh-users/tests/util');

/**
 * Assert a user can log in
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         username                The username for the user
 * @param  {String}         password                The password for the user
 * @param  {Function}       callback                Standard callback function
 */
var assertLogin = module.exports.assertLogin = function(client, username, password, callback) {
    client.auth.login(username, password, function(err, body, response) {
        assert.ok(!err);

        // Verify we're logged in
        client.user.getMe(function(err, body, response) {
            assert.ok(!err);
            assert.strictEqual(body.anon, false);
            return callback();
        });
    });
};

/**
 * Assert a user can not log in
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         username                The username for the user
 * @param  {String}         password                The password for the user
 * @param  {Function}       callback                Standard callback function
 */
var assertLoginFails = module.exports.assertLoginFails = function(client, username, password, callback) {
    // Get the me feed before trying to log in so we know what our session was like before
    UsersTestsUtil.assertGetMe(client, function(meBefore) {

        // Attempt to log in, ensuring it fails
        client.auth.login(username, password, function(err, body, response) {
            assert.ok(err);
            assert.strictEqual(err.code, 401);

            // Get the me feed again, ensuring our session hasn't changed
            return UsersTestsUtil.assertGetMeEquals(client, meBefore, callback);
        });
    });
};

/**
 * Assert a user can log out
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Function}       callback                Standard callback function
 */
var assertLogout = module.exports.assertLogout = function(client, callback) {
    client.auth.logout(function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to the main page
        assert.ok(_.has(response.headers, 'location'));
        assert.strictEqual(response.headers.location, '/');

        // Verify we're logged out
        client.user.getMe(function(err, body, response) {
            assert.ok(!err);
            assert.strictEqual(body.anon, true);
            return callback();
        });
    });
};

/**
 * Assert that a user can be redirected from the application to the SP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         redirectUrl             The URL where the user should be redirect to once he succesfully authenticates
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.params         The parameters that can be used to initialise the shib flow on the Shibboleth application
 */
var assertShibbolethApplicationRedirect = module.exports.assertShibbolethApplicationRedirect = function(client, redirectUrl, callback) {
    client.auth.shibbolethApplicationRedirect(redirectUrl, function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to our Shibboleth application
        var shibHost = TestsUtil.getConfig().servers.shibbolethSPHost;
        assert.ok(_.has(response.headers, 'location'));
        assert.strictEqual(response.headers.location.indexOf(util.format('https://%s', shibHost)), 0);

        // Get the parameters that need to be sent to the Shibboleth application
        var params = url.parse(response.headers.location, true).query;
        assert.ok(_.has(params, 'app'));
        assert.ok(_.has(params, 'signature'));
        assert.ok(_.has(params, 'expires'));
        return callback(params);
    });
};

/**
 * Assert that a user can not be redirected from the application to the SP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {String}         redirectUrl             The URL where the user should be redirect to once he succesfully authenticates
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethApplicationRedirectFails = module.exports.assertShibbolethApplicationRedirectFails = function(client, redirectUrl, code, callback) {
    client.auth.shibbolethApplicationRedirect(redirectUrl, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert that a user can be redirected from the SP to the IdP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {Number}         params.app              The id of the application on which the user wants to authenticate sign on
 * @param  {String}         params.signature        The signature for the application id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Function}       callback                Standard callback function
 * @param  {Response}       callback.response       The response object as returned by requestjs
 */
var assertShibbolethSPRedirect = module.exports.assertShibbolethSPRedirect = function(client, params, callback) {
    client.auth.shibbolethSPRedirect(params, function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to mod_shib's /Shibboleth.sso/Login
        assert.ok(_.has(response.headers, 'location'));

        var parsedUrl = url.parse(response.headers.location, true);
        assert.strictEqual(parsedUrl.pathname, '/Shibboleth.sso/Login');
        assert.strictEqual(parsedUrl.query.target, '/api/auth/shibboleth/sp/callback');
        assert.ok(_.has(parsedUrl.query, 'entityID'));
        return callback(response);
    });
};

/**
 * Assert that a user can not be redirected from the SP to the IdP
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {String}         params.app              The id of the application on which the user wants to authenticate
 * @param  {String}         params.signature        The signature for the application id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethSPRedirectFails = module.exports.assertShibbolethSPRedirectFails = function(client, params, code, callback) {
    client.auth.shibbolethSPRedirect(params, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert the user can be sent back to the Shibboleth application from mod_shib
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         attributes              The attributes that should be sent to the app server
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.params         The parameters that can be used to finalise the authentication process on the application
 */
var assertShibbolethSPCallback = module.exports.assertShibbolethSPCallback = function(client, attributes, callback) {
    client.auth.shibbolethSPCallback(attributes, function(err, body, response) {
        assert.ok(!err);

        // Verify we're being redirected to the user's application
        assert.ok(_.has(response.headers, 'location'));

        // Get the parameters that need to be sent to the user's application
        var params = url.parse(response.headers.location, true).query;
        assert.ok(_.has(params, 'user'));
        assert.ok(_.has(params, 'signature'));
        assert.ok(_.has(params, 'expires'));
        return callback(params);
    });
};

/**
 * Assert the user can not be sent back to the Shibboleth application from mod_shib
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         attributes              The attributes that should be sent to the app server
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethSPCallbackFails = module.exports.assertShibbolethSPCallbackFails = function(client, attributes, code, callback) {
    client.auth.shibbolethSPCallback(attributes, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert that the user can be sent back to an application
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {String}         params.userId           The id of the user that will be signing in
 * @param  {String}         params.signature        A signature for the user id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Function}       callback                Standard callback function
 * @param  {Response}       callback.response       The response object as returned by requestjs
 */
var assertShibbolethApplicationCallback = module.exports.assertShibbolethApplicationCallback = function(client, params, callback) {
    client.auth.shibbolethApplicationCallback(params, function(err, body, response) {
        assert.ok(!err);

        // If we made it here sucesfully, we should have been logged in
        UsersTestsUtil.assertGetMe(client, function(me) {
            assert.ok(!me.anon);
            assert.ok(me.id);
            return callback(response);
        });
    });
};

/**
 * Assert that the user can not be sent back to an application
 *
 * @param  {RestClient}     client                  The REST client to make the request with
 * @param  {Object}         params                  The query string parameters for this endpoint
 * @param  {String}         params.userId           The id of the user that will be signing in
 * @param  {String}         params.signature        A signature for the user id
 * @param  {Number}         params.expires          The time in ms since epoch when the signature expires
 * @param  {Number}         code                    The expected HTTP error code
 * @param  {Function}       callback                Standard callback function
 */
var assertShibbolethApplicationCallbackFails = module.exports.assertShibbolethApplicationCallbackFails = function(client, params, code, callback) {
    client.auth.shibbolethApplicationCallback(params, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, code);
        return callback();
    });
};

/**
 * Assert that a user can be authenticated on an application through Shibboleth
 *
 * @param  {App}            app                         The application on which the user should be authentication
 * @param  {String}         [remoteUser]                The value that should be used as the `remote_user` attribute. A random value will be generated if left undefined
 * @param  {Object}         [attributes]                The attributes that mod_shib sends back to the application. Defaults to the empty object
 * @param  {String}         [redirectUrl]               The URL where the user should be redirected to. Defaults to `/`
 * @param  {Function}       callback                    Standard callback function
 * @param  {RestClient}     callback.restClient         The authenticated rest client on the application
 * @param  {String}         callback.remoteUser         The user identifier that was used as the `remote_user` value
 */
var assertShibbolethLogin = module.exports.assertShibbolethLogin = function(app, remoteUser, attributes, redirectUrl, callback) {
    remoteUser = remoteUser || TestsUtil.generateTestUserId();
    redirectUrl = redirectUrl || '/';

    TestsUtil.getAnonymousAppUserClient(app, function(anonymousClient) {

        // 1. Indicate that we want to login in with Shibboleth. The backend will
        // redirect us to the Shibboleth application
        assertShibbolethApplicationRedirect(anonymousClient, redirectUrl, function(params) {

            // 2. Let the Shibboleth application redirect us to mod_shib
            TestsUtil.getShibbolethRestClient(function(shibAppClient) {
                assertShibbolethSPRedirect(shibAppClient, params, function() {

                    // 3. We return from mod_shib
                    var modShibAttributes = _.extend({}, attributes, {
                        // Fake a Shib session
                        'shib-session-id': _.random(100000),

                        // Fake a user
                        'remote_user': remoteUser
                    });
                    assertShibbolethSPCallback(shibAppClient, modShibAttributes, function(params) {

                        // 4. We get sent back to our application and should be logged in
                        assertShibbolethApplicationCallback(anonymousClient, params, function(response) {

                            // Verify the user was sent to the correct redirect url
                            assert.strictEqual(response.headers.location, redirectUrl);

                            // Pass the (now authenticated) rest client back to the caller
                            return callback(anonymousClient, remoteUser);
                        });
                    });
                });
            });
        });
    });
};

/**
 * Assertion function for the OauthClient model
 */
var assertOauthClient = module.exports.assertOauthClient = TestsUtil.createAssertionFunction({

    /*!
     * Perform an OauthClient-specific sanity check based on the given "view" expected from the
     * model. Possible views are:
     *
     *  * 'admin' - The OauthClient was acquired by a user who administers the app of the client
     *  * 'user'  - The OauthClient was acquired by a regular user of the app of the client
     *
     * No other views are possible as the OauthClient model is only accessible by authenticated
     * users.
     *
     * @param  {String}     view    The view of the OauthClient
     */
    'sanity': function(actualOauthClient, view) {
        // Standard assertions for any "view" of an oauth client
        var assertions = {
            'validate': {
                'id': _.isNumber,
                'displayName': _.isString,
                'redirectUri': _.isString,
                'disabled': function(actualDisabled) {
                    if (_.isString(actualDisabled)) {
                        // It must have been disabled sometime after it was created, or before or equal
                        // to the last update time
                        TestsUtil.assertTimestamp(actualDisabled, {
                            'afterOrEqual': actualOauthClient.createdAt,
                            'beforeOrEqual': actualOauthClient.updatedAt
                        });
                    } else if (_.isNull(actualDisabled)) {
                        return true;
                    } else {
                        assert.fail(util.format('Expected "disabled" property to be either string or null. Was: %s', actualDisabled));
                    }
                },
                'createdAt': function(actualCreatedAt) {
                    // It must have been created within the last hour, assuming the tests were shorter
                    // than that
                    TestsUtil.assertTimestamp(actualCreatedAt, {
                        'after': moment().subtract(1, 'hours'),
                        'beforeOrEqual': moment()
                    });
                },
                'updatedAt': function(actualUpdatedAt) {
                    // It must have been updated somewhere between the created date and now
                    TestsUtil.assertTimestamp(actualUpdatedAt, {
                        'afterOrEqual': actualOauthClient.createdAt,
                        'beforeOrEqual': moment()
                    });
                },
                'AppId': _.isNumber
            }
        };

        // If we are asserting a particular view, we should ensure the state of the secret. Otherwise
        // it is indeterministic and should not be asserted
        if (view === 'admin') {
            // If it's the admin view, we should expect a secret
            assertions.validate.secret = _.isString;
        } else if (view === 'user') {
            // If it's the user view, we should expect that there is no secret key in the result
            assertions.missing = ['secret'];
        } else {
            assert.fail('Expected a view of either "admin" or "user" to sanity check oauth client');
        }

        assertOauthClient(actualOauthClient, assertions);
    }
});

/**
 * Get all oauth clients from the app
 *
 * @param  {RestClient}         client                  The REST client with which to make the requests
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {Number}             [opts.AppId]            The id of the app whose clients to get. Defaults to the app to which the REST client is configured
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient[]}      callback.oauthClients   The array of clients in the app
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertGetAllOauthClients = module.exports.assertGetAllOauthClients = function(client, opts, callback) {
    opts = opts || {};

    // Get the first page to get a count
    assertGetOauthClients(client, _.extend({}, opts, {'limit': 1}), function(firstResponse) {
        assert.ok(_.isNumber(firstResponse.count));
        assert.ok(firstResponse.rows.length <= 1);

        // One request to get them all
        assertGetOauthClients(client, _.extend({}, opts, {'limit': firstResponse.count}), function(secondResponse) {
            assert.strictEqual(secondResponse.count, firstResponse.count);
            assert.strictEqual(secondResponse.count, secondResponse.rows.length);
            return callback(secondResponse.rows);
        });
    });
};

/**
 * Get a page of oauth clients from the app
 *
 * @param  {RestClient}         client                  The REST client with which to make the requests
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {Number}             [opts.limit]            The maximum number of oauth clients to get
 * @param  {Number}             [opts.offset]           The offset index at which to start listing clients
 * @param  {Number}             [opts.AppId]            The id of the app whose clients to get. Defaults to the app to which the REST client is configured
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClientList}    callback.response       The oauth client list response
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertGetOauthClients = module.exports.assertGetOauthClients = function(client, opts, callback) {
    opts = opts || {};

    // Get the expected app
    UsersTestsUtil.assertGetMe(client, function(me) {
        var expectedAppId = opts.appId || me.app.id;

        client.auth.getOauthClients(opts, function(err, response) {
            assert.ok(!err);
            assert.ok(_.isNumber(response.count));
            assert.ok(_.isArray(response.rows));
            assert.ok(response.count >= response.rows.length);

            if (_.isNumber(opts.limit)) {
                assert.ok(response.rows.length <= limit);
            }

            _.each(response.rows, function(oauthClient) {
                assertOauthClient(oauthClient, {
                    'sanity': _resolveExpectedView(me),
                    'match': {
                        'AppId': expectedAppId
                    }
                });
            });

            return callback(response);
        });
    });
};

/**
 * Get a page of oauth clients from the app, ensuring the request fails in the expected manner
 *
 * @param  {RestClient}         client          The REST client with which to make the request
 * @param  {Object}             [opts]          Optional arguments
 * @param  {Number}             [opts.limit]    The maximum number of oauth clients to get
 * @param  {Number}             [opts.offset]   The offset index at which to start listing clients
 * @param  {Number}             [opts.AppId]    The id of the app whose clients to get. Defaults to the app to which the REST client is configured
 * @param  {Number}             httpCode        The expected failure code
 * @param  {Function}           callback        Invoked when complete
 * @throws {AssertionError}                     Thrown if any assertions fail
 */
var assertGetOauthClientsFails = module.exports.assertGetOauthClientsFails = function(client, opts, httpCode, callback) {
    client.auth.getOauthClients(opts, function(err, response) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!response);
        return callback();
    });
};

/**
 * Get an oauth client from an app
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             id                      The id of the oauth client to get
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient}        callback.oauthClient    The oauth client
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertGetOauthClient = module.exports.assertGetOauthClient = function(client, id, callback) {
    // Get the expected app
    UsersTestsUtil.assertGetMe(client, function(me) {
        client.auth.getOauthClient(id, function(err, oauthClient) {
            assert.ok(!err);
            assertOauthClient(oauthClient, {'sanity': _resolveExpectedView(me)});
            return callback(oauthClient);
        });
    });
};

/**
 * Get an oauth client from an app, ensuring it fails in the expected manner
 *
 * @param  {RestClient}         client              The REST client with which to make the request
 * @param  {Number}             id                  The id of the oauth client to get
 * @param  {Number}             httpCode            The expected HTTP code of the failure response
 * @param  {Function}           callback            Invoked when complete
 * @throws {AssertionError}                         Thrown if any assertions fail
 */
var assertGetOauthClientFails = module.exports.assertGetOauthClientFails = function(client, id, httpCode, callback) {
    client.auth.getOauthClient(id, function(err, oauthClient) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assertOauthClient(oauthClient, {'exists': false});
        return callback();
    });
};

/**
 * Create an oauth client
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {String}             displayName             The display name of the oauth client
 * @param  {String}             redirectUri             The redirect uri of the oauth client
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {Number}             [opts.AppId]            The id of the app on which to create the client
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient}        callback.oauthClient    The created oauth client
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertCreateOauthClient = module.exports.assertCreateOauthClient = function(client, displayName, redirectUri, opts, callback) {
    opts = opts || {};

    // Get the expected app
    UsersTestsUtil.assertGetMe(client, function(me) {
        var expectedAppId = opts.appId || me.app.id;

        // Create the client
        client.auth.createOauthClient(displayName, redirectUri, opts, function(err, oauthClientCreated) {
            assert.ok(!err);
            assertOauthClient(oauthClientCreated, {
                'sanity': 'admin',
                'match': {
                    'AppId': expectedAppId,
                    'displayName': displayName,
                    'redirectUri': redirectUri
                }
            });

            // Ensure the oauth client is available in the global list of clients for the app
            assertGetOauthClient(client, oauthClientCreated.id, function(oauthClientAfterCreate) {
                assertOauthClient(oauthClientAfterCreate, {'equals': oauthClientCreated});
                return callback(oauthClientAfterCreate);
            });
        });
    });
};

/**
 * Create an oauth client, ensuring it fails in the specified manner
 *
 * @param  {RestClient}         client          The REST client with which to make the request
 * @param  {String}             displayName     The display name of the oauth client
 * @param  {String}             redirectUri     The redirect uri of the oauth client
 * @param  {Object}             [opts]          Optional arguments
 * @param  {Number}             [opts.AppId]    The id of the app on which to create the client
 * @param  {Number}             httpCode        The expected HTTP code of the failed response
 * @param  {Function}           callback        Invoked when complete
 * @throws {AssertionError}                     Thrown if any assertions fail
 */
var assertCreateOauthClientFails = module.exports.assertCreateOauthClientFails = function(client, displayName, redirectUri, opts, httpCode, callback) {
    client.auth.createOauthClient(displayName, redirectUri, opts, function(err, oauthClientCreated) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assertOauthClient(oauthClientCreated, {'exists': false});
        return callback();
    });
};

/**
 * Update an oauth client
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             id                      The id of the client to update
 * @param  {Object}             fields                  Object containing the fields and values representing the updates to make
 * @param  {String}             [fields.displayName]    The display name of the oauth client
 * @param  {String}             [fields.redirectUri]    The redirect uri of the oauth client
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient}        callback.oauthClient    The updated oauth client
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertUpdateOauthClient = module.exports.assertUpdateOauthClient = function(client, id, fields, callback) {
    // Update the client, ensuring the response matches the updated values
    client.auth.updateOauthClient(id, fields, function(err, oauthClientUpdated) {
        assert.ok(!err);
        assertOauthClient(oauthClientUpdated, {
            'sanity': 'admin',
            'match': _.extend({}, fields, {'disabled': null})
        });

        // Get the client, ensuring it matches the new values
        assertGetOauthClient(client, id, function(oauthClientAfterUpdate) {
            assertOauthClient(oauthClientAfterUpdate, {'equals': oauthClientUpdated});
            return callback(oauthClientAfterUpdate);
        });
    });
};

/**
 * Update an oauth client, ensuring the request fails in the specified manner
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             id                      The id of the client to update
 * @param  {Object}             fields                  Object containing the fields and values representing the updates to make
 * @param  {String}             [fields.displayName]    The display name of the oauth client
 * @param  {String}             [fields.redirectUri]    The redirect uri of the oauth client
 * @param  {Number}             httpCode                The expected HTTP status code of the failed response
 * @param  {Function}           callback                Invoked when complete
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertUpdateOauthClientFails = module.exports.assertUpdateOauthClientFails = function(client, id, fields, httpCode, callback) {
    client.auth.updateOauthClient(id, fields, function(err, oauthClientUpdated) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assertOauthClient(oauthClientUpdated, {'exists': false});
        return callback();
    });
};

/**
 * Disable an oauth client
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             id                      The id of the client to disable
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient}        callback.oauthClient    The oauth client after being disabled
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertDisableOauthClient = module.exports.assertDisableOauthClient = function(client, id, callback) {
    assertGetOauthClient(client, id, function(oauthClientBeforeDisable) {
        var millisBeforeDisable = Date.now();
        client.auth.disableOauthClient(id, function(err, oauthClientDisabled) {
            assert.ok(!err);
            assertOauthClient(oauthClientDisabled, {
                'sanity': 'admin',
                // Ensure only the disabled and updatedAt fields have changed
                'equals': _.extend({}, oauthClientBeforeDisable, _.pick(oauthClientDisabled, 'disabled', 'updatedAt'))
            });

            // Ensure the client changes are persistent
            assertGetOauthClient(client, id, function(oauthClientAfterDisable) {
                assertOauthClient(oauthClientAfterDisable, {'equals': oauthClientDisabled});
                return callback(oauthClientAfterDisable);
            });
        });
    });
};

/**
 * Disable an oauth client, ensuring the request fails in the specified manner
 *
 * @param  {RestClient}         client      The REST client with which to make the request
 * @param  {Number}             id          The id of the client to disable
 * @param  {Number}             httpCode    The expected HTTP status code of the failed request
 * @param  {Function}           callback    Invoked when complete
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertDisableOauthClientFails = module.exports.assertDisableOauthClientFails = function(client, id, httpCode, callback) {
    client.auth.disableOauthClient(id, function(err, oauthClientDisabled) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assertOauthClient(oauthClientDisabled, {'exists': false});
        return callback();
    });
};

/**
 * Enable an oauth client
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             id                      The id of the client to enable
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient}        callback.oauthClient    The oauth client after being enabled
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertEnableOauthClient = module.exports.assertEnableOauthClient = function(client, id, callback) {
    assertGetOauthClient(client, id, function(oauthClientBeforeEnable) {
        client.auth.enableOauthClient(id, function(err, oauthClientEnabled) {
            assert.ok(!err);
            assertOauthClient(oauthClientEnabled, {
                'sanity': 'admin',
                // Ensure only the disabled and updatedAt fields have changed
                'equals': _.extend({}, oauthClientBeforeEnable, _.pick(oauthClientEnabled, 'disabled', 'updatedAt')),
                'match': {
                    'disabled': null
                }
            });

            // Ensure the client changes are persistent
            assertGetOauthClient(client, id, function(oauthClientAfterEnable) {
                assertOauthClient(oauthClientEnabled, {'equals': oauthClientAfterEnable});
                return callback(oauthClientAfterEnable);
            });
        });
    });
};

/**
 * Enable an oauth client, ensuring the request fails in the specified manner
 *
 * @param  {RestClient}         client      The REST client with which to make the request
 * @param  {Number}             id          The id of the client to enable
 * @param  {Number}             httpCode    The expected HTTP status code of the failed request
 * @param  {Function}           callback    Invoked when complete
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertEnableOauthClientFails = module.exports.assertEnableOauthClientFails = function(client, id, httpCode, callback) {
    client.auth.enableOauthClient(id, function(err, oauthClientEnabled) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assertOauthClient(oauthClientEnabled, {'exists': false});
        return callback();
    });
};

/**
 * Regenerate the secret of an oauth client
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             id                      The id of the client whose secret to regenerate
 * @param  {Function}           callback                Invoked when complete
 * @param  {OauthClient}        callback.oauthClient    The oauth client after its secret has been regenerated
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertRegenerateOauthClientSecret = module.exports.assertRegenerateOauthClientSecret = function(client, id, callback) {
    assertGetOauthClient(client, id, function(oauthClientBeforeRegenerate) {
        client.auth.regenerateOauthClientSecret(id, function(err, oauthClientRegenerated) {
            assert.ok(!err);
            assertOauthClient(oauthClientRegenerated, {
                'sanity': 'admin',
                // Ensure only the secret and updatedAt fields have changed
                'equals': _.extend({}, oauthClientBeforeRegenerate, _.pick(oauthClientRegenerated, 'secret', 'updatedAt')),
                'validate': {
                    'secret': function(actualSecret) {
                        // Ensure the secret changed
                        return (actualSecret !== oauthClientBeforeRegenerate.secret);
                    }
                }
            });

            // Ensure the client changes are persistent
            assertGetOauthClient(client, id, function(oauthClientAfterRegenerate) {
                assertOauthClient(oauthClientRegenerated, {'equals': oauthClientAfterRegenerate});
                return callback(oauthClientAfterRegenerate);
            });
        });
    });
};

/**
 * Regenerate the secret of an oauth client, ensuring the request fails in the specified manner
 *
 * @param  {RestClient}         client      The REST client with which to make the request
 * @param  {Number}             id          The id of the client whose secret to regenerate
 * @param  {Number}             httpCode    The expected HTTP status code of the failed request
 * @param  {Function}           callback    Invoked when complete
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertRegenerateOauthClientSecretFails = module.exports.assertRegenerateOauthClientSecretFails = function(client, id, httpCode, callback) {
    client.auth.regenerateOauthClientSecret(id, function(err, oauthClientRegenerated) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assertOauthClient(oauthClientRegenerated, {'exists': false});
        return callback();
    });
};

/**
 * Grant an oauth authorization code for the specified client
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             oauthClientId           The id of the client whose to which to grant an authorization code
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {String}             [opts.responseType]     The type of response, if specified, only "code" is currently supported
 * @param  {Boolean}            [opts.redirect]         If `true`, the response will be a redirect. If `false`, it will be an object containing the desired redirect. Default: `true`
 * @param  {Number}             [opts.redirectUri]      Provided for compliance, but currently unused. Successful grants are always redirected to the client's configured redirect uri
 * @param  {Number}             [opts.forUserId]        The id of the user for which to perform the grant, if not the current user. If unspecified, authorization code will be granted for the currently authenticated user. Only available for amdministrators
 * @param  {Function}           callback                Invoked when complete
 * @param  {String}             callback.code           The granted oauth authorization code
 * @param  {String}             callback.redirectUri    The redirect "location" header in the redirect response. This will include the oauth authorization code as a query string parameter
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertGrantOauthAuthCode = module.exports.assertGrantOauthAuthCode = function(client, oauthClientId, opts, callback) {
    assertGetOauthClient(client, oauthClientId, function(oauthClient) {
        client.auth.grantOauthAuthCode(oauthClientId, opts, function(err, body, response) {
            assert.ok(!err);

            // The value of `redirect` will alter the response. Interpret the response appropriately
            var actualRedirectUri = null;
            if (opts && opts.redirect === false) {
                assert.strictEqual(response.statusCode, 200);
                actualRedirectUri = body.redirectUri;
            } else {
                assert.strictEqual(response.statusCode, 302);
                actualRedirectUri = response.headers.location;
            }

            // Parse the returned redirect uri
            var actualParsedRedirectUri = url.parse(actualRedirectUri, true);
            var expectedParsedRedirectUri = url.parse(oauthClient.redirectUri, true);

            // Ensure we got a code
            assert.ok(_.isObject(actualParsedRedirectUri.query));
            assert.ok(_.isString(actualParsedRedirectUri.query.code));

            // Ensure that aside from the code being added, the redirect URI is the same as that of
            // the client
            assert.strictEqual(actualParsedRedirectUri.protocol, expectedParsedRedirectUri.protocol);
            assert.strictEqual(actualParsedRedirectUri.hostname, expectedParsedRedirectUri.hostname);
            assert.strictEqual(actualParsedRedirectUri.pathname, expectedParsedRedirectUri.pathname);
            assert.deepEqual(actualParsedRedirectUri.query, _.extend({}, expectedParsedRedirectUri.query, {'code': actualParsedRedirectUri.query.code}));

            return callback(actualParsedRedirectUri.query.code, actualRedirectUri);
        });
    });
};

/**
 * Grant an oauth authorization code for the specified client, ensuring that the request fails in
 * the specified manner
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             oauthClientId           The id of the client whose to which to grant an authorization code
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {String}             [opts.responseType]     The type of response, if specified, only "code" is currently supported
 * @param  {Number}             [opts.redirectUri]      Provided for compliance, but currently unused. Successful grants are always redirected to the client's configured redirect uri
 * @param  {Number}             [opts.forUserId]        The id of the user for which to perform the grant, if not the current user. If unspecified, authorization code will be granted for the currently authenticated user. Only available for amdministrators
 * @param  {Number}             httpCode                The expected HTTP status code of the failed request
 * @param  {Function}           callback                Invoked when complete
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertGrantOauthAuthCodeFails = module.exports.assertGrantOauthAuthCodeFails = function(client, oauthClientId, opts, httpCode, callback) {
    client.auth.grantOauthAuthCode(oauthClientId, opts, function(err, body, response) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Assertion function for the OauthAccessToken model
 */
var assertOauthAccessToken = module.exports.assertOauthAccessToken = TestsUtil.createAssertionFunction({

    /*!
     * Perform an OauthAccessToken-specific sanity check based on the given "view" expected from the
     * model. Possible views are:
     *
     *  * 'admin' - The OauthAccessToken was acquired by a user who administers the app of the token
     *  * 'user'  - The OauthAccessToken was acquired by the user who owns the access token
     *
     * No other views are possible as the OauthAccessToken model is only accessible by authenticated
     * users.
     *
     * @param  {String}     view    The expected view of the OauthAccessToken
     */
    'sanity': function(actualAccessToken, view) {
        // Extend the `validation` assertions to sanity check the access token fields
        var assertions = {
            'validate': {
                'id': _.isNumber,
                'token': _.isString,
                'OauthClientId': _.isNumber,
                'UserId': _.isNumber,
                'createdAt': function(actualCreatedAt) {
                    // It must have been created sometime in the last hour, assuming the tests run
                    // shorter than that
                    TestsUtil.assertTimestamp(actualCreatedAt, {
                        'after': moment().subtract(1, 'hours'),
                        'beforeOrEqual': moment()
                    });
                },
                'updatedAt': function(actualUpdatedAt) {
                    // It must have been updated somewhere between when it created and now
                    TestsUtil.assertTimestamp(actualUpdatedAt, {
                        'afterOrEqual': actualAccessToken.createdAt,
                        'beforeOrEqual': moment()
                    });
                }
            }
        };

        // Perform oauth client assertions if the client is returned
        if (actualAccessToken.OauthClient) {
            assertions.validate.OauthClient = function(actualOauthClient) {
                assertOauthClient(actualOauthClient, {
                    'sanity': view,
                    'match': {
                        'id': actualAccessToken.OauthClientId
                    }
                });
            };
        }

        // Perform user assertions if the user is returned
        if (actualAccessToken.User) {
            assertions.validate.User = function(actualUser) {
                assert.strictEqual(actualUser.id, actualAccessToken.UserId);
            };
        }

        assertOauthAccessToken(actualAccessToken, assertions);
    }
});

/**
 * Get all access tokens for a user
 *
 * @param  {RestClient}             client                  The REST client with which to make the request
 * @param  {Number}                 userId                  The id of the user whose access tokens to get
 * @param  {Function}               callback                Invoked when complete
 * @param  {OauthAccessToken[]}     callback.accessTokens   All access tokens associated to the user
 * @throws {AssertionError}                                 Thrown if any assertions fail
 */
var assertGetAllOauthAccessTokensByUser = module.exports.assertGetAllOauthAccessTokensByUser = function(client, userId, callback) {
    assertGetOauthAccessTokensByUser(client, userId, {'limit': 1}, function(firstResponse) {
        assertGetOauthAccessTokensByUser(client, userId, {'limit': firstResponse.count}, function(secondResponse) {
            assert.strictEqual(secondResponse.count, firstResponse.count);
            assert.strictEqual(secondResponse.count, secondResponse.rows.length);
            return callback(secondResponse.rows);
        });
    });
};

/**
 * Get a list of access tokens for a user
 *
 * @param  {RestClient}             client              The REST client with which to make the request
 * @param  {Number}                 userId              The id of the user whose access tokens to get
 * @param  {Object}                 [opts]              Optional arguments
 * @param  {Number}                 [opts.limit]        The maximum number of access tokens to return
 * @param  {Number}                 [opts.offset]       The offset index at which to start listing access tokens
 * @param  {Function}               callback            Invoked when complete
 * @param  {OauthAccessTokenList}   callback.response   The access token list response
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertGetOauthAccessTokensByUser = module.exports.assertGetOauthAccessTokensByUser = function(client, userId, opts, callback) {
    opts = opts || {};

    UsersTestsUtil.assertGetMe(client, function(me) {
        client.auth.getOauthAccessTokensByUser(userId, opts, function(err, response) {
            assert.ok(!err);
            assert.ok(_.isNumber(response.count));
            assert.ok(_.isArray(response.rows));
            assert.ok(response.count >= response.rows.length);

            if (_.isNumber(opts.limit)) {
                assert.ok(response.rows.length <= opts.limit);
            }

            _.each(response.rows, function(accessToken) {
                assertOauthAccessToken(accessToken, {
                    'sanity': _resolveExpectedView(me),
                    'match': {
                        'UserId': userId
                    }
                });
            });

            return callback(response);
        });
    });
};

/**
 * Get a list of access tokens for a user, ensuring it fails in the specified manner
 *
 * @param  {RestClient}         client          The REST client with which to make the request
 * @param  {Number}             userId          The id of the user whose access tokens to get
 * @param  {Object}             [opts]          Optional arguments
 * @param  {Number}             [opts.limit]    The maximum number of access tokens to return
 * @param  {Number}             [opts.offset]   The offset index at which to start listing access tokens
 * @param  {Number}             httpCode        The expected HTTP status code of the failed response
 * @param  {Function}           callback        Invoked when complete
 * @throws {AssertionError}                     Thrown if any assertions fail
 */
var assertGetOauthAccessTokensByUserFails = module.exports.assertGetOauthAccessTokensByUserFails = function(client, userId, opts, httpCode, callback) {
    client.auth.getOauthAccessTokensByUser(userId, opts, function(err, response) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!response);
        return callback();
    });
};

/**
 * Exchange an oauth authorization code for an oauth access token
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             oauthClientId           The id of the oauth client who is performing the exchange
 * @param  {String}             oauthClientSecret       The secret of the oauth client who is performing the exchange
 * @param  {String}             code                    The authorization code that was previously granted to the client
 * @param  {String}             redirectUri             The redirect uri of the client. This is an oauth-specific additional security measure
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {Number}             [opts.grantType]        The type of oauth grant to perform. Only "code" is supported and it is the default
 * @param  {Function}           callback                Invoked when complete
 * @param  {RestClient}         callback.bearerClient   A REST client that can be used to invoke requests with the exchanged token in the authorization bearer header
 * @param  {String}             callback.token          The access token string for which the authorization code was exchanged
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertExchangeOauthAuthCode = module.exports.assertExchangeOauthAuthCode = function(client, oauthClientId, oauthClientSecret, code, redirectUri, opts, callback) {
    TestsUtil.getGlobalAdminRestClient(function(globalAdminClient) {

        // Get the target app and oauth client. The given client may be anonymous, so we should just
        // use the global admin client for preliminary checks
        assertGetOauthClient(globalAdminClient, oauthClientId, function(oauthClient) {
            AppsTestsUtil.assertGetApp(globalAdminClient, oauthClient.AppId, null, function(app) {

                // Get the access token
                client.auth.exchangeOauthAuthCode(oauthClientId, oauthClientSecret, code, redirectUri, opts, function(err, response) {
                    assert.ok(!err);
                    assert.ok(response);
                    assert.strictEqual(response.token_type, 'Bearer');

                    var token = response.access_token;
                    assert.ok(_.isString(token));

                    // Get a client that is wired to make requests with the access token, ensuring
                    // it is authenticating as someone
                    TestsUtil.getOauthAppUserClient(app, token, function(bearerClient) {
                        UsersTestsUtil.assertGetMe(bearerClient, function(bearerMe) {
                            assert.ok(!bearerMe.anon);
                            assert.ok(_.isNumber(bearerMe.id));
                            assert.strictEqual(bearerMe.app.id, app.id);

                            // Ensure the token exists in the user's list of access tokens
                            assertGetAllOauthAccessTokensByUser(bearerClient, bearerMe.id, function(accessTokens) {
                                assert.ok(_.findWhere(accessTokens, {'token': token}));
                                return callback(bearerClient, token);
                            });
                        });
                    });
                });
            });
        });
    });
};

/**
 * Exchange an oauth authorization code for an oauth access token, ensuring the request fails in the
 * specified manner
 *
 * @param  {RestClient}         client                  The REST client with which to make the request
 * @param  {Number}             oauthClientId           The id of the oauth client who is performing the exchange
 * @param  {String}             oauthClientSecret       The secret of the oauth client who is performing the exchange
 * @param  {String}             code                    The authorization code that was previously granted to the client
 * @param  {String}             redirectUri             The redirect uri of the client. This is an oauth-specific additional security measure
 * @param  {Object}             [opts]                  Optional arguments
 * @param  {Number}             [opts.grantType]        The type of oauth grant to perform. Only "code" is supported and it is the default
 * @param  {Number}             httpCode                The expected HTTP status code of the failed request
 * @param  {Function}           callback                Invoked when complete
 * @param  {RestClient}         callback.bearerClient   A REST client that can be used to invoke requests with the exchanged token in the authorization bearer header
 * @param  {String}             callback.token          The access token string for which the authorization code was exchanged
 * @throws {AssertionError}                             Thrown if any assertions fail
 */
var assertExchangeOauthAuthCodeFails = module.exports.assertExchangeOauthAuthCodeFails = function(client, oauthClientId, oauthClientSecret, code, redirectUri, opts, httpCode, callback) {
    client.auth.exchangeOauthAuthCode(oauthClientId, oauthClientSecret, code, redirectUri, opts, function(err, response) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        assert.ok(!response);
        return callback();
    });
};

/**
 * Delete an oauth access token by its string token value
 *
 * @param  {RestClient}         client      The REST client with which to make the request
 * @param  {String}             token       The unique string token value of the access token
 * @param  {Function}           callback    Invoked when complete
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertDeleteOauthAccessTokenByToken = module.exports.assertDeleteOauthAccessTokenByToken = function(client, token, callback) {
    client.auth.deleteOauthAccessTokenByToken(token, function(err) {
        assert.ok(!err);
        return callback();
    });
};

/**
 * Delete an oauth access token by its string token value, ensuring the request fails in the
 * specified manner
 *
 * @param  {RestClient}         client      The REST client with which to make the request
 * @param  {String}             token       The unique string token value of the access token
 * @param  {Number}             httpCode    The expected HTTP status code of the failed request
 * @param  {Function}           callback    Invoked when complete
 * @throws {AssertionError}                 Thrown if any assertions fail
 */
var assertDeleteOauthAccessTokenByTokenFails = module.exports.assertDeleteOauthAccessTokenByTokenFails = function(client, token, httpCode, callback) {
    client.auth.deleteOauthAccessTokenByToken(token, function(err) {
        assert.ok(err);
        assert.strictEqual(err.code, httpCode);
        return callback();
    });
};

/**
 * Determine the view we should expect (either "admin" or "user") from a user's `me` object
 *
 * @param  {Me}     me      The `me` object of the user
 * @return {String}         The expected view, either "admin" or "user"
 * @api private
 */
var _resolveExpectedView = function(me) {
    var isAdmin = (!me.anon && (me.app.isGlobalAdmin || me.isAdmin));
    return (isAdmin) ? 'admin' : 'user';
};
