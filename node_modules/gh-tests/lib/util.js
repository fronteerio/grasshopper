/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var assert = require('assert');
var ConfigAPI = require('gh-config');
var ICalParser = require('cozy-ical').ICalParser;
var moment = require('moment');
var parseString = require('xml2js').parseString;
var util = require('util');

var Grasshopper = require('gh-core');
var RestAPI = require('gh-rest');
var RestUtil = require('gh-rest/lib/util');

var _config = null;

/**
 * Create the initial test configuration
 *
 * @return {Object}     config           The application configuration
 */
var createInitialTestConfig = module.exports.createInitialTestConfig = function() {
    // Require the configuration file. From here on, the configuration should be
    // passed around instead of required
    var config = require('../../../config');

    // Streams can't be deep copied so we stash them in a variable, delete them from the config
    // and add them to the final config
    var logConfig = config.log;
    delete config.log;
    config = _.cloneDeep(config);
    config.log = logConfig;
    config.log.streams = [{
        'level': 'trace',
        'path': './tests.log'
    }];

    // Ensure that test data does not find its way into the main database
    config.db.database = 'grasshoppertest';
    config.db.dropOnStartup = true;

    // Ensure that the tests always run on the correct hostname/ports
    config.servers.adminPort = 2000;
    config.servers.appsPort = 2001;

    return config;
};

/**
 * Set up Grasshopper and create a number of test tenants, apps and admins
 *
 * @param  {Object}      config         The application configuration
 * @param  {Function}    callback       Standard callback function
 */
var setUpBeforeTests = module.exports.setUpBeforeTests = function(config, callback) {

    // Set the config so it can be accessed elsewhere in the application
    _config = config;

    // Initialize the core container
    Grasshopper.init(config, function(err) {
        if (err) {
            return callback(new Error(err.msg));
        }

        // Pipe REST events to our test logger
        _bindRequestLogger();

        // Get a global admin rest client
        getGlobalAdminRestClient(function(globalAdminRestClient) {

            // Create 2 tenants with 2 apps each
            globalAdminRestClient.tenant.createTenant('Cambridge University', function(err, cambridgeTenant) {
                if (err) {
                    return callback(err);
                }
                globalAdminRestClient.tenant.createTenant('Oxford University', function(err, oxfordTenant) {
                    if (err) {
                        return callback(err);
                    }

                    createDefaultTestApps(globalAdminRestClient, cambridgeTenant, 'timetable.cam.ac.uk', function(err, cambridge2013App, cambridge2014App, cambridge2013Admin, cambridge2014Admin) {
                        if (err) {
                            return callback(err);
                        }
                        createDefaultTestApps(globalAdminRestClient, oxfordTenant, 'timetable.oxford.ac.uk', function(err, oxford2013App, oxford2014App, oxford2013Admin, oxford2014Admin) {
                            if (err) {
                                return callback(err);
                            }

                            // Expose the tenant and apps on the global object
                            global.tests = {
                                'tenants': {
                                    'cam': cambridgeTenant,
                                    'oxford': oxfordTenant
                                },
                                'apps': {
                                    'cam2013': cambridge2013App,
                                    'cam2014': cambridge2014App,
                                    'oxford2013': oxford2013App,
                                    'oxford2014': oxford2014App
                                },
                                'admins': {
                                    'cam2013': cambridge2013Admin,
                                    'cam2014': cambridge2014Admin,
                                    'oxford2013': oxford2013Admin,
                                    'oxford2014': oxford2014Admin
                                }
                            };

                            return callback();
                        });
                    });
                });
            });
        });
    });
};

/**
 * Bind request logging for gh-rest unit test debugging
 *
 * @api private
 */
var _bindRequestLogger = function() {
    var requestLog = require('gh-core/lib/logger').logger('request-log');

    RestUtil.on('request', function(url, method, data) {
        requestLog().trace({
            'url': url,
            'method': method,
            'data': data
        }, 'Performing REST request');
    });

    RestUtil.on('response', function(body, res) {
        requestLog().trace({'res': res, 'body': body}, 'REST Request complete');
    });

    RestUtil.on('error', function(err, body, res) {
        requestLog().error({
            'err': err,
            'res': res,
            'body': body
        }, 'An error occurred sending a REST request');
    });
};

/**
 * Create 2 timetable apps for a tenant. Each app represents a different year
 *
 * @param  {RestClient}     globalAdminRestClient       A rest client that is authenticated as the global admin
 * @param  {Tenant}         tenant                      The tenant on which to create the app
 * @param  {String}         hostSuffix                  The suffix for the application hostnames (e.g. `timetable.oxford.ac.uk`)
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {App}            callback.app2013            The 2013 app
 * @param  {App}            callback.app2014            The 2014 app
 * @param  {User}           callback.admin2013          An app administrator for the 2013 app
 * @param  {User}           callback.admin2014          An app administrator for the 2014 app
 * @api private
 */
var createDefaultTestApps = function(globalAdminRestClient, tenant, hostSuffix, callback) {
    createDefaultTestApp(globalAdminRestClient, tenant, hostSuffix, 2013, function(err, app2013, admin2013) {
        if (err) {
            return callback(err);
        }

        createDefaultTestApp(globalAdminRestClient, tenant, hostSuffix, 2014, function(err, app2014, admin2014) {
            if (err) {
                return callback(err);
            }

            return callback(null, app2013, app2014, admin2013, admin2014);
        });
    });
};

/**
 * Create a timetable app for a given tenant and year
 *
 * @param  {RestClient}     globalAdminRestClient       A rest client that is authenticated as the global admin
 * @param  {Tenant}         tenant                      The tenant on which to create the application
 * @param  {String}         hostSuffix                  The suffix for the application hostnames (e.g. `timetable.oxford.ac.uk`)
 * @param  {Number}         year                        The year for which to create the application
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {App}            callback.app                The created app
 * @param  {User}           callback.user               An app administrator for the created app
 * @api private
 */
var createDefaultTestApp = function(globalAdminRestClient, tenant, hostSuffix, year, callback) {
    var displayName = year;
    var host = util.format('%s.%s', year, hostSuffix);

    // Generate the test app
    _generateTestApp(globalAdminRestClient, tenant.id, displayName, host, function(app) {

        // Create an app administrator for this app
        generateTestUser(app, true, function(err, user) {
            if (err) {
                return callback(err);
            }

            return callback(null, app, user);
        });
    });
};

/**
 * Get the application configuration used for the test suite
 *
 * @return {Config}                The application configuration
 */
var getConfig = module.exports.getConfig = function() {
    return _config;
};

/**
 * Get the address and port on which the global administration server is listening.
 * The returned uri will be formatted as `address:port`
 *
 * @return {String} The address and port on which the global administration server is listening formatted
 */
var getAdminListenUri = module.exports.getAdminListenUri = function() {
    var config = getConfig();
    return util.format('%s:%d', config.servers.listenAddress, config.servers.adminPort);
};

/**
 * Get the address and port on which the application server is listening.
 * The returned uri will be formatted as `address:port`
 *
 * @return {String} The address and port on which the application server is listening formatted
 */
var getAppListenUri = module.exports.getAppListenUri = function() {
    var config = getConfig();
    return util.format('%s:%d', config.servers.listenAddress, config.servers.appsPort);
};

/**
 * Get an anonymous global administrator REST client
 *
 * @param  {Function}       callback                    Standard callback function
 * @param  {RestClient}     callback.client             An anonymous global administrator REST client
 */
var getAnonymousGlobalAdminRestClient = module.exports.getAnonymousGlobalAdminRestClient = function(callback) {
    var options = {
        'host': getAdminListenUri(),
        'hostHeader': getConfig().servers.adminHostname
    };
    RestAPI.createClient(options, function(err, client) {
        assert.ok(!err);
        return callback(client);
    });
};

/**
 * Get an authenticated global administrator REST client
 *
 * @param  {Function}       callback                    Standard callback function
 * @param  {RestClient}     callback.client             An authenticated global administrator REST client
 */
var getGlobalAdminRestClient = module.exports.getGlobalAdminRestClient = function(callback) {
    var options = {
        'host': getAdminListenUri(),
        'hostHeader': getConfig().servers.adminHostname,
        'authenticationStrategy': 'local',
        'username': 'administrator',
        'password': 'administrator'
    };
    RestAPI.createClient(options, function(err, client) {
        assert.ok(!err);
        return callback(client);
    });
};

/**
 * Get a mocked global admin application object
 *
 * @return {Object}     A mocked global admin object
 */
var getGlobalAdminApp = module.exports.getGlobalAdminApp = function() {
    return {
        'displayName': 'Global admin server',
        'host': getConfig().servers.adminHostname,
        'isGlobalAdmin': true
    };
};

/**
 * Get an anonymous Shibboleth REST client
 *
 * @param  {Function}       callback                    Standard callback function
 * @param  {RestClient}     callback.client             An anonymous Shibboleth REST client
 */
var getShibbolethRestClient = module.exports.getShibbolethRestClient = function(callback) {
    var options = {
        'host': getAppListenUri(),
        'hostHeader': getConfig().servers.shibbolethSPHost
    };
    RestAPI.createClient(options, function(err, client) {
        assert.ok(!err);
        return callback(client);
    });
};

/**
 * Get an anonymous app user REST client
 *
 * @param  {App}            app                         The app for which to create an anonymous user REST client
 * @param  {Function}       callback                    Standard callback function
 * @param  {RestClient}     callback.client             An anonymous app user REST client
 */
var getAnonymousAppUserClient = module.exports.getAnonymousAppUserClient = function(app, callback) {
    var options = {
        'host': getAppListenUri(),
        'hostHeader': app.host
    };
    RestAPI.createClient(options, function(err, client) {
        assert.ok(!err);
        return callback(client);
    });
};

/**
 * Get a REST client that authenticates using the given bearer token
 *
 * @param  {App}            app                 The app for which to create a bearer token client
 * @param  {String}         token               The bearer token that will be used by the client
 * @param  {Function}       callback            Standard callback function
 * @param  {RestClient}     callback.client     A bearer token REST client
 */
var getOauthAppUserClient = module.exports.getOauthAppUserClient = function(app, token, callback) {
    var options = {
        'host': 'localhost:2001',
        'hostHeader': app.host,
        'bearer': token
    };
    RestAPI.createClient(options, function(err, client) {
        assert.ok(!err);
        return callback(client);
    });
};

/**
 * Create a test tenant and a number of applications
 *
 * @param  {Number}     nrOfApps            The number of apps that should be added to the tenant
 * @param  {Function}   callback            Standard callback function
 * @param  {Tenant}     callback.tenant     The created tenant
 * @param  {App}        [callback.app1]     The first created application
 * @param  {App}        [callback.app2]     The next created application
 * @param  {App}        [callback...]       Each application is provided as an argument
 */
var generateTestTenant = module.exports.generateTestTenant = function(nrOfApps, callback) {
    var tenantDisplayName = generateString();

    getGlobalAdminRestClient(function(globalAdminClient) {
        globalAdminClient.tenant.createTenant(tenantDisplayName, function(err, tenant) {
            assert.ok(!err);

            if (nrOfApps === 0) {
                return callback(tenant);
            }

            var args = [tenant];

            // Gets executed once all the applications have been created
            var done = _.after(nrOfApps, function() {
                return callback.apply(callback, args);
            });

            // Create a number of applications
            _.times(nrOfApps, function(n) {
                var appDisplayName = util.format('%s %d', tenantDisplayName, n);
                var host = util.format('%d.%s.grasshopper.local', n, tenantDisplayName);
                _generateTestApp(globalAdminClient, tenant.id, appDisplayName, host, function(app) {
                    args.push(app);
                    return done();
                });
            });
        });
    });
};

/**
 * Generate a test app
 *
 * @param  {RestClient}     globalAdminRestClient       A rest client that is authenticated as the global admin
 * @param  {Number}         tenantId                    The id of the tenant on which to create the application
 * @param  {String}         displayName                 The display name of the new app
 * @param  {String}         host                        The hostname of the new app
 * @param  {Function}       callback                    Standard callback function
 * @param  {App}            callback.app                The created application
 * @api private
 */
var _generateTestApp = function(globalAdminRestClient, tenantId, displayName, host, callback) {
    var createdApp = null;
    var isCached = false;
    var isRequestDone = false;

    /*!
     * This function will return the created application to the caller
     * when the REST request has finished and its config has been cached
     */
    var done = function() {
        if (isRequestDone && isCached) {
            return callback(createdApp);
        }
    };

    // Create the app
    globalAdminRestClient.app.createApp(tenantId, displayName, host, 'timetable', function(err, app) {
        assert.ok(!err);
        createdApp = app;
        isRequestDone = true;
        done();
    });

    // Wait until the config for the new app has been cached
    ConfigAPI.once('cached', function() {
        isCached = true;
        done();
    });
};

/**
 * Generate a number of test users
 *
 * @param  {App}            app                         The app on which to create the test users
 * @param  {Number}         total                       The total number of test users that need to be created. If not provided, a single test user will be created
 * @param  {Boolean}        [isAdmin]                   Whether the test users should be app administrators
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.user1              An object containing the REST client and profile of the created user
 * @param  {User}           callback.user1.profile      The basic user profile of the created user
 * @param  {RestClient}     callback.user1.client       The REST client for the created user
 * @param  {Object}         [callback.user2]            The next created user(s)
 * @param  {Object}         [callback....]              Each created user as an additional callback argument
 */
var generateTestUsers = module.exports.generateTestUsers = function(app, total, isAdmin, callback) {
    var createdUsers = [];

    // Only gets executed once all the users have been created
    var done = _.after(total, function() {
        return callback.apply(null, createdUsers);
    });

    // Generate each user asynchronous
    _.times(total, function() {
        generateTestUser(app, isAdmin, function(err, user) {
            assert.ok(!err);

            createdUsers.push(user);
            done();
        });
    });
};

/**
 * Generate a test app user
 *
 * @param  {App}            app                         The app on which to create the test user
 * @param  {Boolean}        [isAdmin]                   Whether the test user should be an app administrator
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Object}         callback.user               An object containing the REST client and profile of the created test user
 * @param  {User}           callback.user.profile       The basic user profile of the created test user
 * @param  {RestClient}     callback.user.client        The REST client for the created test user
 */
var generateTestUser = function(app, isAdmin, callback) {
    // Lower-case the name to avoid weird ordering issues
    var displayName = generateString().toLowerCase();
    var email = generateTestEmailAddress();
    var password = generateString();

    getGlobalAdminRestClient(function(globalAdminClient) {
        globalAdminClient.user.createUser(displayName, email, password, {'app': app.id, 'isAdmin': isAdmin}, function(err, user) {
            if (err) {
                return callback(err);
            }

            // Create a REST client for the created user
            var options = {
                'host': getAppListenUri(),
                'hostHeader': app.host,
                'authenticationStrategy': 'local',
                'username': email,
                'password': password
            };

            RestAPI.createClient(options, function(err, client) {
                if (err) {
                    return callback(err);
                }

                return callback(null, {'profile': user, 'client': client});
            });
        });
    });
};

/**
 * Generate a random unique user id that can be used inside of tests
 *
 * @param  {String}     [seed]  String that should be used as the first part of the generated user id. Defaults to "user"
 * @return {String}             A random user id
 */
var generateTestUserId = module.exports.generateTestUserId = function(seed) {
    seed = seed || 'user';
    return util.format('%s-%s', seed, generateString());
};

/**
 * Generate a unique and random email address based on an optional seed
 *
 * @param  {String}     [seed]      The seed / prefix of the email address. Defaults to "email"
 * @param  {String}     [domain]    The domain on which to put the email. Defaults to "gh-email.com"
 * @return {String}                 A random email address
 */
var generateTestEmailAddress = module.exports.generateTestEmailAddress = function(seed, domain) {
    seed = seed || 'email';
    domain = domain || 'gh-email.com';
    return util.format('%s_%s@%s', seed, generateString(), domain);
};

/**
 * Generate a random string
 *
 * @param  {Number}     [letters]   The number of letters that should be in the string, defaults to `10`
 * @return {String}                 A random string of letters
 */
var generateString = module.exports.generateString = function(letters) {
    letters = letters || 10;
    var alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    var word = '';
    for (var i = 0; i < letters; i++) {
        word += alphabet[_.random(alphabet.length - 1)];
    }
    return word;
};

/**
 * Parse an RSS calendar
 *
 * @param  {String}             calendar                The RSS calendar
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.calendar       The parsed RSS calendar
 * @throws {AssertionError}                             Error thrown when an assertion failed
 */
var parseRssCalendar = module.exports.parseRssCalendar = function(calendar, callback) {
    parseString(calendar, function(err, result) {
        assert.ok(!err);

        // Assert the calendar is in proper RSS format
        assert.ok(result.rss);
        assert.ok(result.rss['$']);
        assert.strictEqual(result.rss['$']['version'], '2.0');
        assert.strictEqual(result.rss['$']['xmlns:ev'], 'http://purl.org/rss/1.0/modules/event/');

        // Assert that some basic information like a calendar title is present
        assert.ok(result.rss.channel[0]);
        assert.ok(result.rss.channel[0].title);

        // Return the calendar
        return callback(result.rss.channel[0]);
    });
};

/**
 * Parse an iCal calendar
 *
 * @param  {String}             calendar                The iCal calendar
 * @param  {Function}           callback                Standard callback function
 * @param  {Object}             callback.calendar       The parsed iCal calendar
 * @throws {AssertionError}                             Error thrown when an assertion failed
 */
var parseIcalCalendar = module.exports.parseIcalCalendar = function(calendar, callback) {
    var parser = new ICalParser();
    parser.parseString(calendar, function(err, calendar) {
        assert.ok(!err);

        // Assert the calendar has a title
        // TODO: Broken in cozy-ical's 1.1.2 parser
        // assert.ok(calendar.fields);
        // assert.ok(calendar.fields.PRODID);

        _.each(calendar.subComponents, function(item) {
            // Convert the date timestamps to ISO8601 so they can be properly reasoned on
            if (item.fields && item.fields.DTSTART) {
                item.fields.DTSTART = moment(newitem.fields.DTSTART, 'YYYYMMDDTHHmmss').format();
            }
            if (item.fields && item.fields.DTEND) {
                item.fields.DTEND = moment(newitem.fields.DTEND, 'YYYYMMDDTHHmmss').format();
            }
        });

        return callback(calendar);
    });
};

/**
 * Create a function that can invoke a standard set of assertions for some type of generic object.
 * The returned function will accept some actual data (e.g., a server response) and a set of
 * assertions that the consumer wants to perform, along with some set of expected data. If any
 * assertions fail, an `AssertionError` is thrown from the assertion function. The following generic
 * assertions are provided for you:
 *
 *  * 'equals': Performs an `assert.deepEqual` on the actual data and the expected data
 *  * 'exists': When truthy, ensures the actual data is truthy. When falsey, ensures the actual data is falsey
 *  * 'match': Given an object of arbitrary keys and values, ensures that all keys and expected values are present on the actual data object. Similar to 'equals' but allows one to assert partial data
 *  * 'missing': Given an array of strings, ensures the actual data contains of the strings as keys
 *  * 'validate': Given an object keyed by property name whose value is a validation function, ensure the value identified by the key succeeds in validation. If the validation function returns a boolean, it will assert that it is true. Otherwise, you can simply perform your own assertions in the validation with no return value for full customization
 *
 * To override any of the generic assertion methods, simply provide a custom assertion function with
 * the same assertion name and it will be overridden.
 *
 * @param  {Object}     customAssertionFunctions        An object keyed by "assertion name" whose value is a function that takes the expected data, actual data, and allows you to run custom assertions
 * @return {Function}   assertionFunction               The assertion function that can be used in tests
 *         {Object}     assertionFunction.actualData    Represents the "actual" data object you wish to run assertions on
 *         {Object}     assertionFunction.assertions    An object keyed by assertion type (e.g., 'equals'), whose value is the assertion-specific data (usually "expected" data)
 */
var createAssertionFunction = module.exports.createAssertionFunction = function(customAssertionFunctions) {
    customAssertionFunctions = customAssertionFunctions || {};

    var _assertExists = function(actual, exists) {
        if (exists) {
            assert.ok(actual);
        } else {
            assert.ok(!actual);
        }
    };

    // Create our set of default generic assertion functions that are handy for most cases. See
    // function summary for more information about what these functions do
    var defaultAssertionFunctions = {
        'equals': assert.deepEqual,
        'exists': _assertExists,
        'match': function(actual, expectedFieldValues) {
            if (_.isEmpty(expectedFieldValues)) {
                assert.fail('Expected to assert the value of at least one field');
            }

            // Ensure the object is specified
            _assertExists(actual, true);

            _.each(expectedFieldValues, function(value, key) {
                assert.strictEqual(actual[key], value);
            });
        },
        'missing': function(actual, missingKeys) {
            if (!_.isArray(missingKeys) || _.isEmpty(missingKeys)) {
                assert.fail('Expected a non-empty array of missing keys to test');
            }

            // Ensure the object is specified
            _assertExists(actual, true);

            var invalidKeys = _.chain(actual)
                .keys()
                .intersection(missingKeys)
                .value();
            assert.ok(_.isEmpty(invalidKeys), util.format('Invalid keys existed on actual object: "%s"', invalidKeys.join('", "')));
        },
        'validate': function(actual, validationFunctions) {
            if (_.isEmpty(validationFunctions)) {
                assert.fail('Expected to apply at least one validation');
            }

            // Ensure the object is specified
            _assertExists(actual, true);

            _.each(validationFunctions, function(validationFunction, key) {
                if (!_.chain(actual).keys().contains(key).value()) {
                    // Sanity check no typos in key names. If they want to validate a key
                    // doesn't exist, "missing" should be used instead
                    assert.fail(util.format('Tried to validate non-existing key "%s" on actual object', key));
                }

                var validationResult = null;
                try {
                    validationResult = validationFunction(actual[key]);
                } catch (ex) {
                    // Rewrite the message to be a bit more descriptive
                    ex.message = util.format('(key: "%s") %s', key, ex.message);
                    throw ex;
                }

                if (_.isBoolean(validationResult)) {
                    // Give the validation function an opportunity to just use a boolean
                    // validation check. Makes value type checks super easy by just specifying
                    // something like `_.isString` as the function
                    assert.ok(validationResult, util.format('Validation for key "%s" failed', key));
                } else if (!_.isUndefined(validationResult)) {
                    // Sanity check that the validation function isn't misimplemented
                    assert.fail(util.format('Validation function for key "%s" returned type %s, but only boolean or undefined are expected', key, typeof validationResult));
                }
            });
        }
    };

    // Overlay the default assertion functions onto the provided custom assertion functions
    var assertionFunctions = _.defaults(customAssertionFunctions, defaultAssertionFunctions);

    return function(actualData, assertions) {
        if (_.isEmpty(assertions)) {
            // There should always be at least one assertion
            assert.fail('Expected at least one assertion to perform');
        }

        // Run each assertion that was specified by the consumer with the expected assertion data.
        // The actual meaning of the data is dependent on the assertion implementation in
        // `assertionFunctions`
        _.each(assertions, function(expectedData, name) {
            var assertionFunction = assertionFunctions[name];
            if (!_.isFunction(assertionFunction)) {
                // Fail hard if the consumer specified an assertion that doesn't have any
                // functionality associated to it
                assert.fail(util.format('Invalid assertion specified with name "%s"', name));
            }

            assertionFunction(actualData, expectedData);
        });
    };
};

/**
 * Assertion function that validates some aspects of a timestamp
 */
var assertTimestamp = module.exports.assertTimestamp = createAssertionFunction({
    'before': function(actualTimestamp, dateExpr) {
        assert.ok(_getMillis(actualTimestamp) < _getMillis(dateExpr));
    },
    'beforeOrEqual': function(actualTimestamp, dateExpr) {
        assert.ok(_getMillis(actualTimestamp) <= _getMillis(dateExpr));
    },
    'after': function(actualTimestamp, dateExpr) {
        assert.ok(_getMillis(actualTimestamp) > _getMillis(dateExpr));
    },
    'afterOrEqual': function(actualTimestamp, dateExpr) {
        assert.ok(_getMillis(actualTimestamp) >= _getMillis(dateExpr));
    }
});

/**
 * Get the millis-since-epoch of a given multi-type expression that represents some date or time
 * or timestamp
 *
 * @param  {Number|String|Moment|Date}  millisExpr  The expression representing some date and time
 * @return {Number}                                 The millis since the epoch
 * @api private
 */
var _getMillis = function(millisExpr) {
    var millis = null;
    if (_.isString(millisExpr)) {
        millis = moment(new Date(millisExpr)).valueOf();
    } else if (_.isNumber(millisExpr)) {
        millis = millisExpr;
    } else if (moment.isMoment(millisExpr)) {
        millis = millisExpr.valueOf();
    } else if (millisExpr instanceof Date) {
        millis = millisExpr.getTime();
    } else {
        assert.fail('Invalid before expression');
    }

    return millis;
};
