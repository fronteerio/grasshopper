/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var util = require('util');

var AuthUtil = require('gh-auth/lib/util');
var AppsAPI = require('gh-apps');
var CalendarInfo = require('gh-calendar/lib/model').CalendarInfo;
var CalendarUtil = require('gh-calendar/lib/util');
var DB = require('gh-core/lib/db');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-users');
var OrgUnitDAO = require('gh-orgunit/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var UsersAuthz = require('./authz');
var UsersDAO = require('./internal/dao');

/**
 * Get a user
 *
 * @param  {Number}         id                              The id of the user to retrieve
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The requested user
 */
var getUser = module.exports.getUser = function(id, callback) {
    // TODO: id validation
    // TODO: hide calendarToken

    UsersDAO.getUser(id, callback);
};

/**
 * Get a user by its authentication credentials
 *
 * @param  {Number}         appId                           The id of the app to which the user belongs
 * @param  {String}         strategy                        The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         identifier                      The unique credentials identifier for the user. `email` when using local authentication or `shibbolethId` when using Shibboleth authentication
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The requested user
 */
var getUserByCredentials = module.exports.getUserByCredentials = function(appId, strategy, identifier, callback) {
    // TODO: validate strategy
    // TODO: validate app
    // TODO: validate identifier

    UsersDAO.getUserByCredentials(appId, strategy, identifier, callback);
};

/**
 * Create a new user
 *
 * @param  {Context}        ctx                             The current execution context containing the user and application
 * @param  {Number}         appId                           The id of the app on which the user should be created
 * @param  {Object}         userProfile                     The user profile parameters for the user
 * @param  {String}         userProfile.displayName         The name of the user
 * @param  {String}         userProfile.email               The email address for the user
 * @param  {String}         userProfile.emailPreference     The email preference for the user. One of `immediate` or `no`
 * @param  {String}         userProfile.isAdmin             Whether the user is an app administrator. Only allowed when the current user is an administrator
 * @param  {Object}         credentials                     The authentication credentials for the user
 * @param  {String}         credentials.strategy            The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         [credentials.password]          The password with which the user will authenticate. Only required when using the local authentiation strategy
 * @param  {String}         [credentials.shibbolethId]      The unique shibboleth id for the user. Only required when using the Shibboleth authentication strategy
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User}           callback.user                   The created user
 */
var createUser = module.exports.createUser = function(ctx, appId, userProfile, credentials, callback) {
    userProfile = userProfile || {};
    userProfile.emailPreference = userProfile.emailPreference || 'immediate';
    userProfile.isAdmin = GrasshopperUtil.getBooleanParam(userProfile.isAdmin, false);

    // TODO: displayName validation
    // TODO: email validation
    // TODO: email preference validation
    // TODO: isAdmin validation
    // TODO: strategy validation
    // TODO: validate password when using local
    // TODO: validate shibbolethid when using shib

    // Verify that the provided app exists
    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        // Ensure that a user with the provided credentials doesn't already exist
        getUserByCredentials(appId, credentials.strategy, (credentials.shibbolethId || userProfile.email), function(err, user) {
            if (user) {
                log().error({'err': err, 'credentials': (credentials.shibbolethId || userProfile.email)}, 'Failed to create a new user');
                return callback({'code': 400, 'msg': 'A user with the provided authentication credentials already exists'});
            } else if (err && err.code !== 404) {
                return callback(err);
            }

            UsersDAO.createUser(appId, userProfile, credentials, callback);
        });
    });
};

/**
 * Validate the login credentials for a user
 *
 * @param  {Number}         appId                           The id of the app to which the user belongs
 * @param  {String}         email                           The email of the user to attempt login validation for. The email acts as the username
 * @param  {String}         password                        The password to attempt login validation with
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The user for the provided username and password. If the provided password was incorrect, this will be `null`
 */
var validateLoginCredentials = module.exports.validateLoginCredentials = function(appId, email, password, callback) {
    // TODO: email validation
    // TODO: password validation

    // Ensure that a user with the provided credentials exist
    getUserByCredentials(appId, 'local', email, function(err, user) {
        // No user could be found for the provided credentials
        if (err && err.code === 404) {
            log().warn({'err': err, 'email': email}, 'The provided user email is incorrect');
            return callback({'code': 401, 'msg': 'The provided user email is incorrect'});
        // A different error occured
        } else if (err) {
            log().error({'err': err, 'email': email}, 'Failed to validate the login credentials for a user');
            return callback(err);
        }

        var match = AuthUtil.comparePassword(password, user.password);
        if (!match) {
            log().warn({'err': err, 'email': email}, 'The provided user password is incorrect');
            return callback({'code': 401, 'msg': 'The provided user password is incorrect'});
        }

        return callback(null, user);
    });
};


//////////////
// Calendar //
//////////////

/**
 * Get the calendar for a user
 *
 * @param  {Context}    ctx                 The current execution context containing the user and application
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     start               The timestamp (ISO 8601) from which to get the calendar for the user
 * @param  {String}     end                 The timestamp (ISO 8601) until which to get the calendar for the user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Event[]}    callback.events     The events in a user's calendar
 */
var getUserCalendar = module.exports.getUserCalendar = function(ctx, id, start, end, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can retrieve a user\'s calendar'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(start, {'code': 400, 'msg': 'A start time must be provided in a valid date format'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'An end time must be provided in a valid date format'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the user's calendar
    _getUserCalendar(ctx, id, true, null, start, end, function(err, user, events) {
        if (err) {
            return callback(err);
        }

        return callback(null, events);
    });
};

/**
 * Get the calendar for a user in iCal
 *
 * @param  {Context}    ctx                 The current execution context containing the user and application
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     token               The access control token
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {String}     callback.ical       The requested event series calendar in iCal format
 */
var getUserCalendarIcal = module.exports.getUserCalendarIcal = function(ctx, id, token, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(token, {'code': 400, 'msg': 'A valid access control token must be provided'}).len(32, 32);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the user's calendar
    _getUserCalendar(ctx, id, false, token, null, null, function(err, user, events) {
        if (err) {
            return callback(err);
        }

        // Return the events as iCal
        var calendarInfo = _getCalendarInfo(ctx, user, 'ical');
        var ical = CalendarUtil.eventsToICal(calendarInfo, events);
        return callback(null, ical);
    });
};

/**
 * Get the calendar for a user in RSS
 *
 * @param  {Context}    ctx                 The current execution context containing the user and application
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     token               The access control token
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {String}     callback.rss        The requested event series calendar in RSS format
 */
var getUserCalendarRSS = module.exports.getUserCalendarRSS = function(ctx, id, token, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(token, {'code': 400, 'msg': 'A valid access control token must be provided'}).len(32, 32);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the user's calendar
    _getUserCalendar(ctx, id, false, token, null, null, function(err, user, events) {
        if (err) {
            return callback(err);
        }

        // Return the events as RSS
        var calendarInfo = _getCalendarInfo(ctx, user, 'rss');
        var rss = CalendarUtil.eventsToRSS(calendarInfo, events);
        return callback(null, rss);
    });
};

/**
 * Get the calendar for a user
 *
 * @param  {Context}    ctx                 The current execution context containing the user and application
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {Boolean}    [includeContext]    Whether or not the organisational units that were provided as context during subscription should be included
 * @param  {String}     [token]             The access control token
 * @param  {String}     [start]             The timestamp (ISO 8601) from which to get the calendar for the user
 * @param  {String}     [end]               The timestamp (ISO 8601) until which to get the calendar for the user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {User}       callback.user       The user who owns the calendar
 * @param  {Event[]}    callback.events     The events in a user's calendar
 * @api private
 */
var _getUserCalendar = function(ctx, id, includeContext, token, start, end, callback) {
    // Ensure the user exists
    getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can get the calendar
        UsersAuthz.canGetUserCalendar(ctx, user, token, function(err, canGetCalendar) {
            if (err) {
                return callback(err);
            } else if (!canGetCalendar) {
                log().warn({'id': id}, 'Unauthorized attempt at retrieving a user\'s calendar');
                return callback({'code': 401, 'msg': 'You are not allowed to retrieve this user\'s calendar'});
            }

            // Get the events in the user calendar
            UsersDAO.getUserCalendar(user, includeContext, start, end, function(err, events) {
                if (err) {
                    return callback(err);
                }

                return callback(null, user, events);
            });
        });
    });
};

/**
 * Reset a user's calendar token
 *
 * @param  {Context}    ctx                 The current execution context containing the user and application
 * @param  {Number}     id                  The id of the user to reset the calendar token for
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {User}       callback.user       The full user object
 */
var resetUserCalendarToken = module.exports.resetUserCalendarToken = function(ctx, id, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can reset a user\'s calendar token'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can reset the user's token
        UsersAuthz.canResetUserToken(ctx, user, function(err, canResetToken) {
            if (err) {
                return callback(err);
            } else if (!canResetToken) {
                log().warn({'id': id, 'actor': ctx.user.id}, 'Unauthorized attempt at resetting a user\'s calendar token');
                return callback({'code': 401, 'msg': 'You are not allowed to reset this user\'s calendar token'});
            }

            // Generate a new token and persist it
            var token = UsersDAO.generateCalendarToken();
            var update = {
                'calendarToken': token
            };
            return UsersDAO.updateUser(user, update, callback);
        });
    });
};

/**
 * Get the calendar info for a user
 *
 * @param  {Context}    ctx         Standard context containing the current user and the current app
 * @param  {User}       user        The user for which to get the calendar info
 * @param  {String}     format      The format in which the calendar will be returned. One of `ical` or `rss`
 * @return {CalendarInfo}           An object representing the calendar info for the user
 * @api private
 */
var _getCalendarInfo = function(ctx, user, format) {
    var link = util.format('https://%s/api/user/%s/%s/calendar.%s', ctx.app.host, user.id, user.calendarToken, format);
    return new CalendarInfo(ctx.app.host, user.displayName, '', ctx.app.displayName, link, '', user.updatedAt);
};
