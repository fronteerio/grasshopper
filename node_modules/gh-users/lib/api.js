/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var Sequelize = require('sequelize');

var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-users');
var mixpanel = require('gh-core/lib/mixpanel').mixpanel;
var MixpanelConstants = require('gh-core/lib/mixpanel').MixpanelConstants;

/**
 * Create a new user object
 *
 * @param  {Context}    ctx                                 The current execution context containing the user and application
 * @param  {String}     tenantId                            The id of the tenant on which to create the user account
 * @param  {Object}     credentials                         Specifies the authentication strategy that the users wants to use and the credentials for it
 * @param  {String}     credentials.strategy                One of `local` or `shibboleth`
 * @param  {String}     [credentials.username]              The `username` the user logs in with when the `local` strategy was chosen
 * @param  {String}     [credentials.password]              The `password` the user logs in with when the `local` strategy was chosen
 * @param  {String}     [credentials.shibbolethId]          The Shibboleth entity id for the user when the `shibboleth` strategy was chosen
 * @param  {Object}     userProfile                         The user profile parameters for the new user account
 * @param  {String}     userProfile.displayName             The display name of the new user
 * @param  {String}     userProfile.email                   The email address of the new user
 * @param  {String}     [userProfile.emailPreference]       The email preference of the new user
 * @param  {Function}   callback                            Standard callback function
 * @param  {Object}     callback.err                        An error that occurred, if any
 * @param  {User}       callback.user                       A user object
 */
var createUser = module.exports.createUser = function(ctx, tenantId, credentials, userProfile, callback) {
    userProfile = userProfile || {};
    userProfile.emailPreference = userProfile.emailPreference || 'immediate';
    // Todo: Parameter validation
    // Todo: Tenant/app validation
    
    if (!credentials || !credentials.type) {
        return callback({'code': 400, 'msg': 'Missing credentials type'});
    }

    // Ensure that the user doesn't already exist
    _getUser(ctx, tenantId, credentials, userProfile, function(err, user) {
        if (err) {
            return callback(err);
        } else if (user) {
            return callback({'code': 400, 'msg': 'The provided credentials already exist'});
        }

        _createUser(ctx, tenantId, credentials, userProfile, callback);
    });
};

/**
 * Create a new user object. This function will not perform any validation
 *
 * @see createUser
 */
var _createUser = function(ctx, tenantId, credentials, userProfile, callback) {
    var opts = {
        'TenantId': tenantId,
        'displayName': userProfile.displayName,
        'email': userProfile.email,
        'emailPreference': userProfile.emailPreference,
        'authenticationStrategy': credentials.type
    };
    if (credentials.type === 'local') {
        opts.username = credentials.username;
        // Salt and hash the password when persisting it
        opts.password = DB.User.hash(credentials.password);
    } else if (credentials.type === 'shibboleth') {
        opts.shibbolethId = credentials.shibbolethId;
    }

    // Persist the user account
    DB.User.create(opts).done(function(err, user) {
        if (err) {
            log().error({'err': err}, 'Failed to persist user');
            return callback({'code': 500, 'msg': err.message});
        }

        // Create a person that can be tracked in mixpanel
        mixpanel().people.set(user.id, {
            'name': user.displayName,
            '$created': (new Date().toISOString()),
            'authentication_type': credentials.type,
            'sign_ins': 0,
            'subscriptions': 0,
            'tenant': tenantId
        });

        // Track the user creation event
        mixpanel().track(MixpanelConstants.events.USER_CREATE, {
            'distinct_id': user.id,
            'authentication_type': credentials.type,
            'tenant': tenantId
        });

        log().debug({'user': user}, 'Created a user account');
        return callback(null, user);
    });
};

/**
 * Retrieves or creates a user object. If the user object could not
 * be found for the provided credentials and email, it will be created
 *
 * @see createUser
 */
var getOrCreateUser = module.exports.getOrCreateUser = function(ctx, tenantId, credentials, userProfile, callback) {
    _getUser(ctx, tenantId, credentials, userProfile, function(err, user) {
        if (err) {
            return callback(err);
        } else if (user) {
            return callback(null, user);
        } else {
            return createUser(ctx, tenantId, credentials, userProfile, callback);
        }
    });
};

/**
 * Retrieve a user object. This function wil not perform any validation
 *
 * @see createUser
 */
var _getUser = function(ctx, tenantId, credentials, userProfile, callback) {
    var credentialFilter = null;
    if (credentials.type === 'local') {
        // The username has to be unique within the tenant
        credentialFilter = Sequelize.and({'username': credentials.username}, {'TenantId': tenantId});
    } else if (credentials.type === 'shibboleth') {
        // The Shibboleth entity ID has to be unique within the tenant
        credentialFilter = Sequelize.and({'shibbolethId': credentials.shibbolethId}, {'TenantId': tenantId});
    }

    // The email has to be globally unique
    var emailFilter = {'email': userProfile.email};

    // If either of the filters return a user, we can't allow the user creation to proceed
    var where = Sequelize.or(credentialFilter, emailFilter);
    DB.User.find({'where': where}).done(function(err, user) {
        if (err) {
            log().error({'err': err}, 'Unable to lookup a user by username or email address');
            return callback({'code': 500, 'msg': 'Unable to lookup a user by username or email address'});
        }

        return callback(null, user);
    });
};
