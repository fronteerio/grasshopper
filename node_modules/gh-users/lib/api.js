/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var csv = require('csv');
var events = require('events');
var fs = require('fs');
var util = require('util');

var AppsAPI = require('gh-apps');
var AuthConstants = require('gh-auth/lib/constants');
var CalendarInfo = require('gh-calendar/lib/model').CalendarInfo;
var CalendarUtil = require('gh-calendar/lib/util');
var ConfigAPI = require('gh-config');
var DB = require('gh-core/lib/db');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-users');
var OrgUnitDAO = require('gh-orgunit/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var UsersAuthz = require('./authz');
var UsersDAO = require('./internal/dao');

/**
 * The `UsersAPI` will emit the following events:
 *
 * * `preImportUsers`: A request was made to import a set of users
 * * `postImportUsers`: A set of users has been imported
 */
var UsersAPI = module.exports = new events.EventEmitter();

/**
 * Initialise the users api
 *
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error object, if any
 */
var init = module.exports.init = function(callback) {
    UsersDAO.init(callback);
};

/**
 * Get a user
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current application
 * @param  {Number}         id                  The id of the user to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {User}           callback.user       The requested user
 */
var getUser = module.exports.getUser = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can get a user'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    UsersDAO.getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        } else if (user.AppId !== ctx.app.id && (!ctx.user.canAdmin(user.AppId))) {
            return callback({'code': 401, 'msg': 'This user cannot be retrieved on this application'});
        }

        // Hide the user's personal information
        user.hidePersonalInformation(ctx);

        return callback(null, user);
    });
};

/**
 * Get a set of users in an application
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current application
 * @param  {Number}         [app]               The id of the app to get the users for
 * @param  {String}         [query]             The string to query users by
 * @param  {Number}         [limit]             The maximum number of results to retrieve. Defaults to 10
 * @param  {Number}         [offset]            The number to start paging from. Defaults to 0
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {User[]}         callback.users      The (filtered) users in the application
 */
var getUsers = module.exports.getUsers = function(ctx, app, query, limit, offset, callback) {
    // Default some parameters
    app = GrasshopperUtil.getNumberParam(app);
    limit = GrasshopperUtil.getNumberParam(limit, 10, 1, 25);
    offset = GrasshopperUtil.getNumberParam(offset, 0, 0);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can search/page users'}).isLoggedInUser(ctx);
    validator.check(app, {'code': 400, 'msg': 'A valid app id must be provided'}).isInt();
    validator.check(limit, {'code': 400, 'msg': 'A valid limit must be provided'}).isInt();
    validator.check(offset, {'code': 400, 'msg': 'A valid offset must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user is allowed to search/page users in the given application
    if (app !== ctx.app.id && !ctx.user.canAdmin(app)) {
        log().warn('Unauthorized attempt at searching/paging users in an application');
        return callback({'code': 401, 'msg': 'You are not allowed to search/page users in this application'});
    }

    /*!
     * Hide personal information from a set of users
     *
     * @param  {Object}     err         An error object, if any
     * @param  {User[]}     users       The users whose personal information to hide
     * @api private
     */
    var done = function(err, users) {
        if (err) {
            return callback(err);
        }

        hideUsersPersonalInformation(ctx, users);

        return callback(null, users);
    };

    // If a query was specified, search for users
    if (query) {
        UsersDAO.searchUsers(app, query, limit, offset, done);

    // Otherwise we page through the users
    } else {
        UsersDAO.getUsers(app, limit, offset, done);
    }
};

/**
 * Hide the personal information of a set of users
 *
 * @param  {Context}        ctx                 Standard context object containing the current user and the current application
 * @param  {User[]}         users               The users whose personal information to hide. The modifications will be made inline
 */
var hideUsersPersonalInformation = module.exports.hideUsersPersonalInformation = function(ctx, users) {
    _.each(users, function(user) {
        user.hidePersonalInformation(ctx);
    });
};

/**
 * Create a new user
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current app
 * @param  {Number}         appId                           The id of the app on which the user should be created
 * @param  {Object}         userProfile                     The user profile parameters for the user
 * @param  {String}         userProfile.displayName         The name of the user
 * @param  {String}         userProfile.email               The email address for the user
 * @param  {String}         userProfile.emailPreference     The email preference for the user. One of `immediate` or `no`
 * @param  {String}         userProfile.isAdmin             Whether the user is an app administrator. Only allowed when the current user is an administrator
 * @param  {Object}         credentials                     The authentication credentials for the user
 * @param  {String}         credentials.strategy            The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         [credentials.password]          The password with which the user will authenticate. Only required when using the local authentiation strategy
 * @param  {String}         [credentials.shibbolethId]      The unique shibboleth id for the user. Only required when using the Shibboleth authentication strategy
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User}           callback.user                   The created user
 */
var createUser = module.exports.createUser = function(ctx, appId, userProfile, credentials, callback) {
    userProfile = userProfile || {};
    credentials = credentials || {};
    userProfile.emailPreference = userProfile.emailPreference || 'immediate';
    userProfile.isAdmin = GrasshopperUtil.getBooleanParam(userProfile.isAdmin, false);

    // Ensure that the application id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    var validator = new Validator();
    validator.check(appId, {'code': 400, 'msg': 'A valid app id must be provided'}).isInt();
    validator.check(userProfile.displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).notEmpty();
    validator.check(userProfile.displayName, {'code': 400, 'msg': 'A displayName can be at most 255 characters long'}).isShortString();
    validator.check(userProfile.emailPreference, {'code': 400, 'msg': 'A valid email preference must be provided'}).isIn(['immediate', 'no']);
    validator.check(credentials.strategy, {'code': 400, 'msg': 'A valid strategy must be provided'}).isIn([AuthConstants.strategies.LOCAL, AuthConstants.strategies.SHIBBOLETH]);

    if (credentials.strategy === AuthConstants.strategies.LOCAL) {
        validator.check(userProfile.email, {'code': 400, 'msg': 'A valid email address must be provided'}).isEmail();
        validator.check(credentials.password, {'code': 400, 'msg': 'A valid password must be provided'}).notEmpty();
        validator.check(credentials.password, {'code': 400, 'msg': 'A valid password that is 6 characters or longer must be provided'}).len(6);
    } else if (credentials.strategy === AuthConstants.strategies.SHIBBOLETH) {
        validator.check(credentials.shibbolethId, {'code': 400, 'msg': 'A valid shibboleth identifier must be provided'}).notEmpty();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    var isAdminApp = (ctx.user && ctx.user.canAdmin(appId));
    if (userProfile.isAdmin && !isAdminApp) {
        return callback({'code': 401, 'msg': 'Only administrators can create other administrators'});
    }

    // Verify that the provided app exists
    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        // Verify that the application allows new user accounts to be created
        var allowLocalAccountCreation = ConfigAPI.config(appId).allowLocalAccountCreation;
        if (credentials.strategy === AuthConstants.strategies.LOCAL && !isAdminApp && !allowLocalAccountCreation) {
            return callback({'code': 401, 'msg': 'Local user accounts can not be created on this application'});
        }

        // Verify the user accepted the Terms and Conditions if there are any
        var termsAndConditions = AppsAPI.getTermsAndConditionsForApp(app);
        if (!isAdminApp && termsAndConditions.enabled && !userProfile.termsAndConditions) {
            return callback({'code': 400, 'msg': 'The Terms and Conditions need to be accepted'});
        }

        // Ensure that a user with the provided credentials doesn't already exist
        UsersDAO.getUserByCredentials(appId, credentials.strategy, (credentials.shibbolethId || userProfile.email), function(err, user) {
            if (user) {
                log().error({'err': err, 'credentials': (credentials.shibbolethId || userProfile.email)}, 'Failed to create a new user');
                return callback({'code': 400, 'msg': 'A user with the provided authentication credentials already exists'});
            } else if (err && err.code !== 404) {
                return callback(err);
            }

            return UsersDAO.createUser(appId, userProfile, credentials, callback);
        });
    });
};

/**
 * Update a user
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current app
 * @param  {Number}         userId                          The id of the user that should be updated
 * @param  {Object}         update                          The updates to make
 * @param  {String}         [update.displayName]            The updated displayName
 * @param  {String}         [update.email]                  The updated email
 * @param  {String}         [update.emailPreference]        The updated email preference
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User}           callback.user                   The updated user
 */
var updateUser = module.exports.updateUser = function(ctx, userId, update, callback) {
    userId = GrasshopperUtil.getNumberParam(userId);
    update = update || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can update a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'The profile updates must be provided as an object'}).isObject(update);
    validator.check(_.keys(update), {'code': 400, 'msg': 'At least 1 profile update must be provided'}).len(1);
    var validUpdates = ['displayName', 'email', 'emailPreference'];
    _.each(update, function(val, key) {
        validator.check(key, {'code': 400, 'msg': 'A profile field must be one of: ' + validUpdates.join(', ')}).isIn(validUpdates);
        validator.check(val, {'code': 400, 'msg': 'A value must be provided for: ' + key}).notEmpty();
    });
    if (update.displayName) {
        validator.check(update.displayName, {'code': 400, 'msg': 'A displayName can be at most 255 characters long'}).isShortString();
    }
    if (update.email) {
        validator.check(update.email, {'code': 400, 'msg': 'A valid email address must be provided'}).isEmail();
    }
    if (update.emailPreference) {
        validator.check(update.emailPreference, {'code': 400, 'msg': 'A valid email preference must be provided'}).isIn(['immediate', 'no']);
    }

    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    UsersDAO.getUser(userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can update the user
        UsersAuthz.canUpdateUser(ctx, user, function(err, canUpdate) {
            if (err) {
                return callback(err);
            } else if (!canUpdate) {
                log().warn({'id': userId, 'actor': ctx.user.id}, 'Unauthorized attempt at updating a user');
                return callback({'code': 401, 'msg': 'You are not allowed to update this user'});
            }

            UsersDAO.updateUser(user, update, callback);
        });
    });
};

/**
 * Update the app administrator status for a user
 *
 * @param  {Context}        ctx                             Standard context object containing the current user and the current application
 * @param  {Number}         userId                          The id of the user to update the app administrator status for
 * @param  {Boolean}        admin                           Whether the user should be an app administrator
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User}           callback.user                   The updated user
 */
var updateAdminStatus = module.exports.updateAdminStatus = function(ctx, userId, admin, callback) {
    userId = GrasshopperUtil.getNumberParam(userId);
    admin = GrasshopperUtil.getBooleanParam(admin);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can update a user'}).isLoggedInUser(ctx);
    validator.check(userId, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'A valid boolean flag must be provided'}).isBoolean(admin);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    UsersDAO.getUser(userId, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can update the user
        UsersAuthz.canUpdateAdminStatus(ctx, user, function(err, canUpdate) {
            if (err) {
                return callback(err);
            } else if (!canUpdate) {
                log().warn({'id': userId, 'actor': ctx.user.id}, 'Unauthorized attempt at updating the admin status of a user');
                return callback({'code': 401, 'msg': 'You are not allowed to update the admin status of this user'});
            }

            UsersDAO.updateUser(user, {'isAdmin': admin}, callback);
        });
    });
};

/**
 * Import users using a CSV file.
 *
 * The CSV file should be formatted in the following way:
 *
 *  `displayName, email, shibbolethId`
 *
 * When importing a set of users using the local authentication strategy, the CSV format should be the following:
 *
 *  `displayName, email, password`
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current app
 * @param  {File}           file                            The CSV file to import
 * @param  {Number}         appId                           The id of the application into which the users should be imported
 * @param  {String}         authenticationStrategy          The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {Boolean}        [forceProfileUpdate]            Whether the user information should be updated, even when other user information is already present. Defaults to `false`
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 */
var importUsers = module.exports.importUsers = function(ctx, file, appId, authenticationStrategy, forceProfileUpdate, callback) {
    forceProfileUpdate = forceProfileUpdate || false;
    forceProfileUpdate = GrasshopperUtil.getBooleanParam(forceProfileUpdate);
    appId = GrasshopperUtil.getNumberParam(appId);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can import users'}).isLoggedInUser(ctx);
    validator.check(authenticationStrategy, {'code': 400, 'msg': 'A valid authentication strategy must be provided'}).isIn([AuthConstants.strategies.LOCAL, AuthConstants.strategies.SHIBBOLETH]);
    validator.check(null, {'code': 400, 'msg': 'A valid CSV file must be provided'}).isObject(file);
    if (file) {
        validator.check(file.file, {'code': 400, 'msg': 'Missing path to the CSV file'}).notEmpty();
    }
    validator.check(appId, {'code': 400, 'msg': 'A valid application id must be provided'}).isInt();
    validator.check(null, {'code': 400, 'msg': 'A valid profile update flag must be provided'}).isBoolean(forceProfileUpdate);
    if (validator.hasErrors()) {
        _cleanUpCSVFile(file, function() {
            return callback(validator.getFirstError());
        });
        return;
    }

    // Ensure the application exists
    AppsAPI.getApp(ctx, appId, function(err, app) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can import users
        UsersAuthz.canImportUsers(ctx, app, function(err, canImportUsers) {
            if (err) {
                return callback(err);
            } else if (!canImportUsers) {
                log().warn({'appId': appId, 'actor': ctx.user.id}, 'Unauthorized attempt at importing users');
                return callback({'code': 401, 'msg': 'You are not allowed to import users'});
            }

            // Construct the CSV parser
            var parser = csv.parse({'trim': true}, function(err, userRows) {
                // Regardless of the error, get rid of the CSV file first
                _cleanUpCSVFile(file, function() {
                    if (err) {
                        log().error({'err': err, 'appId': appId}, 'Failed to parse CSV file when importing users');
                        return callback({'code': 400, 'msg': 'Failed to parse the provided CSV file'});
                    }

                    // Validate each record before attempting to create users. Although this makes
                    // the request a bit slower, it prevents us from ending up with only half of the
                    // CSV file's users
                    _.each(userRows, function(userRow) {
                        validator.check(userRow[0], {'code': 400, 'msg': util.format('Missing display name for: %s', userRow[1])}).notEmpty();
                        if (authenticationStrategy === AuthConstants.strategies.LOCAL) {
                            validator.check(userRow[1], {'code': 400, 'msg': util.format('A valid email address must be provided for: %s', userRow[0])}).isEmail();
                            validator.check(userRow[2], {'code': 400, 'msg': util.format('A valid password must be provided for: %s', userRow[0])}).notEmpty();
                            validator.check(userRow[2], {'code': 400, 'msg': util.format('A valid password must be provided for: %s', userRow[0])}).len(6);
                        } else {
                            validator.check(userRow[2], {'code': 400, 'msg': util.format('A valid shibboleth id must be provided for: %s', userRow[0])}).notEmpty();
                        }
                    });

                    if (validator.hasErrors()) {
                        return callback(validator.getFirstError());
                    }

                    // Indicate the request is valid and we will start actually importing users
                    UsersAPI.emit('preImportUsers');

                    // If the CSV parse was successful, we call the callback to prevent the request from timing out
                    // whilst the users are being loaded
                    callback();

                    // Import the users
                    log().info({
                        'appId': appId,
                        'authenticationStrategy': authenticationStrategy
                    }, 'Starting user import from CSV');
                    _importUsers(appId, authenticationStrategy, forceProfileUpdate, userRows, function(err) {
                        if (!err) {
                            log().info({
                                'appId': appId,
                                'authenticationStrategy': authenticationStrategy
                            }, 'All users have been imported');
                        }

                        // Indicate that all the users from the CSV file have been processed
                        UsersAPI.emit('postImportUsers', err);
                    });
                });
            });

            // The CSV module works with streams, so get a readable stream to the uploaded CSV file
            // and pipe it to the CSV parser
            fs.createReadStream(file.file).pipe(parser);
        });
    });
};

/**
 * Remove an uploaded user CSV file
 *
 * @param  {Object}         userCSV                 File object representing the uploaded CSV file as returned by express
 * @param  {Function}       callback                Standard callback function
 * @api private
 */
var _cleanUpCSVFile = function(userCSV, callback) {
    if (userCSV && userCSV.file) {
        fs.exists(userCSV.file, function(exists) {
            if (exists) {
                fs.unlink(userCSV.file, function(err) {
                    if (err) {
                        log().warn({'err': err, 'file': userCSV}, 'Could not remove the user import CSV file');
                    }
                    return callback();
                });
            } else {
                return callback();
            }
        });
    } else {
        return callback();
    }
};

/**
 * Import a set of users
 *
 * @param  {Number}     appId                       The id of the application to import the users into
 * @param  {String}     authenticationStrategy      The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {Boolean}    [forceProfileUpdate]        Whether the user information should be updated, even when other user information is already present
 * @param  {String[][]} userRows                    The users records to import. Each item in the array represents a single user through a fixed length array of strings
 * @param  {String}     userRows.[0][0]              The displayName of the user
 * @param  {String}     userRows.[0][1]              The email address of the user
 * @param  {String}     userRows.[0][2]              The password for the user in case the `local` authentication strategy is used, the shibboleth identifier in case the `shibboleth` strategy is used
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @api private
 */
var _importUsers = function(appId, authenticationStrategy, forceProfileUpdate, userRows, callback) {
    if (_.isEmpty(userRows)) {
        return callback();

    // Add a progress log statement every 50 imported users
    } else if (userRows.length % 50 === 0) {
        log().info({
            'authenticationStrategy': authenticationStrategy,
            'appId': appId
        }, 'Importing users from CSV. ' + userRows.length + ' users left to import');
    }

    // Import the next user
    var userRow = userRows.pop();
    _importUser(appId, authenticationStrategy, forceProfileUpdate, userRow, function(err) {
        // Swallow the error so that 1 bad user account doesn't prevent the others
        // from being created. The error will have been logged already

        // Recursively import the next user (if any)
        _importUsers(appId, authenticationStrategy, forceProfileUpdate, userRows, callback);
    });
};

/**
 * Import a user
 *
 * @param  {Number}     appId                       The id of the application to import the user into
 * @param  {String}     authenticationStrategy      The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {Boolean}    [forceProfileUpdate]        Whether the user information should be updated, even when other user information is already present
 * @param  {String[]}   userRow                     The user row to import
 * @param  {String}     userRow.[0]                 The displayName of the user
 * @param  {String}     userRow.[1]                 The email address of the user
 * @param  {String}     userRow.[2]                 The password for the user in case the `local` authentication strategy is used, the shibboleth identifier in case the `shibboleth` strategy is used
 * @param  {Function}   callback                    Standard callback function
 * @param  {Object}     callback.err                An error object, if any
 * @api private
 */
var _importUser = function(appId, authenticationStrategy, forceProfileUpdate, userRow, callback) {
    var userProfile = {
        'displayName': userRow[0],
        'emailPreference': 'immediate'
    };

    // Shibboleth users don't require an email address. The CSV file returns the empty which would
    // trigger a constraint violation if we just passed it on. To avoid that, we only set the email
    // address if one was actually provided
    if (userRow[1]) {
        userProfile.email = userRow[1];
    }

    var credentials = {
        'strategy': authenticationStrategy
    };
    var identifier = null;
    if (authenticationStrategy === AuthConstants.strategies.LOCAL) {
        identifier = userRow[1];
        credentials.password = userRow[2];
    } else if (authenticationStrategy === AuthConstants.strategies.SHIBBOLETH) {
        credentials.shibbolethId = userRow[2];
        identifier = userRow[2];
    }

    UsersDAO.getUserByCredentials(appId, authenticationStrategy, identifier, function(err, persistedUser) {
        if (err && err.code !== 404) {
            return callback(err);

        // If we get a 404, it means the user doesn't exist yet and we can safely create it
        } else if (err && err.code === 404) {
            return UsersDAO.createUser(appId, userProfile, credentials, callback);

        // Otherwise the user exists
        } else {
            // If we don't force updates or there's nothing to update, we can move on to the next user
            if (!forceProfileUpdate || (persistedUser.displayName === userRow[0] && persistedUser.email === userRow[1])) {
                return callback();
            }

            // Otherwise we have to update the user
            var update = {
                'displayName': userProfile.displayName,
                'email': userProfile.email
            };
            return UsersDAO.updateUser(persistedUser, update, callback);
        }
    });
};

/* Calendar */

/**
 * Get the calendar for a user
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current app
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     start               The timestamp (ISO 8601) from which to get the calendar for the user
 * @param  {String}     end                 The timestamp (ISO 8601) until which to get the calendar for the user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Event[]}    callback.events     The events in a user's calendar
 */
var getUserCalendar = module.exports.getUserCalendar = function(ctx, id, start, end, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can retrieve a user\'s calendar'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(start, {'code': 400, 'msg': 'A start time must be provided in a valid date format'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'An end time must be provided in a valid date format'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the user's calendar
    _getUserCalendar(ctx, id, true, null, start, end, function(err, user, events) {
        if (err) {
            return callback(err);
        }

        return callback(null, events);
    });
};

/**
 * Get the calendar for a user in iCal
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current app
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     token               The access control token
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {String}     callback.ical       The requested event series calendar in iCal format
 */
var getUserCalendarIcal = module.exports.getUserCalendarIcal = function(ctx, id, token, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(token, {'code': 400, 'msg': 'A valid access control token must be provided'}).len(32, 32);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the user's calendar
    _getUserCalendar(ctx, id, false, token, null, null, function(err, user, events) {
        if (err) {
            return callback(err);
        }

        // Return the events as iCal
        var calendarInfo = _getCalendarInfo(ctx, user, 'ical');
        var ical = CalendarUtil.eventsToICal(calendarInfo, events);
        return callback(null, ical);
    });
};

/**
 * Get the calendar for a user in RSS
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current app
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {String}     token               The access control token
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {String}     callback.rss        The requested event series calendar in RSS format
 */
var getUserCalendarRSS = module.exports.getUserCalendarRSS = function(ctx, id, token, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    validator.check(token, {'code': 400, 'msg': 'A valid access control token must be provided'}).len(32, 32);
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Get the user's calendar
    _getUserCalendar(ctx, id, false, token, null, null, function(err, user, events) {
        if (err) {
            return callback(err);
        }

        // Return the events as RSS
        var calendarInfo = _getCalendarInfo(ctx, user, 'rss');
        var rss = CalendarUtil.eventsToRSS(calendarInfo, events);
        return callback(null, rss);
    });
};

/**
 * Get the calendar for a user
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current app
 * @param  {Number}     id                  The id of the user to get the calendar for
 * @param  {Boolean}    [includeContext]    Whether or not the organisational units that were provided as context during subscription should be included
 * @param  {String}     [token]             The access control token
 * @param  {String}     [start]             The timestamp (ISO 8601) from which to get the calendar for the user
 * @param  {String}     [end]               The timestamp (ISO 8601) until which to get the calendar for the user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {User}       callback.user       The user who owns the calendar
 * @param  {Event[]}    callback.events     The events in a user's calendar
 * @api private
 */
var _getUserCalendar = function(ctx, id, includeContext, token, start, end, callback) {
    // Ensure the user exists
    UsersDAO.getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can get the calendar
        UsersAuthz.canGetUserCalendar(ctx, user, token, function(err, canGetCalendar) {
            if (err) {
                return callback(err);
            } else if (!canGetCalendar) {
                log().warn({'id': id}, 'Unauthorized attempt at retrieving a user\'s calendar');
                return callback({'code': 401, 'msg': 'You are not allowed to retrieve this user\'s calendar'});
            }

            // Get the events in the user calendar
            UsersDAO.getUserCalendar(user, includeContext, start, end, function(err, events) {
                if (err) {
                    return callback(err);
                }

                return callback(null, user, events);
            });
        });
    });
};

/**
 * Reset a user's calendar token
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current app
 * @param  {Number}     id                  The id of the user to reset the calendar token for
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {User}       callback.user       The full user object
 */
var resetUserCalendarToken = module.exports.resetUserCalendarToken = function(ctx, id, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can reset a user\'s calendar token'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    UsersDAO.getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can reset the user's token
        UsersAuthz.canResetUserToken(ctx, user, function(err, canResetToken) {
            if (err) {
                return callback(err);
            } else if (!canResetToken) {
                log().warn({'id': id, 'actor': ctx.user.id}, 'Unauthorized attempt at resetting a user\'s calendar token');
                return callback({'code': 401, 'msg': 'You are not allowed to reset this user\'s calendar token'});
            }

            // Generate a new token and persist it
            var token = UsersDAO.generateCalendarToken();
            var update = {
                'calendarToken': token
            };
            return UsersDAO.updateUser(user, update, callback);
        });
    });
};

/**
 * Get the calendar info for a user
 *
 * @param  {Context}    ctx         Standard context containing the current user and the current app
 * @param  {User}       user        The user for which to get the calendar info
 * @param  {String}     format      The format in which the calendar will be returned. One of `ical` or `rss`
 * @return {CalendarInfo}           An object representing the calendar info for the user
 * @api private
 */
var _getCalendarInfo = function(ctx, user, format) {
    var link = util.format('https://%s/api/user/%s/%s/calendar.%s', ctx.app.host, user.id, user.calendarToken, format);
    return new CalendarInfo(ctx.app, user.displayName, '', ctx.app.displayName, link, '', user.updatedAt);
};

/* Terms and conditions */

/**
 * Get status of the Terms and Conditions for a user
 *
 * @param  {Context}    ctx         Standard context containing the current user and the current app
 * @return {Oject}                  The status of the Terms and Conditions for the user
 */
var getTermsAndConditionsStatus = module.exports.getTermsAndConditionsStatus = function(ctx) {
    return {
        'accepted': (ctx.user) ? ctx.user.termsAndConditions : null,
        'needsToAccept': needsToAcceptTermsAndConditions(ctx)
    };
};

/**
 * Check if a user needs to accept or re-accept the Terms and Conditions
 *
 * @param  {Context}    ctx         Standard context containing the current user and the current app
 * @return {Boolean}                Whether or not the current user needs to accept or re-accept the Terms and Conditions
 */
var needsToAcceptTermsAndConditions = module.exports.needsToAcceptTermsAndConditions = function(ctx) {
    // Anonymous users don't need to accept the Terms and Conditions
    if (!ctx.user) {
        return false;
    }

    var termsAndConditions = AppsAPI.getTermsAndConditionsForApp(ctx.app);

    // If the Terms and Conditions have not been enabled, the user can't accept anything
    if (!termsAndConditions.enabled) {
        return false;

    // Administrators don't need to accept anything
    } else if (ctx.user.canAdmin(ctx.app.id)) {
        return false;
    }

    // This application has Terms and Conditions. We need to check the user has accepted
    // the Terms and Conditions since the last time they were updated
    return (!ctx.user.termsAndConditions || ctx.user.termsAndConditions < termsAndConditions.lastUpdate);
};

/**
 * Accept the Terms and Conditions
 *
 * @param  {Context}    ctx                 Standard context containing the current user and the current app
 * @param  {Number}     id                  The id of the user for which to accept the Terms and Conditions
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Object}     callback.status     The updated status of the Terms and Conditions for the user
 */
var acceptTermsAndConditions = module.exports.acceptTermsAndConditions = function(ctx, id, callback) {
    // Ensure that the user id is a valid number
    id = GrasshopperUtil.getNumberParam(id);

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can accept the terms and conditions'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the user exists
    UsersDAO.getUser(id, function(err, user) {
        if (err) {
            return callback(err);
        }

        // Ensure the current user can accept the terms and conditions for the user
        UsersAuthz.canAcceptTermsAndConditions(ctx, user, function(err, canAcceptTermsAndConditions) {
            if (err) {
                return callback(err);
            } else if (!canAcceptTermsAndConditions) {
                log().warn({'id': id, 'actor': ctx.user.id}, 'Unauthorized attempt at accepting the terms and conditions for a user');
                return callback({'code': 401, 'msg': 'You are not allowed to accept the terms and conditions for a user'});
            }

            UsersDAO.updateUser(user, {'termsAndConditions': Date.now()}, function(err) {
                if (err) {
                    return callback(err);
                }
                ctx.user = user;
                return callback(null, getTermsAndConditionsStatus(ctx));
            });
        });
    });
};
