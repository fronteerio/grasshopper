/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var AuthUtil = require('gh-auth/lib/util');
var DB = require('gh-core/lib/db');
var log = require('gh-core/lib/logger').logger('gh-users');

/**
 * Create three indexes: one for displayNames, emails and shibboleth identifiers.
 * This allows for doing similarity queries on those properties. It's assumed that
 * the trigram extension has been enabled in PostgreSQL
 *
 * @param  {Function}       callback        Standard callback function
 * @param  {Object}         callback.err    An error object, if any
 * @see http://www.postgresql.org/docs/9.1/static/pgtrgm.html
 */
var init = module.exports.init = function(callback) {
    var sequelize = DB.getSequelize();
    sequelize.query('CREATE INDEX users_trgm_displayname_idx ON "Users" USING gin ("displayName" gin_trgm_ops);').complete(function(err) {
        if (err && err.message.indexOf('already exists') === -1) {
            return callback({'code': 500, 'msg': err.message});
        }
        sequelize.query('CREATE INDEX users_trgm_email_idx ON "Users" USING gin ("email" gin_trgm_ops);').complete(function(err) {
            if (err && err.message.indexOf('already exists') === -1) {
                return callback({'code': 500, 'msg': err.message});
            }
            sequelize.query('CREATE INDEX users_trgm_shibbolethid_idx ON "Users" USING gin ("shibbolethId" gin_trgm_ops);').complete(function(err) {
                if (err && err.message.indexOf('already exists') === -1) {
                    return callback({'code': 500, 'msg': err.message});
                }

                return callback();
            });
        });
    });
};

/**
 * Update a user
 *
 * @param  {User}           user                        The user to update
 * @param  {object}         update                      The updates to persist
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {User}           callback.user               The updated user
 */
var updateUser = module.exports.updateUser = function(user, update, callback) {
    user.updateAttributes(update).complete(function(err, user) {
        if (err && err.name === 'SequelizeUniqueConstraintError' && err.errors && err.errors[0] && err.errors[0].message === 'email must be unique') {
            log().error({'err': err}, 'Failed to update a user');
            return callback({'code': 400, 'msg': 'A unique email address must be provided'});
        } else if (err) {
            log().error({'err': err}, 'Failed to update a user');
            return callback({'code': 500, 'msg': err.message});
        }

        return callback(null, user);
    });
};

/**
 * Get a user
 *
 * @param  {Number}         id                              The id of the user to retrieve
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The requested user
 */
var getUser = module.exports.getUser = function(id, callback) {
    DB.User.find(id).complete(function(err, user) {
        if (err) {
            log().error({'err': err, 'id': id}, 'Failed to get a user');
            return callback({'code': 500, 'msg': err.message});
        } else if (!user) {
            log().debug({'err': err, 'id': id}, 'A user with the specified id could not be found');
            return callback({'code': 404, 'msg': 'A user with the specified id could not be found'});
        }

        return callback(null, user);
    });
};

/**
 * Get a set of users
 *
 * @param  {Number}         app                 The id of the app to get the users for
 * @param  {Number}         [limit]             The maximum number of results to retrieve. Defaults to 10
 * @param  {Number}         [offset]            The number to start paging from. Defaults to 0
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {User[]}         callback.users      The requested users
 */
var getUsers = module.exports.getUsers = function(app, limit, offset, callback) {
    limit = limit || 10;
    offset = offset || 0;

    var options = {
        'where': {'AppId': app},
        'limit': limit,
        'offset': offset
    };
    DB.User.findAll(options).complete(function(err, users) {
        if (err) {
            log().error({'err': err, 'app': app}, 'Failed to page users');
            return callback({'code': 500, 'msg': err.message});
        }

        return callback(null, users);
    });
};

/**
 * Search for users in an application
 *
 * @param  {Number}         appId               The id if the app to search the users in
 * @param  {String}         query               The string to query users by
 * @param  {Number}         [limit]             The maximum number of results to retrieve. Defaults to 10
 * @param  {Number}         [offset]            The number to start paging from. Defaults to 0
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {User[]}         callback.users      The matching users
 */
var searchUsers = module.exports.searchUsers = function(appId, query, limit, offset, callback) {
    limit = limit || 10;
    offset = offset || 0;

    var sequelize = DB.getSequelize();

    // Construct a query that selects a set of rows in the Users table ordered
    // on the sum of the displayName, email and shibbolethId similarities. Although
    // this isn't perfect, it gives a reasonable approximation of a typeahead search as
    // each of the three columns their values are split up in possible trigrams and indexed.
    // We need to coalesce the `email` and `shibbolethId` columns as you can't get a similarity
    // value from a null value. Because of the index on each column, the query itself is
    // reasonably quick and accurate
    var sqlQuery = 'SELECT "Users".* ';
    sqlQuery += 'FROM "Users" ';
    sqlQuery += 'WHERE "AppId" = ? ';
    sqlQuery += 'ORDER BY (similarity("displayName", ?) + similarity(coalesce("email", ?), ?) + similarity(coalesce("shibbolethId", ?), ?)) DESC, "displayName" ASC, "id" ASC ';
    sqlQuery += 'LIMIT ? OFFSET ?' ;
    var coalescedValue = '';
    var options = {
        'replacements': [appId, query, coalescedValue, query, coalescedValue, query, limit, offset],
        'type': 'SELECT'
    };
    sequelize.query(sqlQuery, DB.User, options).complete(function(err, users) {
        if (err) {
            log().error({'err': err, 'filter': query}, 'Unable to search on users');
            return callback({'code': 500, 'msg': 'Unable to search on users'});
        }

        return callback(null, users);
    });
};

/**
 * Get multiple users via their user id
 *
 * @param  {Number}         appId                           The id of the app to which the requested users belong
 * @param  {Number[]}       ids                             The ids of the users to retrieve
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User[]}         callback.users                  The requested users
 */
var getUsersById = module.exports.getUsersById = function(appId, ids, callback) {
    if (_.isEmpty(ids)) {
        return callback(null, []);
    }

    DB.User.findAll({'where': {'id': ids, 'AppId': appId}}).complete(function(err, users) {
        if (err) {
            log().error({'err': err, 'appId': appId, 'ids': ids}, 'Failed to get multiple users');
            return callback({'code': 500, 'msg': err.message});
        } else if (users.length !== ids.length) {
            log().error({'appId': appId, 'ids': ids}, 'Failed to get one or multiple users on the specified app');
            return callback({'code': 400, 'msg': 'Failed to get one or multiple users on the specified app'});
        }

        return callback(null, users);
    });
};

/**
 * Get a user by its authentication credentials
 *
 * @param  {Number}         appId                           The id of the app to which the user belongs
 * @param  {String}         strategy                        The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         identifier                      The unique credentials identifier for the user. `email` when using local authentication or `shibbolethId` when using Shibboleth authentication
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The requested user
 */
var getUserByCredentials = module.exports.getUserByCredentials = function(appId, strategy, identifier, callback) {
    var where = {'AppId': appId};
    if (strategy === 'local') {
        where['email'] = identifier;
    } else {
        where['shibbolethId'] = identifier;
    }

    DB.User.find({'where': where}).complete(function(err, user) {
        if (err) {
            log().error({'err': err, 'appId': appId, 'strategy': strategy, 'identifier': identifier}, 'Failed to get a user by its authentication credentials');
            return callback({'code': 500, 'msg': err.message});
        } else if (!user) {
            log().debug({'err': err, 'appId': appId, 'strategy': strategy, 'identifier': identifier}, 'A user with the specified authentication credentials could not be found');
            return callback({'code': 404, 'msg': 'A user with the specified authentication credentials could not be found'});
        }

        return callback(null, user);
    });
};

/**
 * Create a new user
 *
 * @param  {Number}         appId                           The id of the app on which the user should be created
 * @param  {Object}         userProfile                     The user profile parameters for the user
 * @param  {String}         userProfile.displayName         The name of the user
 * @param  {String}         userProfile.email               The email address for the user
 * @param  {String}         userProfile.emailPreference     The email preference for the user. One of `immediate` or `no`
 * @param  {String}         userProfile.calendarToken       The calendar token for the user
 * @param  {String}         userProfile.isAdmin             Whether the user is an app administrator
 * @param  {Object}         credentials                     The authentication credentials for the user
 * @param  {String}         credentials.strategy            The authentication strategy for the user. One of `local` or `shibboleth`
 * @param  {String}         [credentials.password]          The password with which the user will authenticate. Only required when using the local authentiation strategy
 * @param  {String}         [credentials.shibbolethId]      The unique shibboleth id for the user. Only required when using the Shibboleth authentication strategy
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The created user
 */
var createUser = module.exports.createUser = function(appId, userProfile, credentials, callback) {
    if (!userProfile.calendarToken) {
        userProfile.calendarToken = generateCalendarToken();
    }

    if (credentials.strategy === 'local') {
        createLocalUser(appId, userProfile, credentials, callback);
    } else if (credentials.strategy === 'shibboleth') {
        createShibbolethUser(appId, userProfile, credentials, callback);
    }
};

/**
 * Create a new user with a local authentication strategy
 *
 * @param  {Number}         appId                           The id of the app on which the user should be created
 * @param  {Object}         userProfile                     The user profile parameters for the user
 * @param  {String}         userProfile.displayName         The name of the user
 * @param  {String}         userProfile.email               The email address for the user
 * @param  {String}         userProfile.emailPreference     The email preference for the user. One of `immediate` or `no`
 * @param  {String}         userProfile.calendarToken       The calendar token for the user
 * @param  {String}         userProfile.isAdmin             Whether the user is an app administrator
 * @param  {Object}         credentials                     The authentication credentials for the user
 * @param  {String}         credentials.strategy            The authentication strategy for the user. `local` for a user with local authentication
 * @param  {String}         credentials.password            The password with which the user will authenticate
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The created user
 * @api private
 */
var createLocalUser = function(appId, userProfile, credentials, callback) {
    // Hash the provided password
    var hashedPassword = AuthUtil.hashPassword(credentials.password);

    // Persist the user
    var localUser = {
        'AppId': appId,
        'displayName': userProfile.displayName,
        'email': userProfile.email,
        'emailPreference': userProfile.emailPreference,
        'isAdmin': userProfile.isAdmin,
        'authenticationStrategy': credentials.strategy,
        'password': hashedPassword,
        'calendarToken': userProfile.calendarToken
    };
    DB.User.create(localUser).complete(function(err, localUser) {
        if (err) {
            log().error({'err': err}, 'Failed to create a new user with a local authentication strategy');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'localUser': localUser}, 'Created a new user with a local authentication strategy');
        return callback(null, localUser);
    });
};

/**
 * Create a new user with a Shibboleth authentication strategy
 *
 * @param  {Number}         appId                           The id of the app on which the user should be created
 * @param  {Object}         userProfile                     The user profile parameters for the user
 * @param  {String}         userProfile.displayName         The name of the user
 * @param  {String}         userProfile.email               The email address for the user
 * @param  {String}         userProfile.emailPreference     The email preference for the user. One of `immediate` or `no`
 * @param  {String}         userProfile.calendarToken       The calendar token for the user
 * @param  {String}         userProfile.isAdmin             Whether the user is an app administrator
 * @param  {Object}         credentials                     The authentication credentials for the user
 * @param  {String}         credentials.strategy            The authentication strategy for the user. `shibboleth` for a user with Shibboleth authentication
 * @param  {String}         credentials.shibbolethId        The unique shibboleth id for the user
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {User}           callback.user                   The created user
 * @api private
 */
var createShibbolethUser = function(appId, userProfile, credentials, callback) {
    var shibbolethUser = {
        'AppId': appId,
        'displayName': userProfile.displayName,
        'email': userProfile.email,
        'emailPreference': userProfile.emailPreference,
        'isAdmin': userProfile.isAdmin,
        'authenticationStrategy': credentials.strategy,
        'shibbolethId': credentials.shibbolethId,
        'calendarToken': userProfile.calendarToken
    };

    DB.User.create(shibbolethUser).complete(function(err, shibbolethUser) {
        if (err) {
            log().error({'err': err}, 'Failed to create a new user with a Shibboleth authentication strategy');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'shibbolethUser': shibbolethUser}, 'Created a new user with a Shibboleth authentication strategy');
        return callback(null, shibbolethUser);
    });
};

/**
 * Generate a calendar token
 *
 * @return {String} A randomized string that can be used as a calendar token
 */
var generateCalendarToken = module.exports.generateCalendarToken = function() {
    return _.sample('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 32).join('');
};

/* Calendar */

/**
 * Get the calendar for a user
 *
 * @param  {User}       user                The user to get the calendar for
 * @param  {Boolean}    includeContext      Whether or not the organisational units that were provided as context during subscription should be included
 * @param  {String}     [start]             The timestamp (ISO 8601) from which to get the calendar for the user
 * @param  {String}     [end]               The timestamp (ISO 8601) until which to get the calendar for the user
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Object[]}   callback.events     A subset of event data properties: id, displayName, start, end, location, type, description, notes, organiserOther, updatedAt
 */
var getUserCalendar = module.exports.getUserCalendar = function(user, includeContext, start, end, callback) {
    var dateTimeFilter = {};
    if (start) {
        dateTimeFilter.start = {'gte': start};
    }
    if (end) {
        dateTimeFilter.end = {'lte': end};
    }

    // This query fetches such a massive amount of data, that the CPU usage goes through the roof
    // when Sequelize serialises it. To minimise this, we retrieve only those columns we really need
    var eventFields = ['id', 'displayName', 'start', 'end', 'location', 'type', 'description', 'notes', 'organiserOther', 'updatedAt'];
    var userFields = ['id', 'displayName'];

    var options = {
        // Do an outer join (`'required': false`) since many of the relations are optional
        'include': [
            {'model': DB.CalendarSeries, 'required': false, 'include': [
                {'model': DB.Serie, 'required': false, 'limit': null, 'attributes': ['id'], 'include': [
                    {'model': DB.Event, 'where': dateTimeFilter, 'required': false, 'attributes': eventFields, 'include': [
                        {'model': DB.User, 'as': 'Organisers', 'required': false, 'attributes': userFields}
                    ]}
                ]}
            ]},
            {'model': DB.Event, 'where': dateTimeFilter, 'required': false, 'attributes': eventFields, 'include': [
                {'model': DB.User, 'as': 'Organisers', 'required': false, 'attributes': userFields}
            ]}
        ],

        // We need to add a limit so Sequelize avoids doing a subquery to get the calendar row
        // @see: https://github.com/sequelize/sequelize/issues/2698
        'limit': null
    };

    // Only join the organisational units when required
    if (includeContext) {
        options.include[0].include.push({'model': DB.OrgUnit, 'required': false, 'attributes': ['id', 'ParentId', 'displayName', 'type']});
    }
    user.getCalendar(options).complete(function(err, calendar) {
        if (err) {
            log().error({'err': err, 'user': user.id}, 'Could not get a user\'s calendar');
            return callback({'code': 500, 'msg': 'Could not get a user\'s calendar'});
        }

        // If the user hasn't subscribed to any series or events, he won't
        // have a calendar record yet. In that case, we simply return an empty array
        if (!calendar) {
            return callback(null, []);
        }

        // The events the user subscribed to directly
        var events = calendar.Events;

        // Add the events from each serie he subscribed to
        _.each(calendar.CalendarSeries, function(calendarSerie) {

            // Add the originating organisational unit context, if any, to each event
            calendarSerie.Serie.Events = _.map(calendarSerie.Serie.Events, function(event) {
                event = event.toJSON();
                event.context = calendarSerie.OrgUnit;
                return event;
            });

            // Flatten the calendar into a simple event list
            if (calendarSerie.Serie.Events) {
                events = events.concat(calendarSerie.Serie.Events);
            }
        });

        // Sort the events on their start date
        events = _.sortBy(events, 'start');

        return callback(null, events);
    });
};

/**
 * Get or create the calendar for a user
 *
 * @param  {User}       user                The user whose calendar to retrieve
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Calendar}   callback.calendar   The user's calendar
 */
var getOrCreateCalendar = module.exports.getOrCreateCalendar = function(user, callback) {
    var options = {
        'where': {'UserId': user.id}
    };
    DB.Calendar.findOrCreate(options).complete(function(err, data) {
        if (err) {
            log().error({'err': err, 'user': user.id}, 'Could not get or create a user\'s calendar');
            return callback({'code': 500, 'msg': err.msg});
        }

        var calendar = data[0];
        var wasCreated = data[1];
        if (wasCreated) {
            log().debug({'user': user.id}, 'Created a calendar for a user');
        }

        return callback(null, calendar);
    });
};

/**
 * Subscribe a user to one or more series
 *
 * @param  {Serie[]}    series          The series to subscribe the user to
 * @param  {User}       user            The user that needs to be subscribed to one or more series
 * @param  {Number}     [orgUnit]       The id of the organisational unit that the serie belonged to when the user subscribed to it
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var subscribeSeries = module.exports.subscribeSeries = function(series, user, orgUnit, callback) {
    // TODO: Allow the caller to pass in a transaction

    // Get the user's calendar
    getOrCreateCalendar(user, function(err, calendar) {
        if (err) {
            return callback(err);
        }

        // Get all the event series that are already in the calendar. It's possible
        // that the user already subscribed to a serie. Either because he subscribed
        // to it directly or because it's borrowed under another organisational unit
        // that he subscribed to. We filter out all the series the user is already
        // subscribed to
        calendar.getSeries().complete(function(err, subscribedSeries) {
            if (err) {
                log().error({'err': err, 'user': user.id}, 'Failed to get the subscribed series for a user');
                return callback({'code': 500, 'msg': 'Failed to get the subscribed series for a user'});
            }

            var subscribedSerieIds = _.pluck(subscribedSeries, 'id');
            var serieIds = _.pluck(series, 'id');
            var serieIdsToSubscribeTo = _.difference(serieIds, subscribedSerieIds);

            // Add the new series to the calendar
            calendar.addSeries(serieIdsToSubscribeTo, {'OrgUnitId': orgUnit}).complete(function(err) {
                if (err) {
                    log().error({'err': err, 'series': serieIdsToSubscribeTo, 'user': user.id}, 'Error when adding series to a user\'s calendar');
                    return callback({'code': 500, 'msg': 'Error when adding series to a user\'s calendar'});
                }

                return callback();
            });
        });
    });
};

/**
 * Unsubscribe a user from one or more event series
 *
 * @param  {Serie[]}    series          The series to unsubscribe the user from
 * @param  {User}       user            The user that needs to be unsubscribed from one or more series
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var unsubscribeSeries = module.exports.unsubscribeSeries = function(series, user, callback) {
    // TODO: Allow the caller to pass in a transaction

    // Get the user's calendar
    getOrCreateCalendar(user, function(err, calendar) {
        if (err) {
            return callback(err);
        }

        // Remove the series from the calendar
        calendar.removeSeries(series).complete(function(err) {
            if (err) {
                log().error({'err': err, 'series': _.pluck(series, 'id'), 'user': user.id}, 'Error when removing one or more series from a user\'s calendar');
                return callback({'code': 500, 'msg': 'Error when removing a one or more series from a user\'s calendar'});
            }

            return callback();
        });
    });
};
