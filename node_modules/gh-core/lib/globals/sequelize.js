/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var Promise = require('sequelize/lib/promise');

/*!
 * If an unhandled error is thrown inside the promise, we should promote it. This is needed because
 * if an unhandled exception occurs in the `callback` during the `then` handler it is considered a
 * rejection. Since we want things like unit tests to catch these in the test domain, or express to
 * catch exceptions in the error handling middlewhere, we will promote them
 */
Promise.onPossiblyUnhandledRejection(function(err) {
    throw err;
});

/**
 * Add a style helper to the sequelize Promise that allows us to use callback-style error handling
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Args}       callback.arg0   A variable number of callback-specific return arguments
 */
Promise.prototype.complete = function(callback) {
    var called = false;
    this

        // Failure condition. This must be registered before the `then` condition to ensure that an
        // error in the callback does not get caught by this handler, risking that the callback be
        // invoked twice
        .catch(function(err) {
            if (!called) {
                called = true;

                // Send the err argument to the consumer as the first and only parameter
                callback.call(null, err);
            }
        })

        // Success condition
        .then(function() {
            if (!called) {
                called = true;

                // Shift a null value as the first parameter in the callback to indicate the result is
                // a success
                var args = Array.prototype.slice.call(arguments);
                args.unshift(null);
                callback.apply(null, args);
            }
        });
};
