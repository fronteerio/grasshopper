/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var bunyan = require('bunyan');
var util = require('util');

// The logger to use when no logger is specified
var SYSTEM_LOGGER_NAME = 'system';

// Logger state variables to record active loggers and current configuration
var config = null;
var loggers = {};

/**
 * Refresh the log configuration of all the cached logs with that of the provided log configuration
 *
 * @param  {Object}     newConfig   The new configuration to apply to all the loggers
 */
var refreshLogConfiguration = module.exports.refreshLogConfiguration = function(newConfig) {
    config = newConfig;
    logger('gh-logger')().info('Refreshing log configuration');
    _refreshLogConfigurations();
};

/**
 * Create / retrieve a logger with the provided name
 *
 * @param  {String}     name   The name of the logger, this name will be used to identify this logger for potentially custom log configuration
 * @return {Function}          A function that can be used to retrieve the logger takes argument `ctx`
 */
var logger = module.exports.logger = function(name) {
    name = name || SYSTEM_LOGGER_NAME;

    // Lazy-load the logger and cache it so new loggers don't have to be recreated all the time
    if (!loggers[name]) {
        loggers[name] = _createLogger(name);
    }

    // Return a function that returns the logger. this is the only way we can reserve the ability to refresh the logger
    // configuration on the fly. At the moment the "ctx" param is not used, however it is planned to be able to have
    // tenant/user-specific configuration or ctx-specific information in the log entries
    return function(ctx) {
        return loggers[name];
    };
};

/**
 * Update all the existing loggers to be configured with the current configuration.
 *
 * @api private
 */
var _refreshLogConfigurations = function() {
    _.each(loggers, function(logger, name) {
        loggers[name] = _createLogger(name);
    });
};

/**
 * Create a logger with the provided name.
 *
 * @param  {String}     name    The name to assign to the created logger
 * @api private
 */
var _createLogger = function(name) {
    var _config = _.extend({}, config || _resolveBootstrapLoggerConfig());
    _config.name = name;

    // Construct a Logger object
    var logger = bunyan.createLogger(_config);

    // Wrap the error function so we can keep track of error counts
    logger.error = _wrapErrorFunction(name, logger.error);
    return logger;
};

/**
 * Determine what the default bootstrap logger configuration should be.
 *
 * @return {Object}    The log configuration to use by default
 * @api private
 */
var _resolveBootstrapLoggerConfig = function() {
    var bootstrapConfig = {
        'streams': [{
            'level': 'debug'
        }],
        'serializers': {
            'err': bunyan.stdSerializers.err
        }
    };

    var bootstrapLogFile = 'bootstrap.log';
    if (bootstrapLogFile) {
        bootstrapConfig.streams[0].path = bootstrapLogFile;
    } else {
        bootstrapConfig.streams[0].stream = process.stdout;
    }

    return bootstrapConfig;
};

/**
 * Wrap the error logger function so we can count errors with the telemetry api
 *
 * @param  {String}     loggerName          The name of the logger for which the error logger will be wrapped
 * @param  {Function}   errorFunction       The error logger to wrap
 * @return {Function}                       A wrapped error logger
 * @api private
 */
var _wrapErrorFunction = function(loggerName, errorFunction) {

    /*!
     * Keep track of the error count with the telemetry API before handing control back to Bunyan
     */
    var wrapperErrorFunction = function(data, msg) {
        // If the error came from sequelizejs we log the `err.parent` object
        // as that contains more pertinent information about what went wrong
        if (data.err && data.err.parent) {
            data.err = data.err.parent;
        }

        // TODO: Log to telemetry

        // Pass control back to bunyan who can log the message
        return errorFunction.apply(this, arguments);
    };

    return wrapperErrorFunction;
};
