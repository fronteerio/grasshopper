/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var Sequelize = require('sequelize');

var AppsConstants = require('gh-apps/lib/constants');
var GroupsConstants = require('gh-groups/lib/constants');

var log = require('./logger').logger('gh-core/db');
var Pubsub = require('./pubsub');

// A sequelize instance that will be connected to the database
var sequelize = null;

var init = module.exports.init = function(config, callback) {
    // We only support postgres
    config.db.dialect = 'postgres';

    /*!
     * Pipe sequelize log statements to our own logger
     *
     * @param  {String}     msg     The sequelize log statement
     */
    config.db.logging = function(msg) {
        log().debug(msg);
    };

    // Set up a connection to the database
    sequelize = new Sequelize(config.db.database, config.db.username, config.db.password, config.db);

    sequelize
    .authenticate()
    .done(function(err) {
        if (err) {
            log().error({'err': err}, 'Unable to set up a connection to the database');
            return callback({'code': 500, 'msg': 'Unable to set up a connection to the database'});

        // We only support PostgreSQL
        } else if (sequelize.options.dialect !== 'postgres') {
            log().error('Grasshopper only runs on PostgreSQL');
            process.exit(1);
        }

        log().debug('Connected to the database');

        // Set up the model
        _setUpModel(sequelize);

        // By setting `force` to `true` we will drop each table and recreate it. This is useful
        // during development/testing when models tend to change. We NEVER do this in production though
        var force = false;
        if (process.env['NODE_ENV'] !== 'production' && config.db.dropOnStartup === true) {
            force = true;
        }

        sequelize
        .sync({'force': force})
        .done(function(err) {
            if (err) {
                log().error({'err': err}, 'Unable to sync the model to the database');
                return callback({'code': 500, 'msg': 'Unable to sync the model to the database'});
            }

            log().debug('Synced model to database');

            _setUpPubSub(sequelize, callback);
        });
    });
};

/**
 * Get the `Sequelize` object
 *
 * @return {Sequelize}      A sequelize instance that is connected to the database
 */
var getSequelize = module.exports.getSequelize = function() {
    return sequelize;
};

/**
 * Set up the DB model
 *
 * @param  {Sequelize}      sequelize       A sequelize instance that is connected to the database
 * @api private
 */
var _setUpModel = function(sequelize) {

    /**
     * The Tenant model
     *
     * @property  {Number}      id                      The id of the tenant
     * @property  {String}      displayName             The name of the tenant
     */
    var Tenant = module.exports.Tenant = sequelize.define('Tenant', {
        'displayName': {
            'type': Sequelize.STRING,
            'allowNull': false
        }
    });

    /**
     * The Application model
     *
     * @property  {Number}      id                      The id of the application
     * @property  {String}      displayName             The name of the application (e.g. `Timetable 2013-14`)
     * @property  {Boolean}     [enabled]               Whether the application is currently enabled, defaults to `true`
     * @property  {String}      host                    The host on which the application can be found
     * @property  {String}      type                    The type of the application
     */
    var App = module.exports.App = sequelize.define('App', {
        'displayName': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'host': {
            'type': Sequelize.STRING,
            'allowNull': false,
            'unique': true
        },
        'type': {
            'type': Sequelize.ENUM(_.values(AppsConstants.types)),
            'allowNull': false
        },
        'enabled': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': true
        },
        'TenantId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': Tenant,
            'referencesKey': 'id'
        }
    });

    Tenant.hasMany(App);
    App.belongsTo(Tenant);

    /**
     * The global administrator model
     *
     * @property  {String}      displayName             The name of the global administrator
     * @property  {String}      password                The password for the global administrator
     * @property  {String}      username                The username for the global administrator
     */
    var GlobalAdmin = module.exports.GlobalAdmin = sequelize.define('GlobalAdmin', {
        'displayName': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'password': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'username': {
            'type': Sequelize.STRING,
            'allowNull': false,
            'unique': true
        }
    }, {
        'instanceMethods': {
            'canAdmin': function(appId) {
                // Global administrators can administer any application
                return true;
            },
            'isGlobalAdmin': function() {
                return true;
            },
            'toJSON': function() {
                var json = _.clone(this.dataValues);

                // Never return the password hash
                delete json.password;
                return json;
            }
        }
    });

    /**
     * The user model
     *
     * @property  {String}      authenticationStrategy  The authentication strategy for the user
     * @property  {String}      displayName             The name of the user
     * @property  {String}      email                   The email address for the user
     * @property  {String}      emailPreference         The email preference for the user
     * @property  {String}      isAdmin                 Whether the user is an app administrator
     * @property  {String}      password                The password with which the user will authenticate
     * @property  {String}      shibbolethId            The unique shibboleth id for the user
     * @property  {Date}        [termsAndConditions]    The timestamp at which the user accepted the Terms and Conditions
     */
    var User = module.exports.User = sequelize.define('User', {
        'authenticationStrategy': {
            'type': Sequelize.ENUM('local', 'shibboleth'),
            'allowNull': false
        },
        'displayName': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'email': {
            'type': Sequelize.STRING,
            'allowNull': true,
            // The `email` should be unique within an application. By specifying a string
            // that we re-use in the `AppId` column we can enforce this constraint in postgres
            'unique': 'emailUnique'
        },
        'emailPreference': {
            'type': Sequelize.ENUM('immediate', 'no'),
            'allowNull': false,
            'defaultValue': 'immediate'
        },
        'isAdmin': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': false
        },
        'password': {
            'type': Sequelize.STRING,
            'allowNull': true
        },
        'shibbolethId': {
            'type': Sequelize.STRING,
            'allowNull': true
        },
        'termsAndConditions': Sequelize.DATE,
        'calendarToken': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'AppId': {
            'type': Sequelize.INTEGER,
            'unique': 'emailUnique',
            'allowNull': false,
            'references': App,
            'referencesKey': 'id'
        }
    }, {
        'instanceMethods': {
            'canAdmin': function(appId) {
                return (this.AppId === appId && this.isAdmin);
            },
            'isGlobalAdmin': function() {
                return false;
            },
            'hidePersonalInformation': function(ctx) {
                // There's no need to hide information if the current user is requesting their
                // own profile or the current user can administrate the user's application
                if (ctx.user && (ctx.user.id === this.id || ctx.user.canAdmin(this.AppId))) {
                    return;
                }

                // Otherwise we need to hide some information
                delete this.dataValues.authenticationStrategy;
                delete this.dataValues.password;
                delete this.dataValues.calendarToken;
                delete this.dataValues.email;
                delete this.dataValues.emailPreference;
                delete this.dataValues.isAdmin;
                delete this.dataValues.shibbolethId;
                delete this.dataValues.termsAndConditions;
            },
            'toJSON': function() {
                var json = _.clone(this.dataValues);

                // Never return the password hash
                delete json.password;

                // Don't return unnecessary data
                delete json.Event_Organisers;
                delete json.Group_Members;

                return json;
            }
        }
    });

    App.hasMany(User);
    User.belongsTo(App);

    /**
     * The group model
     *
     * @property  {Date}        lockedOn            The timestamp at which the group was locked
     * @property  {Number}      LockedById          The id of the user who locked the group
     */
    var Group = module.exports.Group = sequelize.define('Group', {
        'lockedOn': Sequelize.DATE,
        'AppId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': App,
            'referencesKey': 'id'
        },
        'LockedById': {
            'type': Sequelize.INTEGER,
            'allowNull': true,
            'references': User,
            'referencesKey': 'id'
        }
    }, {
        'instanceMethods': {
            /**
             * Check whether a group is currently locked
             *
             * @return {Boolean}        `true` if the group is locked, `false` otherwise
             */
            'isLocked': function() {
                var lockedOn = this.dataValues.lockedOn;
                if (!lockedOn) {
                    return false;
                }
                return ((Date.now() - lockedOn.getTime()) < GroupsConstants.timeouts.LOCK);
            },

            'toJSON': function() {
                var json = _.clone(this.dataValues);

                // A lock is only valid for 90 seconds
                json.isLocked = this.isLocked();
                if (!json.isLocked) {
                    delete json.lockedOn;
                    delete json.LockedBy;
                    delete json.LockedById;
                }

                // Don't return unnecessary data
                delete json.Group_Members;

                return json;
            }
        }
    });
    Group.belongsTo(App);
    App.hasMany(Group);

    Group.belongsTo(User, {'as': 'LockedBy'});

    Group.hasMany(User, {'as': 'Members', 'through': 'Group_Members'});
    User.hasMany(Group, {'as': 'Memberships', 'through': 'Group_Members'});

    /**
     * The organization unit (orgunit) model
     *
     * @property  {Number}      id                  The unique identifier of the organisational unit
     * @property  {String}      displayName         The display name of the organisational unit
     * @property  {Group}       group               The group who can edit this organisational unit and the units below it
     * @property  {String}      type                A label that identifies what this organization unit represents within the tree of organisational units
     * @property  {Boolean}     [published]         A flag that identifies the published status of the organisational unit
     * @property  {Object}      [metadata]          An object with extra metadata for the organisational unit
     */
    var OrgUnit = module.exports.OrgUnit = sequelize.define('OrgUnit', {
        'displayName': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'type': {
            'type': Sequelize.STRING(32),
            'allowNull': false
        },
        'description': Sequelize.STRING,
        'metadata': {
            'type': Sequelize.JSON,
            'allowNull': true
        },
        'published': {
            'type': Sequelize.BOOLEAN,
            'allowNull': true,
            'defaultValue': true
        },
        'AppId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': App,
            'referencesKey': 'id'
        },
        'GroupId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': Group,
            'referencesKey': 'id'
        },
        'ParentId': {
            'type': Sequelize.INTEGER,
            'allowNull': true,
            'references': OrgUnit,
            'referencesKey': 'id'
        }
    }, {
        'instanceMethods': {
            // Unfortunately we need this method as otherwise Sequelize
            // won't use the `toJSON` function for nested instances
            'toJSON': function() {
                var json = this.get();

                // Don't return the join table
                delete json.OrgUnitSeries;

                return json;
            }
        }
    });
    OrgUnit.belongsTo(App);
    App.hasMany(OrgUnit);

    OrgUnit.belongsTo(Group);
    Group.hasMany(OrgUnit);

    OrgUnit.hasOne(OrgUnit, {'as': 'Parent', 'foreignKey': 'ParentId'});

    /**
     * The serie model
     *
     * @property  {Number}      id                  The unique identifier of the serie
     * @property  {String}      displayName         The display name of the serie
     * @property  {String}      description         The description of the serie
     * @property  {String}      image               The path to an image for the serie
     * @property  {Object}      metadata            The extra metadata of the serie
     */
    var Serie = module.exports.Serie = sequelize.define('Serie', {
        'displayName': Sequelize.STRING,
        'description': Sequelize.TEXT,
        'image': Sequelize.STRING,
        'metadata': Sequelize.JSON,
        'AppId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': App,
            'referencesKey': 'id'
        },
        'GroupId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': Group,
            'referencesKey': 'id'
        }
    }, {
        'instanceMethods': {
            'toJSON': function() {
                var json = _.clone(this.dataValues);

                // Don't return unnecessary data
                delete json.OrgUnitSeries;

                return json;
            }
        }
    });
    Serie.belongsTo(App);
    App.hasMany(Serie);

    Serie.belongsTo(Group);
    Group.hasMany(Serie);

    /**
     * The join table between the OrgUnit and Serie tables. This table is defined explicitly,
     * as Sequelize doesn't intuitively support three way joins.
     *
     * This table will hold 3 values:
     *  - The organisational unit that contains a serie
     *  - The serie that is in the organisational unit
     *  - An optional organisational unit where the serie was "borrowed" from
     *
     * This is to allow for the timetable use-case where series can be borrowed from each other
     * but the administrator needs an indication where the serie is borrowed from.
     */
    var OrgUnitSeries = module.exports.OrgUnitSeries = sequelize.define('OrgUnitSeries');

    // Allow for orgUnit.addSeries([])
    OrgUnit.hasMany(Serie, {'through': OrgUnitSeries});
    Serie.hasMany(OrgUnit, {'through': OrgUnitSeries});

    // Allow for orgUnit.find(.. include[CalendarSeries])
    OrgUnit.hasMany(OrgUnitSeries);
    Serie.hasMany(OrgUnitSeries);
    OrgUnitSeries.belongsTo(OrgUnit);
    OrgUnitSeries.belongsTo(Serie);

    // Allow us to specify the organisational unit where the serie is "borrowed" from
    OrgUnitSeries.belongsTo(OrgUnit, {'as': 'fromOrgUnit'});

    /**
     * The event model
     *
     * @property  {String}      description         The description of the event
     * @property  {String}      displayName         The name of the event
     * @property  {Date}        end                 The timestamp at which the event ends
     * @property  {String}      [image]             The path to an image for the event
     * @property  {String}      [location]          The location of the event
     * @property  {String}      [notes]             The notes for the event
     * @property  {Date}        start               The timestamp at which the event starts
     * @property  {String}      [type]              The type of the event
     * @property  {String}      [organiserOther]    The name(s) of the unrecognised user(s) that organise the event. If no organisers are added, the current user will be added as the organiser
     */
    var Event = module.exports.Event = sequelize.define('Event', {
        'description': Sequelize.TEXT,
        'displayName': {
            'type': Sequelize.STRING,
            'allowNull': false
        },
        'end': {
            'type': Sequelize.DATE,
            'allowNull': false
        },
        'image': Sequelize.STRING,
        'location': Sequelize.STRING,
        'notes': Sequelize.TEXT,
        'start': {
            'type': Sequelize.DATE,
            'allowNull': false
        },
        'type': Sequelize.STRING,
        'organiserOther': {
            'type': Sequelize.TEXT,
            'set': function(val) {
                if (val && _.isArray(val)) {
                    this.setDataValue('organiserOther', val.sort().join(','));
                } else if (val) {
                    log().warn({'val': val}, 'Trying to set the organiserOther field with a value that is not an array');
                    this.setDataValue('organiserOther', '');
                }
            },
            'get': function() {
                if (this.getDataValue('organiserOther')) {
                    return this.getDataValue('organiserOther').split(',');
                } else {
                    return [];
                }
            }
        },
        'AppId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': App,
            'referencesKey': 'id'
        },
        'GroupId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'references': Group,
            'referencesKey': 'id'
        }
    }, {
        'instanceMethods': {
            'toJSON': function() {
                var json = _.clone(this.dataValues);

                // Produce a pretty list of organisers
                var others = this.organiserOther || [];
                var users = this.Organisers || [];
                json.organisers = others.concat(users);

                // Don't return the separate organiser lists
                delete json.organiserOther;
                delete json.Organisers;

                // Don't return unnecesary data
                delete json.EventsSeries;

                // Return all the other values
                return json;
            }
        }
    });
    Event.belongsTo(App);
    App.hasMany(Event);

    Event.belongsTo(Group);
    Group.hasMany(Event);

    Event.hasMany(User, {'as': 'Organisers', 'through': 'Event_Organisers'});
    User.hasMany(Event, {'as': 'OrganisedEvents', 'through': 'Event_Organisers'});

    Serie.hasMany(Event);
    Event.hasMany(Serie);

    /**
     * The calendar model
     *
     * @property {Number}       id                  The unique identifier of the calendar
     * @property {User}         user                The user who owns the calendar
     * @property {Serie[]}      series              The series in this calendar
     * @property {Event[]}      events              The events in this calendar
     * @property {App}          app                 The application with which the calendar is associated
     */
    var Calendar = module.exports.Calendar = sequelize.define('Calendar', {
        'UserId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'primaryKey': true,
            'references': User,
            'referencesKey': 'id'
        }
    });

    /**
     * The join table between the Calendar and Serie tables. This table is defined explicitly,
     * as Sequelize doesn't intuitively support three way joins.
     *
     * @property {Calendar}     calendar            The user's calendar
     * @property {Serie}        serie               The subscribed serie
     * @property {OrgUnit}      orgUnit             An optional organisational unit under which the serie subscription happened
     */
    var CalendarSeries = module.exports.CalendarSeries = sequelize.define('CalendarSeries');
    OrgUnit.hasOne(CalendarSeries);
    CalendarSeries.belongsTo(OrgUnit);

    // A user has one calendar
    Calendar.belongsTo(User);
    User.hasOne(Calendar);

    // Allow for calendar.addSeries([])
    Calendar.hasMany(Serie, {'through': CalendarSeries});
    Serie.hasMany(Calendar, {'through': CalendarSeries});

    // Allow for calendar.find(.. include[CalendarSeries])
    Calendar.hasMany(CalendarSeries);
    Serie.hasMany(CalendarSeries);
    CalendarSeries.belongsTo(Calendar);
    CalendarSeries.belongsTo(Serie);

    // Calendars can also have single events
    Calendar.hasMany(Event);
    Event.hasMany(Calendar);

    /**
     * The config model
     *
     * @property {Boolean}      allowLocalAccountCreation           Whether or not local accounts can be created
     * @property {Boolean}      enableLocalAuth                     Whether or not local authentication is enabled
     * @property {Boolean}      enableShibbolethAuth                Whether or not shibboleth authenticated is enabled
     * @property {String}       shibIdpEntityId                     The entity ID of the Shibboleth Identity Provider that should be used
     * @property {String}       shibExternalIdAttributes            The attribute that uniquely identifies the user. This should be a prioritised space seperated list
     * @property {String}       shibMapDisplayname                  The attibute(s) that should be used to construct the displayname. This should be a prioritised space seperated list
     * @property {String}       shibMapEmail                        The attibute(s) that should be used to construct the email. This should be a prioritised space seperated list
     * @property {Boolean}      allowUserEventCreation              Whether or not regular users can create events
     * @property {Boolean}      allowUserSerieCreation              Whether or not regular users can create series
     * @property {Boolean}      enableGoogleAnalytics               Whether or not Google Analytics should be enabled for this application
     * @property {Boolean}      googleAnalyticsTrackingId           The Google Analytics tracking identifier
     * @property {String}       academicYear                        The academic year for an application
     * @property {App}          app                                 The application with which the configuration is associated
     */
    var Config = module.exports.Config = sequelize.define('Config', {
        'allowLocalAccountCreation': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': false,
            'allowNull': false
        },
        'enableLocalAuth': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': true,
            'allowNull': false
        },
        'enableShibbolethAuth': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': false,
            'allowNull': false
        },
        'shibIdpEntityId': {
            'type': Sequelize.TEXT,
            'defaultValue': ''
        },
        'shibExternalIdAttributes': {
            'type': Sequelize.TEXT,
            'defaultValue': 'eppn persistent-id targeted-id'
        },
        'shibMapDisplayname': {
            'type': Sequelize.TEXT,
            'defaultValue': 'displayname cn'
        },
        'shibMapEmail': {
            'type': Sequelize.TEXT,
            'defaultValue': 'mail email eppn'
        },
        'allowUserEventCreation': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': true,
            'allowNull': false
        },
        'allowUserSerieCreation': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': true,
            'allowNull': false
        },
        'enableGoogleAnalytics': {
            'type': Sequelize.BOOLEAN,
            'defaultValue': false,
            'allowNull': false
        },
        'googleAnalyticsTrackingId': {
            'type': Sequelize.TEXT,
            'defaultValue': ''
        },
        'academicYear': {
            'type': Sequelize.INTEGER,
            'defaultValue': null,
            'allowNull': true
        },
        'AppId': {
            'type': Sequelize.INTEGER,
            'allowNull': false,
            'primaryKey': true,
            'references': App,
            'referencesKey': 'id'
        }
    });
    Config.belongsTo(App);
    App.hasOne(Config);
};

/**
 * Set up the pub/sub mechanism
 *
 * @param  {Sequelize}  sequelize           A sequelize instance that is connected to the database
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error that occurred, if any
 * @api private
 */
var _setUpPubSub = function(sequelize, callback) {
    // Get the connection
    sequelize.connectionManager.getConnection().complete(function(err, conn) {
        if (err) {
            log().error({'err': err}, 'Could not set up pub sub. This is required, process is exiting');
            process.exit(1);
            return;
        }

        // Anything that comes in on the "watchers" channel gets
        // emitted as an event on the pubsub API
        conn.on('notification', function(msg) {
            log().debug(msg, 'Got postgres notification');

            // The first word in the payload will be used as the event name,
            // the rest of the payload gets sent along as a parameter
            var splitPayload = msg.payload.split(' ');
            var eventName = splitPayload[0];
            splitPayload.shift();
            var eventPayload = splitPayload.join(' ');

            // Emit the event for the local pubsub listeners
            Pubsub.emit(eventName, eventPayload);
        });

        // We listen on 1 channel called "watchers"
        conn.query('LISTEN watchers', function(err) {
            if (err) {
                log().error({'err': err}, 'Unable to listen for pubsub messages');
                return callback({'code': 500, 'msg': 'Unable to listen for pubsub messages'});
            }

            log().debug('Listening for postgres notifications');
            return callback();
        });
    });
};
