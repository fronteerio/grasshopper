/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var busboy = require('express-busboy');
var cookieParser = require('cookie-parser');
var cookieSession = require('cookie-session');
var express = require('express');
var http = require('http');
var passport = require('passport');
var util = require('util');

var AppsUtil = require('gh-apps/lib/util');
var StatsdAPI = require('gh-statsd');

var DB = require('./db');
var log = require('./logger').logger('gh-core/server');

var safePathPrefixes = [];

/**
 * Start an Express server on the specified port. This will be done for both the global admin server and
 * the app server
 *
 * @param  {Number}     port        The port on which the Express server should be started
 * @param  {Object}     config      The application configuration
 * @return {Express}                The created express server
 */
var setUpServer = module.exports.setUpServer = function(port, config) {
    // Create the express server
    var app = express();

    // Expose the HTTP server on the express app server so other modules can hook into it
    app.httpServer = http.createServer(app);

    // Start listening for requests
    app.httpServer.listen(port, config.servers.listenAddress);

    // Don't output pretty JSON
    app.set('json spaces', 0);

    // Don't output the x-powered-by header
    app.set('x-powered-by', false);

    // We should always be running behind a load balancer like Nginx or Apache so we can
    // trust the X-Forwarded-* headers
    app.enable('trust proxy');

    // Store the app on which the request was made on the request object
    app.use(function(req, res, next) {
        AppsUtil.getAppByHost(config, req.hostname, function(err, app) {
            if (err && err.code === 404) {
                return res.status(418).send('No app has been registered for this host');
            } else if (err) {
                log().error({'err': err, 'host': req.hostname}, 'Failed to get an app by hostname');
                return res.status(500).send('Failed to get an app by hostname');
            }

            req.ghApp = app;
            return next();
        });
    });

    // Measure how long each request takes
    app.use(function(req, res, next) {
        var start = Date.now();
        res.on('finish', function() {
            var url = req.url;
            var responseCode = res.statusCode;

            // Try to get a more generalised URL. We try to re-use the
            // Expressjs routing logic and convert `/api/user/1234` into
            // something that can be stored in statsd: `api_user_id`
            if (req.route && req.route.path) {
                url = req.route.path;

                // Remove colons
                url = url.replace(/:/g, '');

                // Remove the first and last slash
                url = url.replace(/^\/|\/$/g, '');

                // Replace any remaining slashes or dots with underscores
                url = url.replace(/\/|\./g, '_');
            }

            // Track the time and response code for the route
            var requestName = util.format('http.%s.%s', req.method, url);

            // In situations where a request fails before we've had a chance to bind a Context, we
            // need to find a way to still get meaningful information to statsd. Use app id -1 as
            // a way to indicate there was no app information available
            var appId = (req.ghApp && req.ghApp.id) || -1;
            var statsd = StatsdAPI.getInstance(appId);

            // Keep track of how many different response codes we get for a request and how long
            // each request takes
            statsd.increment(util.format('%s.%s.count', requestName, responseCode));
            statsd.timing(util.format('%s.time', requestName), Date.now() - start);

            // Track the global response code
            statsd.increment(util.format('http.%s.count', responseCode));
        });
        return next();
    });

    // Grasshopper uses cookies to hash the user id. Signing the cookie will be done by session
    // middleware
    app.use(cookieParser(config.cookie.secret));

    /*!
     * Grasshopper supports the following type of request encodings:
     *
     *  * urlencoded (regular POST requests)
     *  * application/json
     *  * multipart (file uploads)
     *
     * A maximum limit of 250kb is imposed for `urlencoded` and `application/json` requests. This limit only
     * applies to the *incoming request data*. If the client needs to send more than 250kb, it should consider
     * using a proper multipart form request
     */
    busboy.extend(app, {
        // Allow file uploads
        'upload': true,

        // Only 1 file can be uploaded at the same time and
        // it can be at most 10MB in size
        'limits': {
            'fieldSize': 10 * 1024 * 1024,
            'fileSize': 10 * 1024 * 1024,
            'files': 1
        }
    });
    app.use(function(req, res, next) {
        // Ensure the request doesn't cross the files limit
        if (req.busboy && req.busboy.hitFilesLimit) {
            return res.status(400).send('Too many files uploaded');
        }

        // Ensure no file was truncated
        var hasTruncatedFiles = _.find(req.files, function(file, key) {
            return file.truncated;
        });
        if (hasTruncatedFiles) {
            return res.status(400).send('File too big');
        }
        return next();
    });

    // This needs to come BEFORE passport and AFTER cookieParser. The secret will be used to sign the cookie
    app.use(cookieSession({'secret': config.cookie.secret}));

    // Initialize passport
    app.use(passport.initialize({'userProperty': 'ghAuthInfo'}));
    app.use(passport.session());

    return app;
};

/**
 * Aggregate the routes for an Express server to allow binding once all middleware
 * has been set up as registering the first route puts the router onto the middleware
 * stack
 *
 * @param  {Express}        app       The Express server to which to apply the router
 * @return {Router}                   Router for the Express server
 */
var setupRouter = module.exports.setupRouter = function(app) {
    var that = {};
    that.routes = [];

    /**
     * Set up a route on the associated server
     *
     * @param  {String}               method          The http method for the route
     * @param  {String|RegEx}         route           The path for the route
     * @param  {Function|Function[]}  handler         The function to handle requests to this route
     * @param  {String}               [telemetryUrl]  The string to use for telemetry tracking
     * @throws {Error}                                Error thrown when arguments aren't of the proper type
     */
    that.on = function(method, route, handler, telemetryUrl) {
        var isRouteValid = (_.isString(route) || _.isRegExp(route));
        var isHandlerValid = (_.isFunction(handler) || _.isArray(handler));
        if (!_.isString(method)) {
            throw new Error(util.format('Invalid type for request method "%s" when binding route "%s" to Grasshopper Router', method, route.toString()));
        } else if (!isRouteValid) {
            throw new Error(util.format('Invalid route path "%s" while binding route to Grasshopper Router', route.toString()));
        } else if (!isHandlerValid) {
            throw new Error(util.format('Invalid method handler given for route "%s" while binding to Grasshopper Router', route.toString()));
        }

        that.routes.push({
            'method': method,
            'route': route,
            'handler': handler,
            'telemetryUrl': telemetryUrl
        });
    };

    /**
     * Bind all the routes, this should only be called once by the server initialization
     */
    that.bind = function() {
        _.each(that.routes, function(route) {
            app[route.method].apply(app, [route.route, route.handler]);
        });
    };

    return that;
};

/**
 * Finish initialising an Express server after all modules have had an opportunity
 * to initialise. This includes:
 *
 *  * CSRF protection
 *  * Binding the REST routes
 *  * Default "catch-all" error handling
 *
 * @param  {Express}        app       The Express server to finish initialising
 */
var postInitialize = module.exports.postInitialize = function(app, router) {
    /*!
     * Referer-based CSRF protection. If the request is not safe (e.g., POST, DELETE) and the origin of the request (as
     * specified by the HTTP Referer header) does not match the target host of the request (as specified by the HTTP
     * Host header), then the request will result in a 500 error.
     *
     * While referer-based protection is not highly recommended due to spoofing possibilities in insecure environments,
     * it currently offers the best trade-off between ease of use (e.g., for cURL interoperability), effort and security
     * against CSRF attacks.
     *
     * Middleware that gets called earlier, can force the CSRF check to be skipped by setting `_checkCSRF` on the request.
     *
     * If using a utility such as `curl` to POST requests to the API, you can bypass this by just setting the referer
     * header to "/":
     *
     * curl -X POST -e / http://my.grasshopper.local/api/auth/login
     *
     * More information about CSRF attacks: http://en.wikipedia.org/wiki/Cross-site_request_forgery
     */
    app.use(function(req, res, next) {
        // If earlier middleware determined that CSRF is not required, we can skip the check
        if (req['_checkCSRF'] === false) {
            return next();
        }

        if (!_isSafeMethod(req.method) && !_isSafePath(req) && !_isSameOrigin(req)) {
            log().warn({
                'method': req.method,
                'host': req.headers.host,
                'referer': req.headers.referer,
                'targetPath': req.path
            }, 'CSRF validation failed: attempted to execute unsafe operation from untrusted origin');
            return _abort(res, 500, 'CSRF validation failed: attempted to execute unsafe method from untrusted origin');
        }

        return next();
    });

    // Bind routes
    router.bind();

    // Catch-all error handler
    app.use(function(err, req, res, next) {
        // TODO: Telemetry
        log(req.ctx).error({
            err: err,
            req: req,
            res: res
        }, 'Unhandled error in the request chain, caught at the default error handler');
        return _abort(res, 500, 'An unexpected error occurred');
    });
};

/**
 * Abort a request with a given code and response message
 *
 * @param  {Response}   res         The express response object
 * @param  {Number}     code        The HTTP response code
 * @param  {String}     message     The message body to provide as a reason for aborting the request
 * @api private
 */
var _abort = function(res, code, message) {
    res.setHeader('Connection', 'Close');
    return res.status(code).send(message);
};

/**
 * Determine whether the target path for a request is considered "safe" from CSRF attacks
 *
 * @param  {Request}    req         The express request object
 * @return {Boolean}                `true` if the path is safe from CSRF attacks, `false` otherwise
 * @api private
 */
var _isSafePath = function(req) {
    var path = req.path;
    var matchingPaths = _.filter(safePathPrefixes, function(safePathPrefix) {
        return (path.indexOf(safePathPrefix) === 0);
    });
    return (matchingPaths.length > 0);
};

/**
 * Determine whether the given request method is considered "safe"
 *
 * @param  {String}     method      The request method
 * @return {Boolean}                `true` if the request method is safe (e.g., GET, HEAD), `false` otherwise
 * @api private
 */
var _isSafeMethod = function(method) {
    return (method === 'GET' || method === 'HEAD');
};

/**
 * Determine whether the origin host of the given request is the same as the target host
 *
 * @param  {Request}    req         The express request object to test
 * @return {Boolean}                `true` if the request is of the same origin as the target host, `false` otherwise
 * @api private
 */
var _isSameOrigin = function(req) {
    var host = req.headers.host;
    var referer = req.headers.referer;

    if (!referer) {
        return false;
    }

    if (referer.indexOf('/') !== 0) {
        // Verify the host portion against the host header
        referer = referer.split('://')[1];
        if (!referer || referer.split('/')[0] !== host) {
            // If there is nothing after the protocol (e.g., "http://") or the host before the first slash does not match
            // we deem it not to be the same origin
            return false;
        } else {
            return true;
        }
    } else {
        // If the referer is a relative uri, it must be from the same origin
        return true;
    }
};
