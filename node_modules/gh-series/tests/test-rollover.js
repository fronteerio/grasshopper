/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var fs = require('fs');
var path = require('path');
var util = require('util');

var _ = require('lodash');
var assert = require('assert');
var moment = require('moment');

var EventsTestsUtil = require('gh-events/tests/util');
var OrgUnitTestsUtil = require('gh-orgunit/tests/util');
var TestsUtil = require('gh-tests');
var UsersTestsUtil = require('gh-users/tests/util');

var SeriesTestsUtil = require('./util');
var Rollover = require('../lib/internal/patterns/cambridge/rollover');

/**
 * Get the all the combinations of pairs from items.
 *
 * @example
 * // returns [['a', 'b'], ['a', 'c'], ['b', 'a'], ['b', 'c'], ['c', 'a'], ['c', 'b']]
 * pairwiseCombinations(['a', 'b', 'c'])
 */
var pairwiseCombinations = function(items) {
    var pairs = [];
    for (var i = 0; i < items.length; ++i) {
        for (var j = 0; j < items.length; j++) {
            if (j !== i) {
                pairs.push([items[i], items[j]]);
            }
        }
    }
    return pairs;
};

describe('Rollover', function() {

    /**
     * Test timestamp roll over against a dataset of testcases containing actual timestamps for
     * every day in every term of several academic years.
     *
     * data/rollover-testcases.json is generated by the rollover_testcases
     * management command from https://github.com/CUL-DigitalServices/timetable-3
     */
    it('verify timestamps are rolled over from one academic year to another correctly', function() {
        // This can take a little while...
        this.timeout(1000 * 10);

        var testData = JSON.parse(
            fs.readFileSync(path.join(__dirname, 'data/rollover-testcases.json'),
                            {encoding: 'utf-8'}));

        // The rollover code is currently hard-coded to roll over in time local to Europe/London,
        // so we need to ensure the dataset contains times local to London.
        assert.strictEqual(testData.roll_zone, 'Europe/London');

        // The years to test rolling between
        var rolls = pairwiseCombinations(testData.years);

        var count = 0;
        _.each(rolls, function(pair) {
            var yearFrom = pair[0];
            var yearTo = pair[1];

            assert(_.isNumber(yearFrom));
            assert(_.isNumber(yearTo));

            _.each(testData.testcases, function(testcase) {
                assert(_.isObject(testcase));
                assert(yearFrom in testcase);
                assert(yearTo in testcase);

                // Timestamps in the test data are UTC
                assert.strictEqual(moment.tz(testcase[yearFrom], 'UTC').format(), testcase[yearFrom]);

                var from = testcase[yearFrom];
                var rolled = Rollover.rollOverTimestamp(from, yearFrom, yearTo);

                // Use .fail() to avoid generating messages each loop
                if (rolled !== testcase[yearTo]) {
                    assert.fail(rolled, testcase[yearTo], '\n' + util.inspect({
                        'yearFrom': yearFrom,
                        'yearTo': yearTo,
                        'from': from,
                        'academic': testcase.academic,
                        'count': count
                    }));
                }

                count++;
            });
        });

        // Sanity check: ensure we completed the expected number of testcases
        assert(rolls.length >= 1);
        assert(testData.testcases.length >= 1);
        assert.strictEqual(count, (Math.pow(testData.years.length, 2) - testData.years.length) * testData.testcases.length);
    });

    /**
     * Verify the behaviour of the internal dateInBetween() function
     */
    it('verify dateInBetween() returns the day between two dates', function() {
        var cases = [
            {a: [2014, 1, 5], b: [2014, 1, 6], expected: '2014-02-05T00:00:00+00:00'},
            {a: [2014, 1, 5], b: [2014, 1, 7], expected: '2014-02-06T00:00:00+00:00'},
            {a: [2014, 1, 5], b: [2014, 1, 10], expected: '2014-02-07T00:00:00+00:00'},
            {a: [2014, 1, 5], b: [2014, 1, 15], expected: '2014-02-10T00:00:00+00:00'}
        ];

        _.each(cases, function(testcase) {
            var between = Rollover.dateInBetween(moment.utc(testcase.a), moment.utc(testcase.b));
            assert.strictEqual(between.format(), testcase.expected);
        });
    });

    /**
     * Verify the behaviour of the internal getTerm() function
     */
    it('verify getTerm() returns the term nearest a timestamp', function() {
        var testcases = [
            {date: [2014, 11, 5], year: 2014, expected: 0},
            {date: [2014, 5, 5], year: 2014, expected: 0},
            {date: [2015, 0, 1], year: 2014, expected: 1},
            {date: [2015, 2, 20], year: 2014, expected: 1},
            {date: [2015, 3, 10], year: 2014, expected: 2},
            {date: [2015, 3, 25], year: 2014, expected: 2},
            {date: [2015, 7, 1], year: 2014, expected: 2}
        ];

        _.each(testcases, function(tc) {
            assert.strictEqual(Rollover.getTerm(moment.utc(tc.date), tc.year), tc.expected);
        });
    });
});
