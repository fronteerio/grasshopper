/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var assert = require('assert');
var moment = require('moment');

var EventsTestsUtil = require('gh-events/tests/util');
var SeriesTestsUtil = require('./util');
var TestsUtil = require('gh-tests');

var FullPattern = require('gh-series/lib/internal/patterns/cambridge/fullpattern').FullPattern;

describe('Series', function() {

    describe('Aggregation', function() {

        /**
         * Create a serie with 3 events in it. The events will aggregate both in time, place and organisers
         *
         * @param  {Function}       callback            Standard callback function
         * @param  {Event}          callback.eventA     The first event
         * @param  {Event}          callback.eventB     The second event
         * @param  {Event}          callback.eventC     The thid event
         * @param  {Serie}          callback.serie      The serie that holds the events
         */
        var setupAggregation = function(callback) {
            // Create 3 events that hold aggregatable information. Keep in mind
            // that we have to provide the start/end times in UTC
            EventsTestsUtil.assertCreateEvent(global.tests.admins.cam2014.client, 'A', '2014-10-28T13:00:00', '2014-10-28T14:00:00', {'organiserOther': ['Prof William Lawsons'], 'location': 'Room 1'}, function(eventA) {
                EventsTestsUtil.assertCreateEvent(global.tests.admins.cam2014.client, 'A', '2014-11-04T13:00:00', '2014-11-04T14:00:00', {'organiserOther': ['Dr Jack Daniels'], 'location': 'Room 1'}, function(eventB) {
                    EventsTestsUtil.assertCreateEvent(global.tests.admins.cam2014.client, 'A', '2014-11-11T13:00:00', '2014-11-11T14:00:00', {'organiserOther': ['Prof William Lawsons'], 'location': 'Room 2'}, function(eventC) {

                        // Create a serie and add the events
                        SeriesTestsUtil.assertCreateSerie(global.tests.admins.cam2014.client, 'Test serie', {}, function(serie) {
                            SeriesTestsUtil.assertAddSeriesEvents(global.tests.admins.cam2014.client, serie.id, [eventA.id, eventB.id, eventC.id], function() {

                                // Get the serie and check if the aggregated metadata is correct
                                SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                                    return callback(eventA, eventB, eventC, serie);
                                });
                            });
                        });
                    });
                });
            });
        };

        /**
         * Test that verifies that serie metadata contains an aggregated location, organisers and event pattern
         */
        it('verify serie metadata should contain an aggregated location, organisers and event pattern', function(callback) {
            // Create a serie with 3 events that can aggregate
            setupAggregation(function(eventA, eventB, eventC, serie) {

                // Assert all the metadata is present
                assert.ok(serie.metadata);
                assert.ok(serie.metadata.locations);
                assert.ok(serie.metadata.organisers);
                assert.ok(serie.metadata.pattern);

                // Assert the metadata is aggregated and returned in the correct order
                assert.deepEqual(serie.metadata.locations, ['Room 1', 'Room 2']);
                assert.deepEqual(serie.metadata.organisers, ['Dr Jack Daniels', 'Prof William Lawsons']);
                assert.strictEqual(serie.metadata.pattern, 'Mi3-5 Tu 1');
                return callback();
            });
        });

        /**
         * Test that verifies that serie metadata is updated when the location of an event changes
         */
        it('verify serie metadata is updated when the location of an event changes', function(callback) {
            // Create a serie with 3 events that can aggregate
            setupAggregation(function(eventA, eventB, eventC, serie) {
                // Sanity check the locations aggregated
                assert.deepEqual(serie.metadata.locations, ['Room 1', 'Room 2']);

                // Update the location of an event
                EventsTestsUtil.assertUpdateEvent(global.tests.admins.cam2014.client, eventA.id, {'location': 'Room 3'}, function() {

                    // Get the new event metadata and verify the new location is now in the metadata
                    SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                        assert.deepEqual(serie.metadata.locations, ['Room 1', 'Room 2', 'Room 3']);

                        // All events should take place in the same location
                        EventsTestsUtil.assertUpdateEvent(global.tests.admins.cam2014.client, eventB.id, {'location': 'Room 3'}, function() {
                            EventsTestsUtil.assertUpdateEvent(global.tests.admins.cam2014.client, eventC.id, {'location': 'Room 3'}, function() {
                                SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                                    assert.deepEqual(serie.metadata.locations, ['Room 3']);
                                    return callback();
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that serie metadata is updated when events their organisers change
         */
        it('verify serie metadata is updated when events their organisers change', function(callback) {
            // Create a serie with 3 events that can aggregate
            setupAggregation(function(eventA, eventB, eventC, serie) {
                // Sanity check the organisers aggregated
                assert.deepEqual(serie.metadata.organisers, ['Dr Jack Daniels', 'Prof William Lawsons']);

                // Add a plain-text organiser to an event
                EventsTestsUtil.assertUpdateEventOrganisers(global.tests.admins.cam2014.client, eventA.id, {'Father Jack McDougal': true}, function() {
                    // Get the new event metadata and verify the new organiser is now in the metadata
                    SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                        assert.deepEqual(serie.metadata.organisers, ['Dr Jack Daniels', 'Father Jack McDougal', 'Prof William Lawsons']);

                        // All events should have the same organiser
                        EventsTestsUtil.assertUpdateEventOrganisers(global.tests.admins.cam2014.client, eventA.id, {'Father Jack McDougal': true, 'Dr Jack Daniels': false, 'Prof William Lawsons': false}, function() {
                            EventsTestsUtil.assertUpdateEventOrganisers(global.tests.admins.cam2014.client, eventB.id, {'Father Jack McDougal': true, 'Dr Jack Daniels': false, 'Prof William Lawsons': false}, function() {
                                EventsTestsUtil.assertUpdateEventOrganisers(global.tests.admins.cam2014.client, eventC.id, {'Father Jack McDougal': true, 'Dr Jack Daniels': false, 'Prof William Lawsons': false}, function() {
                                    SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                                        assert.deepEqual(serie.metadata.organisers, ['Father Jack McDougal']);

                                        // Add a user as an organiser
                                        TestsUtil.generateTestUsers(global.tests.apps.cam2014, 1, false, function(simon) {
                                            var update = {};
                                            update[simon.profile.id] = true;
                                            EventsTestsUtil.assertUpdateEventOrganisers(global.tests.admins.cam2014.client, eventA.id, update, function() {

                                                // Simon should be in the aggregated set of organisers
                                                SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                                                    var expectedOrganisers = ['Father Jack McDougal', simon.profile.displayName].sort();
                                                    assert.deepEqual(serie.metadata.organisers, expectedOrganisers);
                                                    return callback();
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that serie metadata is updated when an event gets created under a serie
         */
        it('verify serie metadata is updated when an event gets created under a serie', function(callback) {
            // Create a serie with 3 events that can aggregate
            setupAggregation(function(eventA, eventB, eventC, serie) {
                assert.deepEqual(serie.metadata.locations, ['Room 1', 'Room 2']);
                assert.strictEqual(serie.metadata.pattern, 'Mi3-5 Tu 1');
                assert.deepEqual(serie.metadata.organisers, ['Dr Jack Daniels', 'Prof William Lawsons']);

                // Create a new event under the serie
                var opts = {
                    'organiserOther': ['Ms Margaret Sames'],
                    'location': 'Room 3',
                    'series': [serie.id]
                };
                EventsTestsUtil.assertCreateEvent(global.tests.admins.cam2014.client, 'D', '2014-11-18T13:00:00', '2014-11-18T14:00:00', opts, function(eventD) {

                    // Verify the serie metadata has been updated
                    SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                        assert.deepEqual(serie.metadata.locations, ['Room 1', 'Room 2', 'Room 3']);
                        assert.strictEqual(serie.metadata.pattern, 'Mi3-6 Tu 1');
                        assert.deepEqual(serie.metadata.organisers, ['Dr Jack Daniels', 'Ms Margaret Sames', 'Prof William Lawsons']);

                        return callback();
                    });
                });
            });
        });

        /**
         * Test that verifies that serie metadata is updated when events their start or end times change
         */
        it('verify serie metadata is updated when events their start or end times change', function(callback) {
            // Create a serie with 3 events that can aggregate
            setupAggregation(function(eventA, eventB, eventC, serie) {
                // Sanity-check the time aggregated in a nice pattern
                assert.strictEqual(serie.metadata.pattern, 'Mi3-5 Tu 1');

                // Postpone event A by one hour
                var start = moment(new Date(eventA.start)).add(1, 'hour').format();
                var end = moment(new Date(eventA.end)).add(1, 'hour').format();
                EventsTestsUtil.assertUpdateEvent(global.tests.admins.cam2014.client, eventA.id, {'start': start, 'end': end}, function() {
                    SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                        assert.strictEqual(serie.metadata.pattern, 'Mi3 Tu 2; Mi4-5 Tu 1');

                        // Make the event a 2 hour session
                        end = moment(new Date(end)).add(1, 'hour').format();
                        EventsTestsUtil.assertUpdateEvent(global.tests.admins.cam2014.client, eventA.id, {'end': end}, function() {
                            SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                                assert.strictEqual(serie.metadata.pattern, 'Mi3 Tu 2-4; Mi4-5 Tu 1');

                                // Make the event a 3 hour session by letting it start at 12 o'clock
                                start = moment(new Date(start)).subtract(1, 'hour').format();
                                EventsTestsUtil.assertUpdateEvent(global.tests.admins.cam2014.client, eventA.id, {'start': start}, function() {
                                    SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                                        assert.strictEqual(serie.metadata.pattern, 'Mi3 Tu 1-4; Mi4-5 Tu 1');
                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });

        /**
         * Test that verifies that organisers who are linked users are included when aggregating event organisers
         */
        it('verify organisers who are linked users are included when aggregating event organisers', function(callback) {
            // Create a serie with 3 events that can aggregate
            setupAggregation(function(eventA, eventB, eventC, serie) {

                // Create an event, but don't specify an organiser. This will make it default
                // to the current user. Ensure the aggregator can handle this
                EventsTestsUtil.assertCreateEvent(global.tests.admins.cam2014.client, 'A', '2014-11-11T20:00:00', '2014-11-20T14:00:00', {'location': 'Room 2'}, function(eventD) {
                    SeriesTestsUtil.assertAddSeriesEvents(global.tests.admins.cam2014.client, serie.id, [eventD.id], function() {

                        // Get the serie and check if the aggregated metadata is correct
                        SeriesTestsUtil.assertGetSeries(global.tests.admins.cam2014.client, serie.id, false, true, null, function(serie) {
                            assert.strictEqual(serie.metadata.organisers.length, 3);
                            return callback();
                        });
                    });
                });
            });
        });
    });

    describe('Patterns', function() {

        // TODO: Once import is written, we should import some data from
        // the old timetable system and compare patterns

        /**
         * Test that verifies aggregation across terms
         */
        it('verify aggregation across terms', function(callback) {
            // A 1 hour event in the first week of the first term at 1pm
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-14T13:00:00Z', 'end': '2014-10-14T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 Tu 2');

            // Add a 1 hour event in the first week of the second term at 1 pm. Notice that we
            // need to specify 14UTC as it's no longer BST anymore
            fullPattern.add({'start': '2015-01-20T14:00:00Z', 'end': '2015-01-20T15:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1,Le1 Tu 2');

            // Add a similar avent in the first week of the third term at 1pm. BST kicks in
            // on the last sunday of March, so we need to specify 13 UTC again
            fullPattern.add({'start': '2015-04-21T13:00:00Z', 'end': '2015-04-21T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1,Le1,Ea1 Tu 2');
            return callback();
        });

        /**
         * Test that verifies aggregation across weeks
         */
        it('verify aggregation across weeks', function(callback) {
            // A 1 hour event in the first week of the first term at 1pm
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-14T13:00:00Z', 'end': '2014-10-14T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 Tu 2');

            // Add a 1 hour event in the second week of the first term at 1pm
            fullPattern.add({'start': '2014-10-21T13:00:00Z', 'end': '2014-10-21T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-2 Tu 2');

            // Add a 1 hour event in the third week of the first term at 1pm
            fullPattern.add({'start': '2014-10-28T14:00:00Z', 'end': '2014-10-28T15:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-3 Tu 2');
            return callback();
        });

        /**
         * Test that verifies aggregation across days
         */
        it('verify aggregation across days', function(callback) {
            // A 1 hour event on Monday in the first week of the first term at 1pm
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T13:00:00Z', 'end': '2014-10-13T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M 2');

            // Add a 1 hour event on Wednesday in the first week of the first term at 1pm
            fullPattern.add({'start': '2014-10-15T13:00:00Z', 'end': '2014-10-15T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M,W 2');

            // Add a 1 hour event on Tuesday in the first week of the first term at 1pm
            fullPattern.add({'start': '2014-10-14T13:00:00Z', 'end': '2014-10-14T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M-W 2');
            return callback();
        });

        /**
         * Test that verifies that events that last exactly 1 hour are abbreviated
         */
        it('verify events that last exactly 1 hour are abbreviated', function(callback) {
            // A 1 hour event on Monday in the first week of the first term at 1pm
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T13:00:00Z', 'end': '2014-10-13T14:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M 2');

            // A 4 hour event on Monday in the first week of the first term at 1pm
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T13:00:00Z', 'end': '2014-10-13T17:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M 2-6');
            return callback();
        });

        /**
         * Test that verifies that events that take place before 8am are marked
         */
        it('verify events that take place before 8am are marked', function(callback) {
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T05:00:00Z', 'end': '2014-10-13T06:00:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M 6!');
            return callback();
        });

        /**
         * Test that verifies that minutes are included when not zero
         */
        it('verify minutes are included when not zero', function(callback) {
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1 M 6:30!');
            return callback();
        });

        /**
         * Test that verifies that the order in which events are added is irrelevant
         */
        it('verify that the order in which events are added is irrelevant', function(callback) {
            // Add events in an ascending order
            var fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            fullPattern.add({'start': '2014-10-20T05:30:00Z', 'end': '2014-10-20T06:30:00Z'});
            fullPattern.add({'start': '2014-10-27T06:30:00Z', 'end': '2014-10-27T07:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-3 M 6:30!');

            // Add events in a descending order
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-27T06:30:00Z', 'end': '2014-10-27T07:30:00Z'});
            fullPattern.add({'start': '2014-10-20T05:30:00Z', 'end': '2014-10-20T06:30:00Z'});
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-3 M 6:30!');

            // Add events in a random order
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-20T05:30:00Z', 'end': '2014-10-20T06:30:00Z'});
            fullPattern.add({'start': '2014-10-27T06:30:00Z', 'end': '2014-10-27T07:30:00Z'});
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-3 M 6:30!');

            // Add 2 blocks of events in ascending order
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            fullPattern.add({'start': '2014-10-20T05:30:00Z', 'end': '2014-10-20T06:30:00Z'});
            fullPattern.add({'start': '2014-11-03T06:30:00Z', 'end': '2014-11-03T07:30:00Z'});
            fullPattern.add({'start': '2014-11-10T06:30:00Z', 'end': '2014-11-10T07:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-2,4-5 M 6:30!');

            // Add 2 blocks of events in descending order
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-11-10T06:30:00Z', 'end': '2014-11-10T07:30:00Z'});
            fullPattern.add({'start': '2014-11-03T06:30:00Z', 'end': '2014-11-03T07:30:00Z'});
            fullPattern.add({'start': '2014-10-20T05:30:00Z', 'end': '2014-10-20T06:30:00Z'});
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-2,4-5 M 6:30!');

            // Add 2 blocks of events in random order
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-11-03T06:30:00Z', 'end': '2014-11-03T07:30:00Z'});
            fullPattern.add({'start': '2014-11-10T06:30:00Z', 'end': '2014-11-10T07:30:00Z'});
            fullPattern.add({'start': '2014-10-13T05:30:00Z', 'end': '2014-10-13T06:30:00Z'});
            fullPattern.add({'start': '2014-10-20T05:30:00Z', 'end': '2014-10-20T06:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi1-2,4-5 M 6:30!');

            // Add 2 blocks of events that take place during other timeslots
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-11-03T06:30:00Z', 'end': '2014-11-03T07:30:00Z'});
            fullPattern.add({'start': '2014-11-10T06:30:00Z', 'end': '2014-11-10T07:30:00Z'});
            fullPattern.add({'start': '2014-10-20T09:30:00Z', 'end': '2014-10-20T10:30:00Z'});
            fullPattern.add({'start': '2014-10-27T10:30:00Z', 'end': '2014-10-27T11:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi2-3 M 10:30; Mi4-5 M 6:30!');

            // Verify order when the pattern spans multiple days
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2014-10-22T10:30:00Z', 'end': '2014-10-22T11:30:00Z'});
            fullPattern.add({'start': '2014-10-21T10:30:00Z', 'end': '2014-10-21T11:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi2 Tu-W 11:30');

            // Verify order when the pattern spans multiple terms
            fullPattern = new FullPattern();
            fullPattern.add({'start': '2015-01-26T15:30:00Z', 'end': '2015-01-26T16:30:00Z'});
            fullPattern.add({'start': '2014-10-27T10:30:00Z', 'end': '2014-10-27T11:30:00Z'});
            assert.strictEqual(fullPattern.toString(), 'Mi3 M 10:30; Le2 M 3:30');
            return callback();
        });
    });
});
