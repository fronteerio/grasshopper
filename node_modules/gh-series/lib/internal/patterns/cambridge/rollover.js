/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var moment = require('moment-timezone');

var PatternConstants = require('./constants');

/**
 * Roll a timestamp over to the next academic year
 *
 * This function will determine on what day of what week of which term a timestamp falls and
 * use that information to return a timestamp that happens on the same day of the same week
 * of the same term.
 *
 * @param  {String}     timestamp   A timestamp to roll over
 * @param  {Number}     from        The academical year to which the timestamp belongs
 * @param  {Number}     to          The academical year to which the timestamp should be rolled over
 * @return {String}                 The rolled over timestamp
 */
var rollOverTimestamp = module.exports.rollOverTimestamp = function(timestamp, from, to) {
    // Convert the timestamp to a momentjs instance as it's easier to work with
    // We should work in the London timezone as we need to take daylight savings
    // time into account
    timestamp = moment.tz(timestamp, 'Europe/London');
    var time = timestamp.clone();

    // Need to perform date calculations at midnight, otherwise differing times can affect
    // the day delta between 2 moments.
    timestamp.hour(0).minute(0).second(0).millisecond(0);

    // Try to figure out which term the timestamp belongs to
    var termIndex = getTerm(timestamp, from);
    var termStart = moment.tz(PatternConstants.TERM_DATES[from][termIndex], 'Europe/London');

    // Determine in which week this event took place and what day
    var dayOfWeek = timestamp.isoWeekday(); // 1 = Monday, 7 = Sunday

    // The dates in the constants start on a Tuesday, but a term "week" really starts on a Thursday
    var actualStartOfTerm = termStart.add(2, 'day');
    var days = timestamp.diff(actualStartOfTerm, 'day');

    // Determine in what week the event falls:
    // If a term starts on Tues the 7th of Oct
    //  - Week 0 = 7th and 8th of Oct
    //  - Week 1 = Thurs 9th till 15th
    var weeks = Math.floor(days / 7);

    // Start with the start date of the term the timestamp belongs to
    var newTimestamp = moment.tz(PatternConstants.TERM_DATES[to][termIndex], 'Europe/London');

    // Make up for weeks starting on a Thursday
    newTimestamp.add(2, 'day');

    // Add the necessary amount of weeks
    newTimestamp.add(weeks, 'week');

    // Ensure the event is hold on the same day. We can't simply use isoWeekday as Cambridge
    // has to start the week on a Thursday
    var offset = ((dayOfWeek - actualStartOfTerm.isoWeekday()) + 7) % 7;
    newTimestamp.add(offset, 'day');

    // Simply copy the time information
    newTimestamp.hours(time.hours());
    newTimestamp.minutes(time.minutes());
    newTimestamp.seconds(time.seconds());

    // Return the new timestamp
    return newTimestamp.tz('UTC').format();
};

/**
 * Given a timestamp, get the term under which it falls
 *
 * The term nearest the timestamp is returned when timestamp does not fall under a term.
 *
 * @param  {Moment}     timestamp       The timestamp for which to get the term
 * @param  {Number}     from            The academical year to which the timestamp belongs
 * @return {Number}                     0 = Michaelmas, 1 = Lent, 2 = Easter
 * @api private
 */
var getTerm = module.exports.getTerm = function(timestamp, from) {
    var endMichaelmas = dateInBetween(
        PatternConstants.TERM_DATES[from][0].clone().add(8, 'weeks'),
        PatternConstants.TERM_DATES[from][1]);

    var endLent = dateInBetween(
        PatternConstants.TERM_DATES[from][1].clone().add(8, 'weeks'),
        PatternConstants.TERM_DATES[from][2]);

    if (timestamp.diff(endLent, 'days') >= 0) {
        return 2;
    } else if (timestamp.diff(endMichaelmas, 'days') >= 0) {
        return 1;
    } else {
        return 0;
    }
};

/**
 * Get the date half way between two dates.
 *
 * @param  {Moment}     a   The start date
 * @param  {Moment}     b   The end date
 * @return {Moment}         The moment half way between a and b.
 * @api private
 */
var dateInBetween = module.exports.dateInBetween = function(a, b) {
    return a.clone().add(Math.floor(b.diff(a, 'days') / 2), 'days');
};
