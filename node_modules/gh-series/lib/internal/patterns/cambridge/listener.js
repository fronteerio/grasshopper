/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var events = require('events');

var log = require('gh-core/lib/logger').logger('gh-series/pattern');

var EventsAPI = require('gh-events');
var EventsConstants = require('gh-events/lib/constants');
var EventsDAO = require('gh-events/lib/internal/dao');
var SeriesAPI = require('gh-series');
var SeriesConstants = require('gh-series/lib/constants');
var SeriesDAO = require('gh-series/lib/internal/dao');

var FullPattern = require('./fullpattern').FullPattern;

var Listener = module.exports = new events.EventEmitter();

/**
 * Generate extra metadata for a given serie. This function will
 * aggregate all the events under a serie an generate aggregate values for:
 *  - the location
 *  - the organisers
 *  - the time when the events take place in the form of a "Cambridge timetable pattern"
 *
 * @param  {Serie}      serie       The serie for which to generate the metadata
 * @api private
 */
var generateMetadata = function(serie) {
    // Indicate that we're about to generate some serie metadata allowing the tests
    // to pause til the asynchronous operation finishes
    Listener.emit('preGeneration');

    // Get all the events for the serie
    SeriesDAO.getSeriesEvents(serie, null, null, null, null, true, function(err, events) {
        if (err) {
            log().error({'err': err, 'serie': serie.id}, 'Unable to generate a pattern for a serie');
            return;
        }

        // Keep track of the locations where each event is held
        var locations = [];

        // Keep track of who organises the events
        var organisers = [];

        // Keep track of the "Cambridge pattern" for this event series
        var fullPattern = new FullPattern();

        _.each(events, function(event) {
            event = event.toJSON();
            fullPattern.add(event);
            locations.push(event.location);
            organisers.push(event.organisers);
        });

        // Only retain the unique locations
        locations = _.chain(locations).uniq().compact().value().sort();

        // Only retain the unique names of the organisers
        organisers = _.chain(organisers)
            .flatten()
            .map(function(organiser) {
                if (_.isObject(organiser)) {
                    return organiser.displayName;
                } else {
                    return organiser;
                }
            })
            .uniq()
            .compact()
            .value()
            .sort();

        var metadata = {
            'pattern': fullPattern.toString(),
            'locations': locations,
            'organisers': organisers
        };

        // Update the serie metadata
        SeriesDAO.updateSerie(serie, {'metadata': metadata}, function(err) {
            if (err) {
                log().error({
                    'err': err,
                    'serie': serie.id
                }, 'Unable to persist a pattern for a serie');
            }

            // Indicate that the asynchronous metadata-generation operation has completed
            Listener.emit('postGeneration', serie);
        });
    });
};

/**
 * Called when events are added or removed from an event series. When the serie
 * resides on a `timetable` application, the metadata for it will be (re)generated
 *
 * @param  {Context}    ctx         Standard context containing the current user and the current app
 * @param  {Serie}      serie       The serie to/from which events were added/removed
 * @api private
 */
var onEventSerieChange = function(ctx, serie) {
    if (serie.App.type === 'timetable') {
        // Generate the metadata for this serie
        generateMetadata(serie);
    }
};

SeriesAPI.on(SeriesConstants.events.ADDED_EVENTS, onEventSerieChange);
SeriesAPI.on(SeriesConstants.events.DELETED_EVENTS, onEventSerieChange);

EventsAPI.on(EventsConstants.events.CREATED_EVENT, function(ctx, event, series) {
    if (event.App.type === 'timetable' && !_.isEmpty(series)) {
        _.each(series, function(serie) {
            generateMetadata(serie);
        });
    }
});

EventsAPI.on(EventsConstants.events.UPDATED_EVENT, function(ctx, event, updatedEvent) {
    // Only re-generate patterns if the event belongs to the timetable app
    // and the start and/or end date of the event changed
    if (updatedEvent.App.type === 'timetable' && (
         (event.start !== updatedEvent.start || event.end !== updatedEvent.end)) ||
         (event.location !== updatedEvent.location) ||
         !sameOrganisers(event, updatedEvent)) {

        // Indicate that we're about to generate some serie metadata allowing the tests
        // to pause til the asynchronous operation finishes
        Listener.emit('preGeneration');

        // Get all the series that hold this event
        EventsDAO.getSeries(updatedEvent, function(err, series) {
            if (err) {
                log().error({
                    'err': err,
                    'event': event.id
                }, 'Unable to get the series for an event, the serie patterns will not be updated');
                return;
            }

            // Generate the metadata for each serie
            _.each(series, function(serie) {
                generateMetadata(serie);
            });

            // Emit one extra `postGeneration` to make up for the async `getSeries` call from earlier
            Listener.emit('postGeneration');
        });
    }
});

/**
 * Check whether two events have the same organisers
 *
 * @param  {Event}          eventA      The first event to check
 * @param  {Event}          eventB      The second event to check
 * @return {Boolean}                    Whether or not the two events have the same organisers
 * @api private
 */
var sameOrganisers = function(eventA, eventB) {
    var eventAOrganiserIds = _.pluck(eventA.Organisers, 'id');
    var eventBOrganiserIds = _.pluck(eventB.Organisers, 'id');
    return (_.isEqual(eventA.organiserOther, eventB.organiserOther) &&
            _.isEqual(eventAOrganiserIds, eventBOrganiserIds));
};
