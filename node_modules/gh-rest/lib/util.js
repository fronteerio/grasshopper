/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var EventEmitter = require('events').EventEmitter;
var request = require('request');
var Stream = require('stream');
var util = require('util');

/**
 * ### Events
 *
 * `RestUtil` emits the following events:
 *
 * * `error(error)`: An error occurred when making a REST request
 * * `response(body, response)`: An HTTP response that was received
 */
var emitter = module.exports = new EventEmitter();

/**
 * Set up a client with some basic functionality such as
 * the ability to make HTTP requests
 *
 * @param  {RestClient}     client      The REST client to set up
 */
var setup = module.exports.setup = function(client) {

    // Instantiate a new cookie jar for this client
    client.cookieJar = request.jar();

    // Contains the utility functions
    client.util = {};

    /**
     * Make an HTTP request to the REST API
     *
     * @param  {String}     url                     The URL where the request should be made against
     * @param  {String}     method                  The HTTP method to perform
     * @param  {Object}     [data]                  Any data that should be sent
     * @param  {Object}     [headers]               Any headers that should be sent, the `host` and `referer` header will be added when they're not present
     * @param  {Function}   callback                Standard callback function
     * @param  {Object}     callback.err            An error that occurred, if any
     * @param  {String}     callback.body           The response body
     * @param  {Response}   callback.response       The full response object
     * @api private
     */
    client._request = function(url, method, data, headers, callback) {
        data = data || {};
        headers = headers || {};
        callback = callback || function() {};

        // If no host header was specified, we set it to the configured host
        if (!headers.host) {
            headers.host = client.options.hostHeader;
        }

        // If no referer header was specified, we set it to the configured host
        if (!headers.referer) {
            headers.referer = util.format('%s://%s/', client.options.protocol, client.options.hostHeader);
        }

        // If no authentication header was specified, apply the bearer token
        if (!headers.authorization && client.options.bearer) {
            headers.authorization = util.format('Bearer %s', client.options.bearer);
        }

        var opts = {
            'url': util.format('%s://%s%s', client.options.protocol, client.options.host, url),
            'method': method,
            'jar': client.cookieJar,
            'strictSSL': client.options.strictSSL,
            'followRedirect': client.options.followRedirect || false,
            'headers': headers
        };

        // Sanitize the parameters to not include null / unspecified values
        _.each(data, function(value, key) {
            if (value === null || value === undefined) {
                delete data[key];
            } else if (_.isArray(value)) {
                // Filter out unspecified items from the parameter array, and remove it if it is empty
                value = _.compact(value);
                if (_.isEmpty(value)) {
                    delete data[key];
                } else {
                    data[key] = value;
                }
            }
        });

        if (!_.isEmpty(data)) {
            if (opts.method === 'GET') {
                opts.qs = data;
            } else {

                // Depending on the data that we have, we can either submit a URL-encoded form
                // or use multipart form uploads. We will only use the latter if there's a stream
                // or buffer present in the provided data.
                var useMultipartForms = _.some(data, function(val, key) {
                    return (val instanceof Stream || Buffer.isBuffer(val));
                });

                if (useMultipartForms) {
                    // requestjs is using the `form-data` library which only accepts strings,
                    // streams and buffers. To avoid errors when passing in numbers or booleans,
                    // we stringify everything that's not a stream or buffer
                    opts.formData = {};
                    _.each(data, function(val, key) {
                        if (val instanceof Stream || Buffer.isBuffer(val)) {
                            opts.formData[key] = val;
                        } else {
                            opts.formData[key] = '' + val;
                        }
                    });
                } else {
                    // Do a simple urlencoded POST
                    opts.form = data;
                }
            }
        }

        emitter.emit('request', opts.url, opts.method, opts.qs || opts.formData || opts.form);
        var req = request(opts, function(err, response, body) {
            if (err) {
                emitter.emit('error', err);
                return callback({'code': 500, 'msg': util.format('Something went wrong trying to contact the server:\n%s\n%s', err.message, err.stack)});
            } else if (response.statusCode >= 400) {
                err = {'code': response.statusCode, 'msg': body};
                emitter.emit('error', err, body, response);
                return callback(err);
            }

            // Check if the response body is JSON
            try {
                body = JSON.parse(body);
            } catch (ex) {
                /* This can be ignored, response is not a JSON object */
            }

            emitter.emit('response', body, response);
            return callback(null, body, response);
        });
    };

    /**
     * Utility wrapper around the native JS encodeURIComponent function, to make sure that
     * encoding null doesn't return "null". In tests, null will often be passed in to validate
     * validation, and there's no need to catch the "null" string everywhere.
     *
     * @param  {String}     uriComponent        The URL part to encode and make URL safe
     * @return {String}                         The encoded URL part. When null was passed in, this will return ''
     */
    client.util.encodeURIComponent = function(uriComponent) {
        return (uriComponent === null) ? '' : encodeURIComponent(uriComponent);
    };
};
