/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');
var events = require('events');

var GrasshopperUtil = require('gh-core/lib/util');
var GroupsAPI = require('gh-groups');
var GroupsDAO = require('gh-groups/lib/internal/dao');
var log = require('gh-core/lib/logger').logger('gh-events');
var SeriesDAO = require('gh-series/lib/internal/dao');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var EventsAuthz = require('./authz');
var EventsConstants = require('./constants');
var EventsDAO = require('./internal/dao');

/**
 * ### Events
 *
 * The `EventsAPI`, as enumerated in `EventsConstants.events`, emits the following events:
 *
 * * `createdEvent(ctx, event, series)`: An event was created. The `ctx`, `event` and any series the event was added to are provided
 * * `updatedEvent(ctx, oldEvent, updatedEvent)`: An event was updated. The `ctx`, the old event object and the new one are provided
 */
var EventsAPI = module.exports = new events.EventEmitter();

/**
 * Create a new event
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         [appId]                     The id of the application that this event will belong to, defaults to the current application
 * @param  {String}         displayName                 The name of the event
 * @param  {Number}         start                       The timestamp (ISO 8601) at which the event starts
 * @param  {Number}         end                         The timestamp (ISO 8601) at which the event ends
 * @param  {Object}         [opts]                      A set of optional parameters
 * @param  {String}         [opts.description]          The description of the event
 * @param  {Number}         [opts.group]                The id of the group that can manage the event
 * @param  {String}         [opts.location]             The location of the event
 * @param  {String}         [opts.notes]                The notes for the event
 * @param  {String[]}       [opts.organiserOther]       The name(s) of the unrecognised user(s) that organise the event. If no organisers are added, the current user will be added as the organiser
 * @param  {Number[]}       [opts.organiserUsers]       The id(s) of the recognised user(s) that organise the event
 * @param  {Number[]}       [opts.series]               The id(s) of the serie(s) that the event belongs to
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Event}          callback.event              The created event
 */
var createEvent = module.exports.createEvent = function(ctx, appId, displayName, start, end, opts, callback) {
    // Default the optional values
    opts = opts || {};
    appId = appId || ctx.app.id;

    // Ensure that the app id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    // TODO: Validate serie if any
    var validator = new Validator();
    validator.check(appId, {'code': 400, 'msg': 'A valid application id must be provided'}).isInt();
    validator.check(displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).isShortString();
    validator.check(start, {'code': 400, 'msg': 'A valid start time must be provided'}).notEmpty();
    validator.check(start, {'code': 400, 'msg': 'A valid start time must be provided'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'A valid end time must be provided'}).notEmpty();
    validator.check(end, {'code': 400, 'msg': 'A valid end time must be provided'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (opts.description) {
        validator.check(opts.description, {'code': 400, 'msg': 'A description can be at most 1000 characters long'}).isMediumString();
    }
    if (opts.group) {
        // Ensure that the group id is a valid number, if any
        opts.group = GrasshopperUtil.getNumberParam(opts.group);
        validator.check(opts.group, {'code': 400, 'msg': 'A group must be a valid integer'}).isInt();
    }
    if (opts.location) {
        validator.check(opts.location, {'code': 400, 'msg': 'A location can be at most 256 characters long'}).isShortString();
    }
    if (opts.notes) {
        validator.check(opts.notes, {'code': 400, 'msg': 'Notes can be at most 10000 characters long'}).isLongString();
    }
    if (!_.isEmpty(opts.series)) {
        // Ensure that each serie id is a valid number
        opts.series = _.map(opts.series, function(serieId) {
            serieId = GrasshopperUtil.getNumberParam(serieId);
            validator.check(serieId, {'code': 400, 'msg': 'A valid serie id must be provided'}).isInt();
            return serieId;
        });
    }
    if (opts.organiserOther) {
        validator.check(null, {'code': 400, 'msg': 'Plain-text organisers should be specified as an array'}).isArray(opts.organiserOther);
        _.each(opts.organiserOther, function(organiser) {
            validator.check(organiser, {'code': 400, 'msg': 'A plain-text organiser can be at most 256 characters long'}).isShortString();
            validator.check(organiser, {'code': 400, 'msg': 'A plain-text organiser cannot contain a comma'}).notContains(',');
        });
    }
    if (opts.organiserUsers) {
        validator.check(null, {'code': 400, 'msg': 'Organiser users should be specified as an array'}).isArray(opts.organiserUsers);
        _.each(opts.organiserUsers, function(userId, index) {
            opts.organiserUsers[index] = GrasshopperUtil.getNumberParam(userId);
            validator.check(userId, {'code': 400, 'msg': 'An individual organiser user should be specified by its id'}).isInt();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that the series exist, if any
    _validateOptionalSeries(ctx, opts.series, appId, function(err, series) {
        if (err) {
            return callback(err);
        }

        // Ensure the user can create an event on the specified application
        EventsAuthz.canCreateEvent(ctx, appId, series, function(err, canCreateEvent) {
            if (err) {
                return callback(err);
            } else if (!canCreateEvent) {
                return callback({'code': 401, 'msg': 'You are not allowed to create events'});
            }

            // Ensure the specified users exist, if any
            var userIds = opts.organiserUsers || [];
            UsersDAO.getUsersById(appId, userIds, function(err, users) {
                if (err) {
                    return callback(err);
                }
                opts.organiserUsers = users;

                // If no organisers were specified and the current user is not
                // a global admin, we make the current user an event organiser
                if (_.isEmpty(opts.organiserOther) && _.isEmpty(opts.organiserUsers) && !ctx.user.isGlobalAdmin()) {
                    opts.organiserUsers = [ctx.user.id];
                }

                // Get or create the group
                GroupsAPI.getOrCreateGroup(ctx, appId, opts.group, function(err, group) {
                    if (err) {
                        return callback(err);
                    }

                    // Ensure `opts.group` points to a valid group
                    opts.group = group.id;

                    // Create the event
                    EventsDAO.createEvent(appId, displayName, start, end, opts, function(err, event) {
                        if (err) {
                            return callback(err);
                        }

                        EventsAPI.emit(EventsConstants.events.CREATED_EVENT, ctx, event, series);
                        return callback(null, event);
                    });
                });
            });
        });
    });
};

/**
 * Get an event
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the event to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Event}          callback.event      The requested event
 */
var getEvent = module.exports.getEvent = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    EventsDAO.getEvent(id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // Ensure that the event is either being requested from the app it belongs to
        // or from an authenticated user on the global admin
        if (event.AppId !== ctx.app.id && (!ctx.user || !ctx.user.isGlobalAdmin())) {
            return callback({'code': 401, 'msg': 'This event cannot be retrieved on this application'});
        }

        // Hide organisers their personal information
        _.each(event.Organisers, function(organiser) {
            organiser.hide(ctx);
        });

        return callback(null, event);
    });
};

/**
 * Update an event
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         id                          The id of the event to update
 * @param  {Object}         update                      The updates to persist
 * @param  {string}         [update.description]        Updated event description
 * @param  {string}         [update.displayName]        Updated event name
 * @param  {number}         [update.end]                Updated timestamp (ISO 8601) at which the event ends
 * @param  {string}         [update.location]           Updated location of the event
 * @param  {group}          [update.group]              Updated id of the group that can manage the event
 * @param  {string}         [update.notes]              Updated notes for the event
 * @param  {number}         [update.start]              Updated timestamp (ISO 8601) at which the event starts
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Event}          callback.event              The updated event
 */
var updateEvent = module.exports.updateEvent = function(ctx, id, update, callback) {
    update = update || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can update events'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
    validator.check(_.keys(update).length, {'code': 400, 'msg': 'At least 1 update value must be provided'}).min(1);
    if (update.displayName) {
        validator.check(update.displayName, {'code': 400, 'msg': 'A displayName can be at most 256 characters long'}).isShortString();
    }
    if (update.start) {
        validator.check(update.start, {'code': 400, 'msg': 'A start time must be provided in a valid date format'}).isDate();
    }
    if (update.end) {
        validator.check(update.end, {'code': 400, 'msg': 'An end time must be provided in a valid date format'}).isDate();
    }
    if (update.description) {
        validator.check(update.description, {'code': 400, 'msg': 'A description can be at most 1000 characters long'}).isMediumString();
    }
    if (update.group) {
        validator.check(update.group, {'code': 400, 'msg': 'A valid group id must be provided'}).isInt();
    }
    if (update.location) {
        validator.check(update.location, {'code': 400, 'msg': 'A location can be at most 256 characters long'}).isShortString();
    }
    if (update.notes) {
        validator.check(update.notes, {'code': 400, 'msg': 'Notes can be at most 10000 characters long'}).isLongString();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getEvent(ctx, id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // Ensure that the start of the event is still before the end of
        // the event, event if we only update one field
        update.start = update.start || event.start;
        update.end = update.end || event.end;
        validator.check(update.start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(update.end);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        // Ensure that the specified group (if any) belongs
        // to the same application as the event
        _validateOptionalGroup(ctx, update.group, event.AppId, function(err) {
            if (err) {
                return callback(err);
            }

            // Ensure that the current user is allowed to update the event
            EventsAuthz.canUpdateEvent(ctx, event, function(err, canUpdateEvent) {
                if (err) {
                    return callback(err);
                } else if (!canUpdateEvent) {
                    return callback({'code': 401, 'msg': 'You are not allowed to update this event'});
                }

                // The DAO will make inline changes to the `event` instance. If we wish to provide
                // the old instance in the emitted event we need to take a copy here. We cannot take
                // a copy of the full `event` instance as that has things such as connections and/or
                // transactions associated to it, which could lead to potentially confusing situations
                // further in the future so we simply serialise it
                var oldEvent = event.toJSON();
                EventsDAO.updateEvent(event, update, function(err, updatedEvent) {
                    if (err) {
                        return callback(err);
                    }

                    EventsAPI.emit(EventsConstants.events.UPDATED_EVENT, ctx, oldEvent, updatedEvent);

                    return callback(null, updatedEvent);
                });
            });
        });
    });
};

/**
 * Update the organisers of an event
 *
 * @param  {Context}        ctx                     Standard context containing the current user and the current app
 * @param  {Number}         id                      The id of the event for which to update the organisers
 * @param  {Object}         [updateById]            The updates to make to the linked organisers. Each key should be a number referencing a user id, each value should be a boolean indicating whether the user needs to be added (`true`) or removed (`false`)
 * @param  {Object}         [updateByText]          The updates to make to the plain text organisers. Each key should be a plain-text string, each value should be a boolean indicating whether the organisers needs to be added (`true`) or removed (`false`)
 * @param  {Function}       callback                Standard callback function
 * @param  {Object}         callback.err            An error object, if any
 * @param  {Event}          callback.event          The updated event
 */
var updateEventOrganisers = module.exports.updateEventOrganisers = function(ctx, id, updateById, updateByText, callback) {
    updateById = updateById || {};
    updateByText = updateByText || {};

    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can update events'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
    var totalChanges = _.keys(updateById).length + _.keys(updateByText).length;
    validator.check(totalChanges, {'code': 400, 'msg': 'At least 1 update value must be provided'}).min(1);
    _.each(updateById, function(val, user) {
        user = GrasshopperUtil.getNumberParam(user);
        updateById[user] = GrasshopperUtil.getBooleanParam(val);
        validator.check(user, {'code': 400, 'msg': 'A valid user id must be provided'}).isInt();
        validator.check(null, {'code': 400, 'msg': 'A valid organiser change must be a boolean value'}).isBoolean(updateById[user]);
    });
    _.each(updateByText, function(val, user) {
        updateByText[user] = GrasshopperUtil.getBooleanParam(val);
        validator.check(null, {'code': 400, 'msg': 'A valid organiser change must be a boolean value'}).isBoolean(updateByText[user]);
    });
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure the event exists
    getEvent(ctx, id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // Ensure the specified users exist, if any
        var userIds = _.keys(updateById);
        _validateOptionalUsers(ctx, userIds, event.AppId, function(err) {
            if (err) {
                return callback(err);
            }

            // Ensure that the current user is allowed to update the event
            EventsAuthz.canUpdateEvent(ctx, event, function(err, canUpdateEvent) {
                if (err) {
                    return callback(err);
                } else if (!canUpdateEvent) {
                    return callback({'code': 401, 'msg': 'You are not allowed to update this event'});
                }

                // The DAO will make inline changes to the `event` instance. If we wish to provide
                // the old instance in the emitted event we need to take a copy here. We cannot take
                // a copy of the full `event` instance as that has things such as connections and/or
                // transactions associated to it, which could lead to potentially confusing situations
                // further in the future so we simply serialise it
                var oldEvent = event.toJSON();
                EventsDAO.updateEventOrganisers(event, updateById, updateByText, function(err, updatedEvent) {
                    if (err) {
                        return callback(err);
                    }

                    EventsAPI.emit(EventsConstants.events.UPDATED_EVENT, ctx, oldEvent, updatedEvent);

                    return callback(null, updatedEvent);
                });
            });
        });
    });
};

/**
 * Ensure that a group, if any, exists and belongs to the given application
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         groupId             The id of the group to retrieve
 * @param  {Number}         appId               The id of the application that the group should belong to
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Group}          callback.group      The retrieved group
 * @api private
 */
var _validateOptionalGroup = function(ctx, groupId, appId, callback) {
    if (!groupId) {
        return callback();
    }

    GroupsDAO.getGroup(groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (group.AppId !== appId) {
            return callback({'code': 401, 'msg': 'The specified group does not belong to the same application as the event'});
        }

        return callback(null, group);
    });
};

/**
 * Ensure that a serie, if any, exists and belongs to the given application
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number[]}       series              The id(s) of the serie(s) to retrieve
 * @param  {Number}         appId               The id of the application that the series should belong to
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Serie[]}        callback.series     The retrieved series
 * @api private
 */
var _validateOptionalSeries = function(ctx, series, appId, callback) {
    if (_.isEmpty(series)) {
        return callback();
    }

    SeriesDAO.getSeries(series, function(err, series) {
        if (err) {
            return callback(err);
        }

        // Ensure each serie belongs to the same application as the event
        var otherAppSeries = _.reject(series, {'AppId': appId});
        if (!_.isEmpty(otherAppSeries)) {
            return callback({'code': 401, 'msg': 'You cannot add an event to a serie from another application'});
        }

        return callback(null, series);
    });
};

/**
 * Ensure that a set of users, if any, exist and belong to the given application
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number[]}       userIds             The id(s) of the user(s) to retrieve
 * @param  {Number}         appId               The id of the application that the user(s) should belong to
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {User[]}         callback.users      The retrieved users
 * @api private
 */
var _validateOptionalUsers = function(ctx, userIds, appId, callback) {
    if (_.isEmpty(userIds)) {
        return callback();
    }

    UsersDAO.getUsersById(appId, userIds, callback);
};

/**
 * Delete an event
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the event to delete
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteEvent = module.exports.deleteEvent = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that the event exists
    getEvent(ctx, id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // Ensure that the current user is allowed to delete the event
        EventsAuthz.canDeleteEvent(ctx, event, function(err, canDeleteEvent) {
            if (err) {
                return callback(err);
            } else if (!canDeleteEvent) {
                return callback({'code': 401, 'msg': 'You are not allowed to delete this event'});
            }

            EventsDAO.deleteEvent(event, callback);
        });
    });
};
