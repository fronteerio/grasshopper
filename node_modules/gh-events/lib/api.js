/**
 * Copyright (c) 2014 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var GrasshopperUtil = require('gh-core/lib/util');
var GroupsAPI = require('gh-groups');
var GroupsDAO = require('gh-groups/lib/internal/dao');
var log = require('gh-core/lib/logger').logger('gh-events');
var UsersDAO = require('gh-users/lib/internal/dao');
var Validator = require('gh-core/lib/validator').Validator;

var EventsAuthz = require('./authz');
var EventsDAO = require('./internal/dao');

/**
 * Create a new event
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         appId                       The id of the application that this event will belong to
 * @param  {String}         displayName                 The name of the event
 * @param  {Number}         start                       When the event starts, in millis since epoch (UTC)
 * @param  {Number}         end                         When the event ends, in millis since epoch (UTC)
 * @param  {Object}         [opts]                      A set of optional parameters
 * @param  {String}         [opts.description]          The description of the event
 * @param  {Number}         [opts.group]                The id of the group that can manage the event
 * @param  {String}         [opts.location]             The location of the event
 * @param  {String}         [opts.notes]                The notes for the event
 * @param  {String}         [opts.organiserOther]       The name(s) of the unrecognised user(s) that organise the event. If no organisers are added, the current user will be added as the organiser
 * @param  {Number[]}       [opts.organiserUsers]       The id(s) of the recognised user(s) that organise the event
 * @param  {Number[]}       [opts.serie]                The id(s) of the serie(s) that the event belongs to
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Event}          callback.event              The created event
 */
var createEvent = module.exports.createEvent = function(ctx, appId, displayName, start, end, opts, callback) {
    opts = opts || {};
    appId = appId || ctx.app.id;

    // TODO: Validate series exist, if any (and are within the same app)
    // TODO: Series
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can create events'}).isLoggedInUser(ctx);
    validator.check(appId, {'code': 400, 'msg': 'A valid application must be a positive integer'}).isInt();
    validator.check(displayName, {'code': 400, 'msg': 'A valid displayName must be provided'}).isShortString();
    validator.check(start, {'code': 400, 'msg': 'A valid start time must be provided'}).notEmpty();
    validator.check(start, {'code': 400, 'msg': 'A valid start time must be provided'}).isDate();
    validator.check(end, {'code': 400, 'msg': 'A valid end time must be provided'}).notEmpty();
    validator.check(end, {'code': 400, 'msg': 'A valid end time must be provided'}).isDate();
    validator.check(start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(end);
    if (opts.description) {
        validator.check(opts.description, {'code': 400, 'msg': 'If provided, a description cannot contain more than 1000 characters'}).isMediumString();
    }
    if (opts.group) {
        // Ensure that the group id is a valid number, if any
        opts.group = GrasshopperUtil.getNumberParam(opts.group);
        validator.check(opts.group, {'code': 400, 'msg': 'If provided, a group must be a valid integer'}).isInt();
    }
    if (opts.location) {
        validator.check(opts.location, {'code': 400, 'msg': 'If provided, a location cannot contain more than 256 characters'}).isShortString();
    }
    if (opts.notes) {
        validator.check(opts.notes, {'code': 400, 'msg': 'If provided, notes cannot contain more than 10000 characters'}).isLongString();
    }
    if (opts.organiserOther) {
        validator.check(null, {'code': 400, 'msg': 'Plain-text organisers should be specified as an array'}).isArray(opts.organiserOther);
        _.each(opts.organiserOther, function(organiser) {
            validator.check(organiser, {'code': 400, 'msg': 'Each plain-text organiser cannot contain more than 256 characters'}).isShortString();
            validator.check(organiser, {'code': 400, 'msg': 'A plain-text organiser cannot contain a comma'}).notContains(',');
        });
    }
    if (opts.organiserUsers) {
        validator.check(null, {'code': 400, 'msg': 'Organiser users should be specified as an array'}).isArray(opts.organiserUsers);
        _.each(opts.organiserUsers, function(userId) {
            validator.check(userId, {'code': 400, 'msg': 'An individual organiser user should be specified by its id'}).isInt();
        });
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    // Ensure that the app id is a valid number
    appId = GrasshopperUtil.getNumberParam(appId);

    // Ensure the event is created on the correct application
    if (ctx.app.id !== appId && !ctx.user.isGlobalAdmin()) {
        return callback({'code': 401, 'msg': 'Only global administrators can create events on other applications'});
    }

    // Ensure the specified users exist, if any
    var userIds = opts.organiserUsers || [];
    UsersDAO.getUsers(appId, userIds, function(err, users) {
        if (err) {
            return callback(err);
        }
        opts.organiserUsers = users;

        // If no organisers were specified, we make the current user the organiser
        if (_.isEmpty(opts.organiserOther) && _.isEmpty(opts.organiserUsers)) {
            opts.organiserUsers = [ctx.user];
        }

        // Get or create the group
        GroupsAPI.getOrCreateGroup(ctx, appId, opts.group, function(err, group) {
            if (err) {
                return callback(err);
            }

            // Ensure `opts.group` points to a valid group
            opts.group = group.id;

            // Create the event
            EventsDAO.createEvent(appId, displayName, start, end, opts, callback);
        });
    });
};

/**
 * Get an event
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the event to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Event}          callback.event      The requested event
 */
var getEvent = module.exports.getEvent = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid event id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    EventsDAO.getEvent(id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // Ensure that the event is either being requested from the app it belongs to
        // or from an authenticated user on the global admin
        if (event.AppId !== ctx.app.id && !ctx.user.isGlobalAdmin()) {
            return callback({'code': 401, 'msg': 'This event cannot be retrieved on this application'});
        }

        return callback(null, event);
    });
};

/**
 * Update an event
 *
 * @param  {Context}        ctx                         Standard context containing the current user and the current app
 * @param  {Number}         id                          The id of the event to update
 * @param  {Object}         update                      The updates to persist
 * @param  {String}         [update.displayName]        The name of the event
 * @param  {Number}         [update.start]              When the event starts, in millis since epoch (UTC)
 * @param  {Number}         [update.end]                When the event ends, in millis since epoch (UTC)
 * @param  {String}         [update.description]        The description of the event
 * @param  {Number}         [update.group]              The id of the group that can manage the event
 * @param  {String}         [update.location]           The location of the event
 * @param  {String}         [update.notes]              The notes for the event
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error object, if any
 * @param  {Event}          callback.event              The updated event
 */
var updateEvent = module.exports.updateEvent = function(ctx, id, update, callback) {
    update = update || {};

    // TODO: Validate series exist, if any (and are within the same app)
    // TODO: Validate group exist, if any (and are within the same app)
    var validator = new Validator();
    validator.check(null, {'code': 401, 'msg': 'Only authenticated users can create events'}).isLoggedInUser(ctx);
    validator.check(id, {'code': 400, 'msg': 'A valid id must be provided'}).isInt();
    validator.check(_.keys(update).length, {'code': 400, 'msg': 'Must provide at least 1 field to update'}).min(1);
    if (update.displayName) {
        validator.check(update.displayName, {'code': 400, 'msg': 'A valid displayName cannot contain more than 256 characters'}).isShortString();
    }
    if (update.start) {
        validator.check(update.start, {'code': 400, 'msg': 'A start time must be provided in a valid date format'}).isDate();
    }
    if (update.end) {
        validator.check(update.end, {'code': 400, 'msg': 'An end time must be provided in a valid date format'}).isDate();
    }
    if (update.description) {
        validator.check(update.description, {'code': 400, 'msg': 'A description cannot contain more than 1000 characters'}).isMediumString();
    }
    if (update.group) {
        validator.check(update.group, {'code': 400, 'msg': 'A group must be an integer'}).isInt();
    }
    if (update.location) {
        validator.check(update.location, {'code': 400, 'msg': 'A location cannot contain more than 256 characters'}).isShortString();
    }
    if (update.notes) {
        validator.check(update.notes, {'code': 400, 'msg': 'Notes cannot contain more than 10000 characters'}).isLongString();
    }
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getEvent(ctx, id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // Ensure that the start of the event is still before the end of
        // the event, event if we only update one field
        update.start = update.start || event.start;
        update.end = update.end || event.end;
        validator.check(update.start, {'code': 400, 'msg': 'The start time must be before the end time'}).isBefore(update.end);
        if (validator.hasErrors()) {
            return callback(validator.getFirstError());
        }

        // Ensure that the specified group (if any) belongs
        // to the same application as the event
        _validateOptionalGroup(ctx, update.group, event.AppId, function(err) {
            if (err) {
                return callback(err);
            }

            // Ensure that the current user is allowed to update the event
            EventsAuthz.canUpdateEvent(ctx, event, function(err, canUpdateEvent) {
                if (err) {
                    return callback(err);
                } else if (!canUpdateEvent) {
                    return callback({'code': 401, 'msg': 'You are not allowed to update this event'});
                }

                EventsDAO.updateEvent(event, update, callback);
            });
        });
    });
};

var _validateOptionalGroup = function(ctx, groupId, appId, callback) {
    if (!groupId) {
        return callback();
    }

    GroupsDAO.getGroup(groupId, function(err, group) {
        if (err) {
            return callback(err);
        } else if (group.AppId !== appId) {
            return callback({'code': 401, 'msg': 'The specified group does not belong to the same application as the event'});
        }
    });
};

/**
 * Delete an event
 *
 * @param  {Context}        ctx                 Standard context containing the current user and the current app
 * @param  {Number}         id                  The id of the event to delete
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var deleteEvent = module.exports.deleteEvent = function(ctx, id, callback) {
    var validator = new Validator();
    validator.check(id, {'code': 400, 'msg': 'A valid id must be provided'}).isInt();
    if (validator.hasErrors()) {
        return callback(validator.getFirstError());
    }

    getEvent(ctx, id, function(err, event) {
        if (err) {
            return callback(err);
        }

        // TODO: Ensure the current user is allowed to delete this event
        EventsDAO.deleteEvent(event, callback);
    });
};
