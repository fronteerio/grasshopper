/**
 * Copyright (c) 2015 "Fronteer LTD"
 * Grasshopper Event Engine
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var _ = require('lodash');

var DB = require('gh-core/lib/db');
var GrasshopperUtil = require('gh-core/lib/util');
var log = require('gh-core/lib/logger').logger('gh-events');

/**
 * Create a new event
 *
 * @param  {Number}         appId                       The id of the application that this event will belong to
 * @param  {String}         displayName                 The name of the event
 * @param  {String}         start                       The timestamp (ISO 8601) at which the event starts
 * @param  {String}         end                         The timestamp (ISO 8601) at which the event ends
 * @param  {Object}         [opts]                      A set of optional parameters
 * @param  {String}         [opts.description]          The description of the event
 * @param  {Number}         [opts.group]                The id of the group that can manage the event
 * @param  {String}         [opts.location]             The location of the event
 * @param  {String}         [opts.notes]                The notes for the event
 * @param  {String[]}       [opts.organiserOther]       The name(s) of the unrecognised user(s) that organise the event. If no organisers are added, the current user will be added as the organiser
 * @param  {Number[]}       [opts.organiserUsers]       The id(s) of the recognised user(s) that organise the event
 * @param  {Number[]}       [opts.series]               The id(s) of the serie(s) that the event belongs to
 * @param  {String}         [opts.type]                 The type of the event
 * @param  {String}         [opts.externalId]           The external id of the event
 */
var createEvent = module.exports.createEvent = function(appId, displayName, start, end, opts, callback) {
    opts = opts || {};
    opts.organiserUsers = opts.organiserUsers || [];
    opts.series = opts.series || [];

    // TODO: Transactions
    var event = {
        'AppId': appId,
        'description': opts.description,
        'displayName': displayName,
        'end': end,
        'externalId': opts.externalId,
        'GroupId': opts.group,
        'location': opts.location,
        'notes': opts.notes,
        'organiserOther': opts.organiserOther,
        'start': start,
        'type': opts.type
    };

    DB.Event.create(event).complete(function(err, event) {
        if (err) {
            log().error({'err': err}, 'Failed to create a new event');
            return callback({'code': 500, 'msg': err.message});
        }

        event.setOrganisers(opts.organiserUsers).complete(function(err) {
            if (err) {
                log().error({'err': err}, 'Failed to add the organisers on a new event');
                return callback({'code': 500, 'msg': err.message});
            }

            event.setSeries(opts.series).complete(function(err) {
                if (err) {
                    log().error({'err': err}, 'Failed to add the event under the series');
                    return callback({'code': 500, 'msg': err.message});
                }

                return getEvent(event.id, callback);
            });
        });
    });
};

/**
 * Get an event
 *
 * @param  {Number}         id                  The id of the event to retrieve
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 * @param  {Event}          callback.event      The requested event
 */
var getEvent = module.exports.getEvent = function(id, callback) {
    var options = {
        'where': {'id': id},
        'include': [
            {'model': DB.App},
            {'model': DB.Group},
            {'model': DB.User, 'as': 'Organisers'}
        ]
    };
    DB.Event.find(options).complete(function(err, event) {
        if (err) {
            log().error({'err': err, 'id': id}, 'Failed to get an event');
            return callback({'code': 500, 'msg': err.message});
        } else if (!event) {
            log().debug({'id': id}, 'An event with the specified id could not be found');
            return callback({'code': 404, 'msg': 'An event with the specified id could not be found'});
        }

        return callback(null, event);
    });
};

/**
 * Get a set of events
 *
 * @param  {Number[]}       ids                             The ids of the events to retrieve
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error object, if any
 * @param  {Event[]}        callback.events                 The requested events
 */
var getEvents = module.exports.getEvents = function(ids, callback) {
    if (_.isEmpty(ids)) {
        return callback(null, []);
    }

    var options = {
        'where': {'id': ids},
        'include': [
            {'model': DB.User, 'as': 'Organisers'}
        ]
    };
    DB.Event.findAll(options).complete(function(err, events) {
        if (err) {
            log().error({'err': err, 'ids': ids}, 'Failed to get a set of events');
            return callback({'code': 500, 'msg': err.message});
        } else if (!events || events.length !== ids.length) {
            log().debug({'ids': ids}, 'Not all events could be found');
            return callback({'code': 404, 'msg': 'Not all events could be found'});
        }

        return callback(null, events);
    });
};

/**
 * Update an event
 *
 * @param  {Event}      event               The event to update
 * @param  {object}     update              The updates to persist
 * @param  {Function}   callback            Standard callback function
 * @param  {Object}     callback.err        An error object, if any
 * @param  {Event}      callback.event      The updated event
 */
var updateEvent = module.exports.updateEvent = function(event, update, callback) {
    event.updateAttributes(update).complete(function(err, event) {
        if (err) {
            log().error({'err': err}, 'Failed to update an event');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'event': event, 'update': update}, 'Updated an event');
        return callback(null, event);
    });
};

/**
 * Update the organisers of an event
 *
 * @param  {Event}      event                   The event for which to update the organisers
 * @param  {Object}     [updateById]            The updates to make to the linked organisers. Each key should be a number referencing a user id, each value should be a boolean indicating whether the user needs to be added (`true`) or removed (`false`)
 * @param  {Object}     [updateByText]          The updates to make to the plain text organisers. Each key should be a plain-text string, each value should be a boolean indicating whether the organisers needs to be added (`true`) or removed (`false`)
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {Event}      callback.event          The updated event
 */
var updateEventOrganisers = module.exports.updateEventOrganisers = function(event, updateById, updateByText, callback) {
    // TODO: Transactions

    // Get the organisers that are already associated with the event
    getOrganisers(event, function(err, organisers) {
        if (err) {
            return callback(err);
        }

        // Build up the new full set of organisers
        var organisersById = _.indexBy(organisers, 'id');
        _.each(updateById, function(val, userId) {
            if (val) {
                organisersById[userId] = true;
            } else {
                delete organisersById[userId];
            }
        });

        // Persist the new organisers. We need to pass in an array of *numbers* as sequelize
        // will do a strict comparison between the provided data and the organisers (=user ids)
        // that are already present in the join table. Passing in numbers would fail that comparison
        // and cause a "DuplicateKey" exception in Postgresql
        var organiserIds = _.chain(organisersById)
            .keys()
            .map(function(userId) {
                return parseInt(userId, 10);
            })
            .value();
        event.setOrganisers(organiserIds).complete(function(err) {
            if (err) {
                log().error({'err': err, 'id': event.id}, 'Failed to update the organisers for an event');
                return callback({'code': 500, 'msg': err.message});
            }

            // Get the plain-text organisers that are already associated with the event
            var organisersByText = {};
            _.each(event.organiserOther, function(name) {
                organisersByText[name] = true;
            });

            // Add and/or remove the plain-text organisers
            _.each(updateByText, function(val, organiserName) {
                if (val) {
                    organisersByText[organiserName] = true;
                } else {
                    delete organisersByText[organiserName];
                }
            });

            // Persist the plain-text organisers
            var plainTextOrganisers = _.keys(organisersByText);
            updateEvent(event, {'organiserOther': plainTextOrganisers}, callback);
        });
    });
};

/**
 * Delete an event
 *
 * @param  {Event}      event           The event to delete
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error object, if any
 */
var deleteEvent = module.exports.deleteEvent = function(event, callback) {
    event.destroy().complete(function(err) {
        if (err) {
            log().error({'err': err, 'id': event.id}, 'Failed to delete an event');
            return callback({'code': 500, 'msg': err.message});
        }

        log().debug({'event': event}, 'Deleted an event');
        return callback();
    });
};

/**
 * Get the organisers for an event
 *
 * @param  {Event}      event                   The event for which to get the organisers
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {User[]}     callback.organisers     The organisers of the event
 */
var getOrganisers = module.exports.getOrganisers = function(event, callback) {
    event.getOrganisers().complete(function(err, organisers) {
        if (err) {
            log().error({'err': err, 'id': event.id}, 'Failed to get the organisers for an event');
            return callback({'code': 500, 'msg': err.message});
        }

        return callback(null, organisers);
    });
};

/**
 * Get the series for an event
 *
 * @param  {Event}      event                   The event for which to get the series
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error object, if any
 * @param  {Serie[]}    callback.series         The series for an the event
 */
var getSeries = module.exports.getSeries = function(event, callback) {
    event.getSeries().complete(function(err, series) {
        if (err) {
            log().error({'err': err, 'id': event.id}, 'Failed to get the series for an event');
            return callback({'code': 500, 'msg': err.message});
        }

        return callback(null, series);
    });
};
